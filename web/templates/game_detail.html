{% extends "base.html" %}

{% block title %}{{ away_team }} @ {{ home_team }} - Player Management{% endblock %}

{% block content %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <div>
        <h1>{{ away_team }} @ {{ home_team }}</h1>
        <p class="subtitle">{{ game_date }}</p>
    </div>
    <a href="/model-config" target="_blank" class="gear-icon" title="Model Configuration">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M19.4 15C19.2669 15.3016 19.2272 15.6362 19.286 15.9606C19.3448 16.285 19.4995 16.5843 19.73 16.82L19.79 16.88C19.976 17.0657 20.1235 17.2863 20.2241 17.5291C20.3248 17.7719 20.3766 18.0322 20.3766 18.295C20.3766 18.5578 20.3248 18.8181 20.2241 19.0609C20.1235 19.3037 19.976 19.5243 19.79 19.71C19.6043 19.896 19.3837 20.0435 19.1409 20.1441C18.8981 20.2448 18.6378 20.2966 18.375 20.2966C18.1122 20.2966 17.8519 20.2448 17.6091 20.1441C17.3663 20.0435 17.1457 19.896 16.96 19.71L16.9 19.65C16.6643 19.4195 16.365 19.2648 16.0406 19.206C15.7162 19.1472 15.3816 19.1869 15.08 19.32C14.7842 19.4468 14.532 19.6572 14.3543 19.9255C14.1766 20.1938 14.0813 20.5082 14.08 20.83V21C14.08 21.5304 13.8693 22.0391 13.4942 22.4142C13.1191 22.7893 12.6104 23 12.08 23C11.5496 23 11.0409 22.7893 10.6658 22.4142C10.2907 22.0391 10.08 21.5304 10.08 21V20.91C10.0723 20.579 9.96512 20.258 9.77251 19.9887C9.5799 19.7194 9.31074 19.5143 9 19.4C8.69838 19.2669 8.36381 19.2272 8.03941 19.286C7.71502 19.3448 7.41568 19.4995 7.18 19.73L7.12 19.79C6.93425 19.976 6.71368 20.1235 6.47088 20.2241C6.22808 20.3248 5.96783 20.3766 5.705 20.3766C5.44217 20.3766 5.18192 20.3248 4.93912 20.2241C4.69632 20.1235 4.47575 19.976 4.29 19.79C4.10405 19.6043 3.95653 19.3837 3.85588 19.1409C3.75523 18.8981 3.70343 18.6378 3.70343 18.375C3.70343 18.1122 3.75523 17.8519 3.85588 17.6091C3.95653 17.3663 4.10405 17.1457 4.29 16.96L4.35 16.9C4.58054 16.6643 4.73519 16.365 4.794 16.0406C4.85282 15.7162 4.81312 15.3816 4.68 15.08C4.55324 14.7842 4.34276 14.532 4.07447 14.3543C3.80618 14.1766 3.49179 14.0813 3.17 14.08H3C2.46957 14.08 1.96086 13.8693 1.58579 13.4942C1.21071 13.1191 1 12.6104 1 12.08C1 11.5496 1.21071 11.0409 1.58579 10.6658C1.96086 10.2907 2.46957 10.08 3 10.08H3.09C3.42099 10.0723 3.742 9.96512 4.01131 9.77251C4.28062 9.5799 4.48568 9.31074 4.6 9C4.73312 8.69838 4.77282 8.36381 4.714 8.03941C4.65519 7.71502 4.50054 7.41568 4.27 7.18L4.21 7.12C4.02405 6.93425 3.87653 6.71368 3.77588 6.47088C3.67523 6.22808 3.62343 5.96783 3.62343 5.705C3.62343 5.44217 3.67523 5.18192 3.77588 4.93912C3.87653 4.69632 4.02405 4.47575 4.21 4.29C4.39575 4.10405 4.61632 3.95653 4.85912 3.85588C5.10192 3.75523 5.36217 3.70343 5.625 3.70343C5.88783 3.70343 6.14808 3.75523 6.39088 3.85588C6.63368 3.95653 6.85425 4.10405 7.04 4.29L7.1 4.35C7.33568 4.58054 7.63502 4.73519 7.95941 4.794C8.28381 4.85282 8.61838 4.81312 8.92 4.68H9C9.29577 4.55324 9.54802 4.34276 9.72569 4.07447C9.90337 3.80618 9.99872 3.49179 10 3.17V3C10 2.46957 10.2107 1.96086 10.5858 1.58579C10.9609 1.21071 11.4696 1 12 1C12.5304 1 13.0391 1.21071 13.4142 1.58579C13.7893 1.96086 14 2.46957 14 3V3.09C14.0013 3.41179 14.0966 3.72618 14.2743 3.99447C14.452 4.26276 14.7042 4.47324 15 4.6C15.3016 4.73312 15.6362 4.77282 15.9606 4.714C16.285 4.65519 16.5843 4.50054 16.82 4.27L16.88 4.21C17.0657 4.02405 17.2863 3.87653 17.5291 3.77588C17.7719 3.67523 18.0322 3.62343 18.295 3.62343C18.5578 3.62343 18.8181 3.67523 19.0609 3.77588C19.3037 3.87653 19.5243 4.02405 19.71 4.21C19.896 4.39575 20.0435 4.61632 20.1441 4.85912C20.2448 5.10192 20.2966 5.36217 20.2966 5.625C20.2966 5.88783 20.2448 6.14808 20.1441 6.39088C20.0435 6.63368 19.896 6.85425 19.71 7.04L19.65 7.1C19.4195 7.33568 19.2648 7.63502 19.206 7.95941C19.1472 8.28381 19.1869 8.61838 19.32 8.92V9C19.4468 9.29577 19.6572 9.54802 19.9255 9.72569C20.1938 9.90337 20.5082 9.99872 20.83 10H21C21.5304 10 22.0391 10.2107 22.4142 10.5858C22.7893 10.9609 23 11.4696 23 12C23 12.5304 22.7893 13.0391 22.4142 13.4142C22.0391 13.7893 21.5304 14 21 14H20.91C20.5882 14.0013 20.2738 14.0966 20.0055 14.2743C19.7372 14.452 19.5268 14.7042 19.4 15Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>

<div style="margin-bottom: 20px;">
    <a href="/?date={{ game_date }}" style="color: #667eea; text-decoration: none;">← Back to games</a>
</div>

<div class="action-bar">
    <button class="refresh-btn" onclick="loadPlayersFromAPI()" title="Load Players from API">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M17.5 2.5V7.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M2.5 12.5V17.5H7.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M15.8333 10C15.8333 13.2217 13.2217 15.8333 10 15.8333C6.77833 15.8333 4.16667 13.2217 4.16667 10C4.16667 6.77833 6.77833 4.16667 10 4.16667C11.6667 4.16667 13.1667 4.83333 14.1667 6L17.5 2.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M2.5 17.5L5.83333 14.1667C6.83333 15.1667 8.33333 15.8333 10 15.8333" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </button>
    <button class="predict-btn" id="generate-prediction-btn" onclick="generatePrediction()">Generate Prediction</button>
    <button class="action-bar-message-btn" onclick="openMatchupChat('{{ game_id }}', '{{ home_team }}', '{{ away_team }}', '{{ game_date }}')" title="Chat about matchup">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
    </button>
</div>

<div class="game-layout">
    <!-- Away Team -->
    <div class="team-section away-team" data-team-color="#{{ away_team_color }}" data-team-alternate-color="#{{ away_team_alternate_color }}">
        {% if away_team_logo %}
        <div class="team-logo-container">
            <img src="{{ away_team_logo }}" alt="{{ away_team }} logo" class="team-logo">
        </div>
        {% endif %}
        <div class="team-records">
            <div class="record-item">
                <span class="record-label">W-L:</span>
                <span class="record-value">{{ away_records.overall.record }}</span>
            </div>
            <div class="record-item">
                <span class="record-label">Home:</span>
                <span class="record-value">{{ away_records.home.record }}</span>
            </div>
            <div class="record-item">
                <span class="record-label">Away:</span>
                <span class="record-value">{{ away_records.away.record }}</span>
            </div>
            <div class="record-item">
                <span class="record-label">Last 10:</span>
                <span class="record-value">{{ away_records.last10.record }}</span>
            </div>
        </div>
        <h2 class="team-header away">
            {{ away_team }}
            {% if pregame_lines and pregame_lines.get('away_ml') is not none %}
            <span class="moneyline">({{ "+" if pregame_lines['away_ml'] >= 0 else "" }}{{ pregame_lines['away_ml'] }})</span>
            {% endif %}
            <button class="info-btn" onclick="showGameFeatures('{{ game_id }}', '{{ game_date }}', '{{ home_team }}', '{{ away_team }}')" title="View feature values">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="9" cy="9" r="8" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M9 6V9M9 12H9.01" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="message-btn" onclick="openMatchupChat('{{ game_id }}', '{{ home_team }}', '{{ away_team }}', '{{ game_date }}')" title="Chat about matchup">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
            </button>
        </h2>
        {% if pregame_lines and pregame_lines.get('spread') is not none %}
        {% set away_spread = -pregame_lines['spread'] %}
        <div class="spread" style="color: #{{ away_team_color }};">
            {{ "+" if away_spread >= 0 else "" }}{{ "%.1f"|format(away_spread) }}
        </div>
        {% endif %}
        {% if last_prediction and last_prediction.get('away_win_prob') is not none %}
        <div class="prediction-banner">
            {{ "%.0f"|format(last_prediction['away_win_prob']) }}%
            {% if last_prediction.get('away_odds') is not none %}
            ({{ "+" if last_prediction['away_odds'] >= 0 else "" }}{{ "%.0f"|format(last_prediction['away_odds']) }})
            {% endif %}
        </div>
        {% endif %}
        {% if last_prediction and last_prediction.get('away_points_pred') is not none %}
        <div class="points-prediction">
            {{ "%.0f"|format(last_prediction['away_points_pred']) }} pts
        </div>
        {% endif %}
        <div class="players-grid" ondrop="handleDrop(event, '{{ away_team }}')" ondragover="handleDragOver(event)" ondragenter="handleDragEnter(event)" ondragleave="handleDragLeave(event)">
            {% for player in away_players %}
            {% if player.player_name %}
            {% set pos_abbr = get_position_abbreviation(player.pos_display_name or '') %}
            <div class="player-tag-wrapper" data-player-id="{{ player.player_id }}" data-team="{{ away_team }}">
                <div class="player-tag{% if player.is_injured %} injured{% endif %}{% if player.is_gtd %} gtd{% endif %}{% if player.is_starter %} starter{% endif %}" 
                     data-player-id="{{ player.player_id }}" 
                     data-team="{{ away_team }}" 
                     data-is-starter="{{ 'true' if player.is_starter else 'false' }}" 
                     data-position="{{ player.pos_display_name or player.pos_name or '' }}" 
                     data-mpg="{{ player.stats.mpg or 0 }}" 
                     draggable="true" 
                     ondragstart="handleDragStart(event)" 
                     ondragend="handleDragEnd(event)"
                     onmouseenter="showPlayerCard(event, '{{ player.player_id }}', '{{ away_team }}')"
                     onmouseleave="hidePlayerCard(event)">
                    <span class="player-tag-pos">{{ pos_abbr }}</span>
                    <span class="player-tag-injury{% if player.is_injured %} active{% endif %}" onclick="event.stopPropagation(); event.preventDefault(); toggleInjuredTag(this, '{{ player.player_id }}', '{{ away_team }}'); return false;" title="Toggle injury status">
                        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2 6H10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </span>
                    <span class="player-tag-name" onclick="event.stopPropagation(); toggleStarterTag(this, '{{ player.player_id }}', '{{ away_team }}');" title="Click to toggle starter status">{{ player.player_name }}</span>
                    <button class="player-tag-remove" onclick="event.stopPropagation(); removePlayer('{{ player.player_id }}', '{{ away_team }}', this);" title="Remove player">×</button>
                </div>
                <!-- Full card shown on hover -->
                <div class="player-card-hover" id="hover-card-{{ player.player_id }}" style="display: none;" onmouseenter="this.style.display='block'" onmouseleave="hidePlayerCard(event)" data-player-id="{{ player.player_id }}" data-team="{{ away_team }}" data-is-starter="{{ 'true' if player.is_starter else 'false' }}">
                    <span class="player-id">ID: {{ player.player_id }}</span>
                <button class="player-card-remove" onclick="event.stopPropagation(); removePlayer('{{ player.player_id }}', '{{ away_team }}', this);" title="Remove player">×</button>
                <div class="player-card-content">
                    <div class="player-left">
                        {% if player.headshot %}
                        <img src="{{ player.headshot }}" alt="{{ player.player_name }}" class="player-headshot" onerror="this.src='https://a.espncdn.com/combiner/i?img=/i/headshots/nba/players/full/{{ player.player_id }}.png&w=350&h=254'">
                        {% else %}
                        <div class="player-headshot-placeholder">{{ player.player_name[0] }}</div>
                        {% endif %}
                        <div class="player-name-container">
                            <span class="player-name">{{ player.player_name }}</span>
                                <span class="injured-icon{% if player.is_injured %} active{% endif %}" onclick="event.stopPropagation(); event.preventDefault(); toggleInjured(this, '{{ player.player_id }}', '{{ away_team }}'); return false;">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M3 8H13" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                </svg>
                            </span>
                        </div>
                        {% if player.pos_display_name %}
                        <div class="player-position">{{ player.pos_display_name }}</div>
                        {% endif %}
                    </div>
                    <div class="player-middle">
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.ppg }}</span>
                            <span class="stat-label">PPG</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.apg }}</span>
                            <span class="stat-label">APG</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.rpg }}</span>
                            <span class="stat-label">RPG</span>
                        </div>
                    </div>
                    <div class="player-right">
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.gp }}</span>
                            <span class="stat-label">GP</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.per }}</span>
                            <span class="stat-label">PER</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.mpg }}</span>
                            <span class="stat-label">MPG</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}
            {% endfor %}
        </div>
    </div>
    
    <!-- Home Team -->
    <div class="team-section home-team" data-team-color="#{{ home_team_color }}" data-team-alternate-color="#{{ home_team_alternate_color }}">
        {% if home_team_logo %}
        <div class="team-logo-container">
            <img src="{{ home_team_logo }}" alt="{{ home_team }} logo" class="team-logo">
        </div>
        {% endif %}
        <div class="team-records">
            <div class="record-item">
                <span class="record-label">W-L:</span>
                <span class="record-value">{{ home_records.overall.record }}</span>
            </div>
            <div class="record-item">
                <span class="record-label">Home:</span>
                <span class="record-value">{{ home_records.home.record }}</span>
            </div>
            <div class="record-item">
                <span class="record-label">Away:</span>
                <span class="record-value">{{ home_records.away.record }}</span>
            </div>
            <div class="record-item">
                <span class="record-label">Last 10:</span>
                <span class="record-value">{{ home_records.last10.record }}</span>
            </div>
        </div>
        <h2 class="team-header home">
            {{ home_team }}
            {% if pregame_lines and pregame_lines.get('home_ml') is not none %}
            <span class="moneyline">({{ "+" if pregame_lines['home_ml'] >= 0 else "" }}{{ pregame_lines['home_ml'] }})</span>
            {% endif %}
            <button class="info-btn" onclick="showGameFeatures('{{ game_id }}', '{{ game_date }}', '{{ home_team }}', '{{ away_team }}')" title="View feature values">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="9" cy="9" r="8" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M9 6V9M9 12H9.01" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="message-btn" onclick="openMatchupChat('{{ game_id }}', '{{ home_team }}', '{{ away_team }}', '{{ game_date }}')" title="Chat about matchup">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
            </button>
        </h2>
        {% if pregame_lines and pregame_lines.get('spread') is not none %}
        <div class="spread" style="color: #{{ home_team_color }};">
            {{ "%.1f"|format(pregame_lines['spread']) }}
        </div>
        {% endif %}
        {% if last_prediction and last_prediction.get('home_win_prob') is not none %}
        <div class="prediction-banner">
            {{ "%.0f"|format(last_prediction['home_win_prob']) }}%
            {% if last_prediction.get('home_odds') is not none %}
            ({{ "+" if last_prediction['home_odds'] >= 0 else "" }}{{ "%.0f"|format(last_prediction['home_odds']) }})
            {% endif %}
        </div>
        {% endif %}
        {% if last_prediction and last_prediction.get('home_points_pred') is not none %}
        <div class="points-prediction">
            {{ "%.0f"|format(last_prediction['home_points_pred']) }} pts
        </div>
        {% endif %}
        <div class="players-grid" ondrop="handleDrop(event, '{{ home_team }}')" ondragover="handleDragOver(event)" ondragenter="handleDragEnter(event)" ondragleave="handleDragLeave(event)">
            {% for player in home_players %}
            {% if player.player_name %}
            {% set pos_abbr = get_position_abbreviation(player.pos_display_name or '') %}
            <div class="player-tag-wrapper" data-player-id="{{ player.player_id }}" data-team="{{ home_team }}">
                <div class="player-tag{% if player.is_injured %} injured{% endif %}{% if player.is_gtd %} gtd{% endif %}{% if player.is_starter %} starter{% endif %}" 
                     data-player-id="{{ player.player_id }}" 
                     data-team="{{ home_team }}" 
                     data-is-starter="{{ 'true' if player.is_starter else 'false' }}" 
                     data-position="{{ player.pos_display_name or player.pos_name or '' }}" 
                     data-mpg="{{ player.stats.mpg or 0 }}" 
                     draggable="true" 
                     ondragstart="handleDragStart(event)" 
                     ondragend="handleDragEnd(event)"
                     onmouseenter="showPlayerCard(event, '{{ player.player_id }}', '{{ home_team }}')"
                     onmouseleave="hidePlayerCard(event)">
                    <span class="player-tag-pos">{{ pos_abbr }}</span>
                    <span class="player-tag-injury{% if player.is_injured %} active{% endif %}" onclick="event.stopPropagation(); event.preventDefault(); toggleInjuredTag(this, '{{ player.player_id }}', '{{ home_team }}'); return false;" title="Toggle injury status">
                        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2 6H10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </span>
                    <span class="player-tag-name" onclick="event.stopPropagation(); toggleStarterTag(this, '{{ player.player_id }}', '{{ home_team }}');" title="Click to toggle starter status">{{ player.player_name }}</span>
                    <button class="player-tag-remove" onclick="event.stopPropagation(); removePlayer('{{ player.player_id }}', '{{ home_team }}', this);" title="Remove player">×</button>
                </div>
                <!-- Full card shown on hover -->
                <div class="player-card-hover" id="hover-card-{{ player.player_id }}" style="display: none;" onmouseenter="this.style.display='block'" onmouseleave="hidePlayerCard(event)" data-player-id="{{ player.player_id }}" data-team="{{ home_team }}" data-is-starter="{{ 'true' if player.is_starter else 'false' }}">
                    <span class="player-id">ID: {{ player.player_id }}</span>
                <button class="player-card-remove" onclick="event.stopPropagation(); removePlayer('{{ player.player_id }}', '{{ home_team }}', this);" title="Remove player">×</button>
                <div class="player-card-content">
                    <div class="player-left">
                        {% if player.headshot %}
                        <img src="{{ player.headshot }}" alt="{{ player.player_name }}" class="player-headshot" onerror="this.src='https://a.espncdn.com/combiner/i?img=/i/headshots/nba/players/full/{{ player.player_id }}.png&w=350&h=254'">
                        {% else %}
                        <div class="player-headshot-placeholder">{{ player.player_name[0] }}</div>
                        {% endif %}
                        <div class="player-name-container">
                            <span class="player-name">{{ player.player_name }}</span>
                            <span class="injured-icon{% if player.is_injured %} active{% endif %}" onclick="event.stopPropagation(); event.preventDefault(); toggleInjured(this, '{{ player.player_id }}', '{{ home_team }}'); return false;">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M3 8H13" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                                </svg>
                            </span>
                        </div>
                        {% if player.pos_display_name %}
                        <div class="player-position">{{ player.pos_display_name }}</div>
                        {% endif %}
                    </div>
                    <div class="player-middle">
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.ppg }}</span>
                            <span class="stat-label">PPG</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.apg }}</span>
                            <span class="stat-label">APG</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.rpg }}</span>
                            <span class="stat-label">RPG</span>
                        </div>
                    </div>
                    <div class="player-right">
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.gp }}</span>
                            <span class="stat-label">GP</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.per }}</span>
                            <span class="stat-label">PER</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">{{ player.stats.mpg }}</span>
                            <span class="stat-label">MPG</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}
            {% endfor %}
        </div>
    </div>
</div>

<style>
    /* Team color glows - using CSS variables */
    .away-team {
        --away-color: #{{ away_team_color }};
        --away-alt-color: #{{ away_team_alternate_color }};
    }
    
    .home-team {
        --home-color: #{{ home_team_color }};
        --home-alt-color: #{{ home_team_alternate_color }};
    }

    .container {
        /* margin-left: 20%;
        margin-right: 20%; */
        font-size: .9em;
    }
    
    .game-layout {
        display: inline-flex;
        grid-template-columns: calc(50% - 10px) calc(50% - 10px);
        gap: 20px;
        margin-bottom: 30px;
        width: 100%;
        box-sizing: border-box;
    }
    
    .team-section {
        background: #f9f9f9;
        border-radius: 8px;
        padding: 20px;
        overflow-y: auto;
        box-sizing: border-box;
        min-width: 0; /* Prevents grid items from overflowing */
        overflow-x: hidden; /* Prevents horizontal scrolling */
        width: 50%;
        border: 3px solid transparent;
        transition: all 0.3s ease;
    }
    
    .team-section.away-team {
        box-shadow: 0 0 20px var(--away-color, rgba(102, 102, 102, 0.3));
        border-color: var(--away-color, #666);
    }
    
    .team-section.home-team {
        box-shadow: 0 0 20px var(--home-color, rgba(102, 126, 234, 0.3));
        border-color: var(--home-color, #667eea);
    }
    
    .team-logo-container {
        text-align: center;
        margin-bottom: 15px;
    }
    
    .team-logo {
        max-width: 120px;
        max-height: 120px;
        width: auto;
        height: auto;
        object-fit: contain;
    }
    
    .team-header {
        font-size: 1.8em;
        margin-bottom: 10px;
        text-align: center;
        padding-bottom: 10px;
        border-bottom: 3px solid;
    }
    
    .team-header.away {
        color: var(--away-color, #666);
        border-color: var(--away-color, #666);
    }
    
    .team-header.home {
        color: var(--home-color, #667eea);
        border-color: var(--home-color, #667eea);
    }
    
    .moneyline {
        font-size: 0.85em;
        font-weight: normal;
        opacity: 0.8;
        margin-left: 8px;
    }
    
    .spread {
        font-size: 0.9em;
        font-weight: 600;
        text-align: center;
        margin-top: 8px;
        margin-bottom: 8px;
    }
    
    .prediction-banner {
        font-size: 0.85em;
        font-weight: 600;
        color: #667eea;
        background: rgba(102, 126, 234, 0.15);
        padding: 4px 8px;
        border-radius: 4px;
        text-align: center;
        margin-top: 8px;
        margin-bottom: 4px;
    }
    
    .points-prediction {
        font-size: 0.9em;
        font-weight: 600;
        color: #28a745;
        background: rgba(40, 167, 69, 0.15);
        padding: 4px 8px;
        border-radius: 4px;
        text-align: center;
        margin-top: 4px;
        margin-bottom: 12px;
    }
    
    .info-btn,
.message-btn {
        background: transparent;
        border: 1px solid currentColor;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-left: 10px;
        padding: 0;
        color: inherit;
        transition: all 0.2s;
        vertical-align: middle;
    }
    
    .info-btn:hover,
    .message-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: scale(1.1);
    }
    
    .info-btn svg,
    .message-btn svg {
        width: 16px;
        height: 16px;
    }
    
    /* Modal styles */
    .calculation-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
    }
    
    .calculation-modal-content {
        background-color: #fff;
        margin: auto;
        padding: 0;
        border-radius: 8px;
        width: 90%;
        max-width: 900px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .features-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
    }
    
    .features-modal-content {
        background-color: #fff;
        margin: auto;
        padding: 0;
        border-radius: 8px;
        width: 90%;
        max-width: 900px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .features-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        border-bottom: 1px solid #e0e0e0;
        background: #f5f5f5;
        border-radius: 8px 8px 0 0;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .features-modal-header h2 {
        margin: 0;
        font-size: 1.5em;
        color: #333;
    }
    
    .calculation-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        border-bottom: 1px solid #e0e0e0;
        background: #f5f5f5;
        border-radius: 8px 8px 0 0;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .calculation-modal-header h2 {
        margin: 0;
        font-size: 1.5em;
        color: #333;
    }
    
    .close-modal {
        background: none;
        border: none;
        font-size: 2em;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s;
    }
    
    .close-modal:hover {
        background: #e0e0e0;
        color: #333;
    }
    
    .features-modal-body {
        padding: 20px;
    }
    
    .game-info {
        margin-bottom: 20px;
        padding: 15px;
        background: #f9f9f9;
        border-radius: 4px;
        border-left: 4px solid #2196F3;
    }
    
    .game-info strong {
        font-size: 1.2em;
        color: #333;
    }
    
    .game-info small {
        color: #666;
    }
    
    .feature-category {
        margin-bottom: 30px;
    }
    
    .feature-category h3 {
        margin: 0 0 10px 0;
        font-size: 1.1em;
        color: #2196F3;
        font-weight: 600;
    }
    
    .features-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }
    
    .features-table thead {
        background: #f5f5f5;
    }
    
    .features-table th {
        padding: 10px;
        text-align: left;
        font-weight: 600;
        color: #666;
        border-bottom: 2px solid #e0e0e0;
    }
    
    .features-table td {
        padding: 8px 10px;
        border-bottom: 1px solid #f0f0f0;
    }
    
    .features-table tr:hover {
        background: #f9f9f9;
    }
    
    .feature-name {
        font-family: 'Courier New', monospace;
        color: #333;
        word-break: break-all;
    }
    
    .feature-value {
        text-align: right;
        font-family: 'Courier New', monospace;
        color: #2196F3;
        font-weight: 500;
    }
    
    .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #2196F3;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .calculation-section {
        margin-bottom: 30px;
    }
    
    .calculation-section h4 {
        margin: 0 0 15px 0;
        font-size: 1.2em;
        color: #667eea;
        border-bottom: 1px solid #eee;
        padding-bottom: 8px;
    }
    
    .players-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
    }
    
    .players-table th,
    .players-table td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #eee;
    }
    
    .players-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #333;
    }
    
    .players-table tr:hover {
        background: #f8f9fa;
    }
    
    .feature-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-top: 10px;
    }
    
    .feature-item {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 6px;
        border-left: 3px solid #667eea;
    }
    
    .feature-item .feature-name {
        font-weight: 600;
        color: #333;
        margin-bottom: 5px;
        font-size: 0.9em;
    }
    
    .feature-item .feature-value {
        font-size: 1.1em;
        color: #667eea;
        font-weight: 600;
    }
    
    .feature-item.diff {
        border-left-color: #28a745;
    }
    
    .feature-item.diff .feature-value {
        color: #28a745;
    }
    
    .badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 0.85em;
        font-weight: 600;
    }
    
    .badge.starter {
        background: #667eea;
        color: white;
    }
    
    .badge.injured {
        background: #e74c3c;
        color: white;
    }
    
    .players-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        width: 100%;
        box-sizing: border-box;
        min-height: 100px;
        transition: background-color 0.2s;
    }
    
    .players-grid.drag-over {
        background-color: rgba(102, 126, 234, 0.1);
        border: 2px dashed #667eea;
        border-radius: 8px;
    }
    
    .player-tag-wrapper {
        position: relative;
    }
    
    .player-tag {
        background: white;
        border: 2px solid #ddd;
        border-radius: 6px;
        padding: 6px 8px;
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.85em;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
    }
    
    .player-tag:hover {
        border-color: #667eea;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .player-tag.starter {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
    }
    
    .player-tag.starter.gtd {
        /* Starter + GTD: Blue background with yellow border */
        border-color: #ffd700;
        border-width: 3px;
        box-shadow: 0 0 0 1px #ffd700, 0 0 8px rgba(255, 215, 0, 0.4);
    }
    
    .player-tag.injured {
        /* Injured overrides everything - red background */
        background: #fee !important;
        border-color: #fcc !important;
        color: #c33 !important;
        box-shadow: none !important;
    }
    
    .player-tag.gtd:not(.starter):not(.injured) {
        /* GTD only (not starter, not injured) */
        background: #fff9e6;
        border-color: #ffd700;
        color: #b8860b;
    }
    
    .player-tag-pos {
        font-weight: bold;
        font-size: 0.9em;
        min-width: 16px;
    }
    
    .player-tag-injury {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        cursor: pointer;
        color: #999;
        background: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
        transition: all 0.2s;
        flex-shrink: 0;
        padding: 2px;
    }
    
    .player-tag-injury:hover {
        color: #e74c3c;
        background: rgba(231, 76, 60, 0.1);
    }
    
    .player-tag-injury.active {
        color: #e74c3c;
        background: rgba(231, 76, 60, 0.15);
    }
    
    .player-tag-name {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
        transition: opacity 0.2s;
    }
    
    .player-tag-name:hover {
        opacity: 0.7;
    }
    
    .player-tag-remove {
        background: rgba(255, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        font-size: 12px;
        line-height: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        opacity: 0;
        transition: opacity 0.2s;
    }
    
    .player-tag:hover .player-tag-remove {
        opacity: 1;
    }
    
    .player-tag-remove:hover {
        background: rgba(255, 0, 0, 1);
    }
    
    .player-card-hover {
        position: absolute;
        bottom: 100%;
        left: 0;
        z-index: 1000;
        background: white;
        border: 2px solid #667eea;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        min-width: 300px;
        margin-bottom: 4px;
    }
    
    .player-card-hover .player-id {
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 0.7em;
        color: #999;
        font-weight: normal;
    }
    
    .player-card {
        background: white;
        border: 2px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        transition: all 0.3s;
        width: 100%;
        box-sizing: border-box;
        flex-shrink: 0;
        position: relative;
    }
    
    .player-card-remove {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(255, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        font-size: 18px;
        line-height: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        z-index: 10;
        padding: 0;
    }
    
    .player-card-remove:hover {
        background: rgba(255, 0, 0, 1);
        transform: scale(1.1);
    }
    
    .player-card-remove:active {
        transform: scale(0.95);
    }
    
    .player-card-content {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    .player-left {
        flex: 0 0 33.33%;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    
    .player-middle {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        justify-content: center;
    }
    
    .player-right {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        justify-content: center;
    }
    
    .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
    }
    
    .stat-label {
        font-size: 0.75em;
        color: #666;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .stat-value {
        font-size: 1em;
        color: #333;
        font-weight: bold;
    }
    
    /* Non-starter cards only glow on hover */
    .away-team .player-card:hover {
        border-color: var(--away-alt-color, #999);
        box-shadow: 0 0 20px var(--away-alt-color, #99999980);
    }
    
    .home-team .player-card:hover {
        border-color: var(--home-alt-color, #764ba2);
        box-shadow: 0 0 20px var(--home-alt-color, #764ba280);
    }
    
    .player-card.not-playing {
        opacity: 0.5;
    }
    
    .player-card.injured {
        border-color: #e74c3c;
        box-shadow: 0 0 15px rgba(231, 76, 60, 0.6), 0 0 25px rgba(231, 76, 60, 0.4);
        animation: injuredGlow 2s ease-in-out infinite alternate;
    }
    
    .player-card.gtd {
        border-color: #f39c12;
        box-shadow: 0 0 15px rgba(243, 156, 18, 0.6), 0 0 25px rgba(243, 156, 18, 0.4);
        animation: gtdGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes injuredGlow {
        from {
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6), 0 0 25px rgba(231, 76, 60, 0.4);
        }
        to {
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.8), 0 0 30px rgba(231, 76, 60, 0.6);
        }
    }
    
    @keyframes gtdGlow {
        from {
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.6), 0 0 25px rgba(243, 156, 18, 0.4);
        }
        to {
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.8), 0 0 30px rgba(243, 156, 18, 0.6);
        }
    }
    
    .player-headshot {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        object-fit: cover;
        margin-bottom: 6px;
        border: 2px solid #ddd;
    }
    
    .player-headshot-placeholder {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: #667eea;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 6px;
    }
    
    .player-name-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-bottom: 5px;
    }
    
    .player-name {
        font-weight: bold;
        font-size: 0.85em;
        color: #333;
    }
    
    .injured-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: white;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.8);
        transition: all 0.2s;
        flex-shrink: 0;
    }
    
    .injured-icon:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
    }
    
    .injured-icon.active {
        color: #e74c3c;
        background: rgba(231, 76, 60, 0.2);
    }
    
    .injured-icon.active:hover {
        background: rgba(231, 76, 60, 0.3);
    }
    
    .team-records {
        display: flex;
        justify-content: space-around;
        padding: 10px;
        margin-bottom: 15px;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 6px;
        font-size: 0.85em;
    }
    
    .record-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }
    
    .record-label {
        color: #666;
        font-size: 0.85em;
        font-weight: 600;
    }
    
    .record-value {
        color: #333;
        font-weight: bold;
        font-size: 1em;
    }
    
    .player-position {
        font-size: 0.7em;
        color: #666;
        margin-bottom: 0;
    }
    
    .player-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .toggle {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        cursor: pointer;
        font-size: 0.85em;
    }
    
    .toggle input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
    }
    
    .action-bar {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        padding: 20px;
        margin-bottom: 30px;
        border-bottom: 2px solid #ddd;
    }
    
    .gear-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        color: #667eea;
        text-decoration: none;
        border-radius: 50%;
        transition: all 0.2s;
        background: rgba(102, 126, 234, 0.1);
    }
    
    .gear-icon:hover {
        background: rgba(102, 126, 234, 0.2);
        transform: rotate(90deg);
    }
    
    .refresh-btn {
        background: #28a745;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
    }
    
    .refresh-btn:hover {
        background: #218838;
        transform: scale(1.05);
    }
    
    .refresh-btn:active {
        transform: scale(0.98);
    }
    
    .refresh-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
    }
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .predict-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 1.2em;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: transform 0.2s;
    }
    
    .predict-btn:hover {
        transform: scale(1.05);
    }
    
    .predict-btn:active {
        transform: scale(0.98);
    }
    
    .action-bar-message-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
    }
    
    .action-bar-message-btn:hover {
        background: #5568d3;
        transform: scale(1.05);
    }
    
    .action-bar-message-btn:active {
        transform: scale(0.98);
    }
    
    .action-bar-message-btn svg {
        width: 20px;
        height: 20px;
    }
    
    
    .download-link {
        display: inline-flex;
        align-items: center;
        color: #667eea;
        text-decoration: none;
        font-weight: 500;
        padding: 8px 12px;
        border-radius: 4px;
        transition: background-color 0.2s;
    }
    
    .download-link:hover {
        background-color: #e8e8f0;
        text-decoration: none;
    }
    
    .stat-value {
        font-size: 1.5em;
        font-weight: bold;
        color: #333;
    }
    
    @media (max-width: 1200px) {
        .game-layout {
            grid-template-columns: 1fr;
        }
    }
</style>

<script>
    // DEBUG: Log last_prediction data
    console.log('=== DEBUG: last_prediction data ===');
    console.log('last_prediction from template:', {{ last_prediction|tojson|safe }});
    console.log('last_prediction exists:', {{ 'true' if last_prediction else 'false' }});
    {% if last_prediction %}
    console.log('home_win_prob:', {{ last_prediction.get('home_win_prob', 'undefined')|tojson|safe }});
    console.log('away_win_prob:', {{ last_prediction.get('away_win_prob', 'undefined')|tojson|safe }});
    console.log('home_odds:', {{ last_prediction.get('home_odds', 'undefined')|tojson|safe }});
    console.log('away_odds:', {{ last_prediction.get('away_odds', 'undefined')|tojson|safe }});
    {% else %}
    console.log('last_prediction is None/undefined');
    {% endif %}
    console.log('====================================');
    
    // Helper function to convert hex to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    // Helper function to convert hex to RGB array
    function hexToRgb(hex) {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        return [r, g, b];
    }
    
    // Helper function to convert hex to RGB array
    function hexToRgb(hex) {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        return [r, g, b];
    }
    
    // Set team section glows and player card hover glows
    document.addEventListener('DOMContentLoaded', function() {
        // DEBUG: Check for prediction badges in DOM
        console.log('=== DEBUG: Checking for prediction badges ===');
        const awayBadge = document.querySelector('.away-team .prediction-badge');
        const homeBadge = document.querySelector('.home-team .prediction-badge');
        console.log('Away team badge found:', awayBadge !== null);
        console.log('Home team badge found:', homeBadge !== null);
        if (awayBadge) console.log('Away badge HTML:', awayBadge.outerHTML);
        if (homeBadge) console.log('Home badge HTML:', homeBadge.outerHTML);
        console.log('============================================');
        
        const awayTeamSection = document.querySelector('.away-team');
        const homeTeamSection = document.querySelector('.home-team');
        
        if (awayTeamSection && '{{ away_team_color }}') {
            const awayColor = '{{ away_team_color }}';
            const awayAltColor = '{{ away_team_alternate_color }}';
            const awayAltRgb = hexToRgb(awayAltColor);
            awayTeamSection.style.boxShadow = `0 0 20px ${hexToRgba(awayColor, 0.3)}`;
            awayTeamSection.style.borderColor = `#${awayColor}`;
            
            // Set CSS variable for RGB values
            awayTeamSection.style.setProperty('--away-alt-color-rgb', awayAltRgb.join(', '));
            
            // Set starter card backgrounds
            // Starter tags already have styling via CSS class
            // No need for additional JavaScript styling for tags
        }
        
        if (homeTeamSection && '{{ home_team_color }}') {
            const homeColor = '{{ home_team_color }}';
            const homeAltColor = '{{ home_team_alternate_color }}';
            const homeAltRgb = hexToRgb(homeAltColor);
            homeTeamSection.style.boxShadow = `0 0 20px ${hexToRgba(homeColor, 0.3)}`;
            homeTeamSection.style.borderColor = `#${homeColor}`;
            
            // Set CSS variable for RGB values
            homeTeamSection.style.setProperty('--home-alt-color-rgb', homeAltRgb.join(', '));
            
            // Set starter card backgrounds
            // Starter tags already have styling via CSS class
            // No need for additional JavaScript styling for tags
        }
        
        // Sort players on page load (after DOM is ready)
        setTimeout(() => {
            if (awayTeamSection) {
                sortPlayerCards(awayTeamSection);
            }
            if (homeTeamSection) {
                sortPlayerCards(homeTeamSection);
            }
        }, 100);
    });
    
    const gameId = '{{ game_id }}';
    const gameDate = '{{ game_date }}';
    const homeTeam = '{{ home_team }}';
    const awayTeam = '{{ away_team }}';
    
    // Track changes
    const playerStatus = {};
    
    // Initialize player status from DOM
    document.querySelectorAll('.player-tag').forEach(tag => {
        const playerId = tag.getAttribute('data-player-id');
        const team = tag.getAttribute('data-team');
        const hoverCard = document.getElementById(`hover-card-${playerId}`);
        const injuredIcon = hoverCard ? hoverCard.querySelector('.injured-icon') : null;
        
        if (!playerStatus[team]) {
            playerStatus[team] = {};
        }
        
        // Initialize status - injured players are not playing by default
        const isInjured = tag.classList.contains('injured');
        const isGtd = tag.classList.contains('gtd');
        const isStarter = tag.getAttribute('data-is-starter') === 'true';
        
        playerStatus[team][playerId] = {
            is_starter: isStarter,
            is_playing: !isInjured,  // If injured, not playing
            is_injured: isInjured,
            is_gtd: isGtd
        };
    });
    
    // Toggle starter status when clicking on player name
    async function toggleStarterTag(nameElement, playerId, team) {
        const tag = nameElement.closest('.player-tag');
        if (!tag) return;
        
        const currentStarter = tag.getAttribute('data-is-starter') === 'true';
        const newStarter = !currentStarter;
        
        // Update tag
        tag.setAttribute('data-is-starter', newStarter ? 'true' : 'false');
        if (newStarter) {
            tag.classList.add('starter');
        } else {
            tag.classList.remove('starter');
        }
        
        // Update hover card if it exists
        const hoverCard = document.getElementById(`hover-card-${playerId}`);
        if (hoverCard) {
            hoverCard.setAttribute('data-is-starter', newStarter ? 'true' : 'false');
        }
        
        // Update player status in memory
        if (!playerStatus[team]) {
            playerStatus[team] = {};
        }
        if (!playerStatus[team][playerId]) {
            playerStatus[team][playerId] = {};
        }
        playerStatus[team][playerId].is_starter = newStarter;
        
        // Re-sort player tags after starter toggle
        const teamSection = tag.closest('.away-team, .home-team');
        if (teamSection) {
            sortPlayerCards(teamSection);
        }
        
        // Update database
        await updatePlayerStatus(team, playerId, 'is_starter', newStarter);
    }
    
    // Toggle injury status when clicking on injury icon
    async function toggleInjuredTag(iconElement, playerId, team) {
        // Prevent any parent click handlers from firing
        if (window.event) {
            window.event.stopPropagation();
            window.event.preventDefault();
        }
        
        const tag = iconElement.closest('.player-tag');
        if (!tag) return;
        
        const isInjured = iconElement.classList.contains('active');
        const newInjured = !isInjured;
        const isGtd = tag.classList.contains('gtd');
        
        // Toggle icon state
        if (newInjured) {
            iconElement.classList.add('active');
        } else {
            iconElement.classList.remove('active');
        }
        
        // Update tag appearance
        updateTagAppearance(tag, newInjured, isGtd);
        
        // Update hover card if it exists
        const hoverCard = document.getElementById(`hover-card-${playerId}`);
        if (hoverCard) {
            const hoverInjuredIcon = hoverCard.querySelector('.injured-icon');
            if (hoverInjuredIcon) {
                if (newInjured) {
                    hoverInjuredIcon.classList.add('active');
                } else {
                    hoverInjuredIcon.classList.remove('active');
                }
            }
            updateCardAppearance(hoverCard, newInjured, isGtd);
        }
        
        // Update player status in memory
        if (!playerStatus[team]) {
            playerStatus[team] = {};
        }
        if (!playerStatus[team][playerId]) {
            playerStatus[team][playerId] = {};
        }
        playerStatus[team][playerId].is_injured = newInjured;
        
        // If injured (Out), mark as not playing and remove starter status
        if (newInjured && !isGtd) {
            playerStatus[team][playerId].is_playing = false;
            const isStarter = tag.getAttribute('data-is-starter') === 'true';
        if (isStarter) {
                tag.setAttribute('data-is-starter', 'false');
                tag.classList.remove('starter');
                if (hoverCard) {
                    hoverCard.setAttribute('data-is-starter', 'false');
                }
                playerStatus[team][playerId].is_starter = false;
                await updatePlayerStatus(team, playerId, 'is_starter', false);
            }
        } else if (!newInjured && !isGtd) {
            // If not injured and not GTD, mark as playing
            playerStatus[team][playerId].is_playing = true;
        }
        
        // Update database (both injured and playing status)
        await updatePlayerStatus(team, playerId, 'is_injured', newInjured);
        await updatePlayerStatus(team, playerId, 'is_playing', playerStatus[team][playerId].is_playing);
        
        // Re-sort player cards after injury toggle
        const teamSection = tag.closest('.away-team, .home-team');
            if (teamSection) {
            sortPlayerCards(teamSection);
        }
    }
    
    // Also allow clicking on hover card to toggle starter (single click)
    document.querySelectorAll('.player-card-hover').forEach(hoverCard => {
        hoverCard.addEventListener('click', function(e) {
            // Don't toggle if clicking the remove button, injured icon, or stat areas
            if (e.target.closest('.player-card-remove') || 
                e.target.closest('.injured-icon') ||
                e.target.closest('.player-tag-injury') ||
                e.target.closest('.stat-item') ||
                e.target.closest('.player-headshot') ||
                e.target.closest('.player-headshot-placeholder')) {
                return;
            }
            
            const playerId = this.getAttribute('data-player-id');
            const team = this.getAttribute('data-team');
            const currentStarter = this.getAttribute('data-is-starter') === 'true';
            const newStarter = !currentStarter;
            
            // Update hover card
            this.setAttribute('data-is-starter', newStarter ? 'true' : 'false');
            
            // Update tag
            const tag = document.querySelector(`.player-tag[data-player-id="${playerId}"]`);
            if (tag) {
                tag.setAttribute('data-is-starter', newStarter ? 'true' : 'false');
                if (newStarter) {
                    tag.classList.add('starter');
                } else {
                    tag.classList.remove('starter');
                }
            }
            
            // Update player status in memory
            if (!playerStatus[team]) {
                playerStatus[team] = {};
            }
            if (!playerStatus[team][playerId]) {
                playerStatus[team][playerId] = {};
            }
            playerStatus[team][playerId].is_starter = newStarter;
            
            // Re-sort player tags after starter toggle
            const teamSection = this.closest('.away-team, .home-team');
            if (teamSection) {
                sortPlayerCards(teamSection);
            }
            
            // Update database
            updatePlayerStatus(team, playerId, 'is_starter', newStarter);
        });
    });
    
    function getPositionSortOrder(posName) {
        if (!posName) return 3;
        const posLower = posName.toLowerCase();
        // Handle both pos_name (PG, SG, PF, SF, C) and pos_display_name (Guard, Forward, Center)
        if (posLower.includes('guard') || posLower === 'pg' || posLower === 'sg' || posLower === 'g') return 0;
        if (posLower.includes('forward') || posLower === 'pf' || posLower === 'sf' || posLower === 'f') return 1;
        if (posLower.includes('center') || posLower === 'c') return 2;
        return 3;
    }
    
    function showPlayerCard(event, playerId, team) {
        const hoverCard = document.getElementById(`hover-card-${playerId}`);
        if (hoverCard) {
            hoverCard.style.display = 'block';
            // Position the card relative to the wrapper
            const tag = event.currentTarget;
            const wrapper = tag.closest('.player-tag-wrapper');
            if (wrapper) {
                const rect = wrapper.getBoundingClientRect();
                const gridRect = wrapper.closest('.players-grid').getBoundingClientRect();
                // Position above the tag
                hoverCard.style.position = 'absolute';
                hoverCard.style.bottom = '100%';
                hoverCard.style.left = '0';
                hoverCard.style.zIndex = '1000';
            }
        }
    }
    
    function hidePlayerCard(event) {
        let playerId;
        if (event.currentTarget.classList.contains('player-card-hover')) {
            // Called from hover card
            playerId = event.currentTarget.id.replace('hover-card-', '');
        } else {
            // Called from tag
            playerId = event.currentTarget.getAttribute('data-player-id');
        }
        
        const hoverCard = document.getElementById(`hover-card-${playerId}`);
        const wrapper = document.querySelector(`.player-tag-wrapper[data-player-id="${playerId}"]`);
        const tag = wrapper ? wrapper.querySelector('.player-tag') : null;
        
        if (hoverCard) {
            // Only hide if mouse is not moving to the hover card or tag
            setTimeout(() => {
                if (!hoverCard.matches(':hover') && (!tag || !tag.matches(':hover'))) {
                    hoverCard.style.display = 'none';
                }
            }, 100);
        }
    }
    
    
    function sortPlayerCards(teamSection) {
        const playersGrid = teamSection.querySelector('.players-grid');
        if (!playersGrid) {
            console.log('sortPlayerCards: No players grid found');
            return;
        }
        
        const cards = Array.from(playersGrid.querySelectorAll('.player-tag-wrapper'));
        console.log(`sortPlayerCards: Found ${cards.length} cards for team section`);
        
        // Debug: log starter and injured status
        cards.forEach((card, idx) => {
            const tag = card.querySelector('.player-tag');
            if (tag) {
                const isStarter = tag.getAttribute('data-is-starter') === 'true';
                const isInjured = tag.classList.contains('injured');
                const pos = tag.getAttribute('data-position') || '';
                const name = tag.querySelector('.player-tag-name')?.textContent || 'unknown';
                console.log(`Card ${idx}: ${name}, starter=${isStarter}, injured=${isInjured}, pos=${pos}`);
            }
        });
        
        cards.sort((a, b) => {
            const aTag = a.querySelector('.player-tag');
            const bTag = b.querySelector('.player-tag');
            if (!aTag || !bTag) return 0;
            
            // Check if injured (injured players go last)
            const aIsInjured = aTag.classList.contains('injured');
            const bIsInjured = bTag.classList.contains('injured');
            
            // Injured players come last
            if (aIsInjured && !bIsInjured) return 1;  // a (injured) comes after b (not injured)
            if (!aIsInjured && bIsInjured) return -1; // a (not injured) comes before b (injured)
            
            // If both injured or both not injured, continue with normal sorting
            const aIsStarter = aTag.getAttribute('data-is-starter') === 'true';
            const bIsStarter = bTag.getAttribute('data-is-starter') === 'true';
            
            // Starters come first (among non-injured players)
            if (aIsStarter && !bIsStarter) return -1;
            if (!aIsStarter && bIsStarter) return 1;
            
            if (aIsStarter && bIsStarter) {
                // Both starters: sort by position (guard, forward, center)
                const aPos = getPositionSortOrder(aTag.getAttribute('data-position') || '');
                const bPos = getPositionSortOrder(bTag.getAttribute('data-position') || '');
                const posDiff = aPos - bPos;
                if (posDiff !== 0) return posDiff;
                // If same position or both unknown, sort by MPG (descending) to maintain consistent order
                const aMpg = parseFloat(aTag.getAttribute('data-mpg') || 0);
                const bMpg = parseFloat(bTag.getAttribute('data-mpg') || 0);
                return bMpg - aMpg;
            } else {
                // Both non-starters: sort by MPG (descending)
                const aMpg = parseFloat(aTag.getAttribute('data-mpg') || 0);
                const bMpg = parseFloat(bTag.getAttribute('data-mpg') || 0);
                return bMpg - aMpg; // Descending order (higher MPG first)
            }
        });
        
        // Re-append sorted cards
        cards.forEach(card => playersGrid.appendChild(card));
        console.log('sortPlayerCards: Cards sorted and re-appended');
    }
    
    async function removePlayer(playerId, team, buttonElement) {
        // Find the wrapper element (contains both tag and hover card)
        const wrapper = buttonElement.closest('.player-tag-wrapper');
        
        if (!wrapper) {
            console.error('Could not find player-tag-wrapper element');
            alert('Error: Could not find player element to remove');
            return;
        }
        
        try {
            const response = await fetch('/api/remove-player', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    game_id: gameId,
                    player_id: playerId,
                    team: team
                })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                const errorMsg = data.error || `HTTP ${response.status}: ${response.statusText}`;
                alert(`Error removing player: ${errorMsg}`);
                console.error('Remove player error:', data);
                return;
            }
            
            if (data.success) {
                // Remove wrapper (which contains both tag and hover card) from DOM with fade-out animation
                wrapper.style.transition = 'opacity 0.3s, transform 0.3s';
                wrapper.style.opacity = '0';
                wrapper.style.transform = 'scale(0.9)';
                
                setTimeout(() => {
                    wrapper.remove();
                }, 300);
            } else {
                alert(`Error: ${data.error || 'Unknown error'}`);
                console.error('Remove player error:', data);
            }
        } catch (error) {
            alert(`Error removing player: ${error.message}`);
            console.error('Remove player exception:', error);
        }
    }
    
    function toggleInjured(icon, playerId, team) {
        // Prevent any parent click handlers from firing
        if (window.event) {
            window.event.stopPropagation();
            window.event.preventDefault();
        }
        
        const hoverCard = icon.closest('.player-card-hover') || document.getElementById(`hover-card-${playerId}`);
        const wrapper = document.querySelector(`.player-tag-wrapper[data-player-id="${playerId}"]`);
        const tag = wrapper ? wrapper.querySelector('.player-tag') : null;
        
        const isInjured = icon.classList.contains('active');
        const newInjured = !isInjured;
        const isGtd = tag ? tag.classList.contains('gtd') : false;
        
        // Toggle icon state
        if (newInjured) {
            icon.classList.add('active');
        } else {
            icon.classList.remove('active');
        }
        
        // Update tag appearance
        if (tag) {
            updateTagAppearance(tag, newInjured, isGtd);
        }
        
        // Update hover card appearance
        if (hoverCard) {
            updateCardAppearance(hoverCard, newInjured, isGtd);
        }
        
        // Update player status in memory
        if (!playerStatus[team]) {
            playerStatus[team] = {};
        }
        if (!playerStatus[team][playerId]) {
            playerStatus[team][playerId] = {};
        }
        playerStatus[team][playerId].is_injured = newInjured;
        
        // If injured (Out), mark as not playing and remove starter status
        if (newInjured && !isGtd) {
            playerStatus[team][playerId].is_playing = false;
            const isStarter = tag ? tag.getAttribute('data-is-starter') === 'true' : false;
            if (isStarter) {
                if (tag) {
                    tag.setAttribute('data-is-starter', 'false');
                    tag.classList.remove('starter');
                }
                if (hoverCard) {
                    hoverCard.setAttribute('data-is-starter', 'false');
                }
                playerStatus[team][playerId].is_starter = false;
                updatePlayerStatus(team, playerId, 'is_starter', false);
            }
        } else if (!newInjured && !isGtd) {
            // If not injured and not GTD, mark as playing
            playerStatus[team][playerId].is_playing = true;
        }
        
        // Update database (both injured and playing status)
        updatePlayerStatus(team, playerId, 'is_injured', newInjured);
        updatePlayerStatus(team, playerId, 'is_playing', playerStatus[team][playerId].is_playing);
        
        // Re-sort player cards after injury toggle
        if (wrapper) {
            const teamSection = wrapper.closest('.away-team, .home-team');
        if (teamSection) {
            sortPlayerCards(teamSection);
            }
        }
    }
    
    function updateTagAppearance(tag, isInjured, isGtd) {
        // Remove status classes (but preserve starter class)
        tag.classList.remove('injured', 'gtd');
        
        // Injured overrides everything
        if (isInjured) {
            tag.classList.add('injured');
            // Remove starter if injured (injured players can't be starters)
            tag.classList.remove('starter');
            tag.setAttribute('data-is-starter', 'false');
        } else if (isGtd) {
            // GTD can coexist with starter
            tag.classList.add('gtd');
        }
    }
    
    function updateCardAppearance(card, isInjured, isGtd) {
        // Remove status classes (but preserve starter class)
        card.classList.remove('injured', 'gtd');
        
        // Injured overrides everything
        if (isInjured) {
            card.classList.add('injured');
            // Remove starter if injured (injured players can't be starters)
            card.classList.remove('starter');
            card.setAttribute('data-is-starter', 'false');
        } else if (isGtd) {
            // GTD can coexist with starter
            card.classList.add('gtd');
        }
    }
    
    async function updatePlayerStatus(team, playerId, field, value) {
        if (!playerStatus[team]) {
            playerStatus[team] = {};
        }
        if (!playerStatus[team][playerId]) {
            playerStatus[team][playerId] = {};
        }
        playerStatus[team][playerId][field] = value;
        
        // Get current status values
        const status = playerStatus[team][playerId];
        
        // Save to database
        try {
            const response = await fetch('/api/update-player', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                game_id: gameId,
                player_id: playerId,
                team: team,
                is_playing: status.is_playing !== undefined ? status.is_playing : true,
                is_starter: status.is_starter !== undefined ? status.is_starter : false,
                is_injured: status.is_injured !== undefined ? status.is_injured : false
            })
            });
            
            const data = await response.json();
            if (!response.ok) {
                console.error('Error updating player status:', data.error || 'Unknown error');
            } else {
                console.log('Player status updated successfully:', { team, playerId, field, value });
            }
        } catch (err) {
            console.error('Error updating player:', err);
        }
    }
    
    async function loadPlayersFromAPI() {
        const loadBtn = document.querySelector('.refresh-btn');
        const originalHTML = loadBtn.innerHTML;
        
        loadBtn.disabled = true;
        // Add spinning animation
        loadBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="animation: spin 1s linear infinite;"><path d="M17.5 2.5V7.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.5 12.5V17.5H7.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M15.8333 10C15.8333 13.2217 13.2217 15.8333 10 15.8333C6.77833 15.8333 4.16667 13.2217 4.16667 10C4.16667 6.77833 6.77833 4.16667 10 4.16667C11.6667 4.16667 13.1667 4.83333 14.1667 6L17.5 2.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.5 17.5L5.83333 14.1667C6.83333 15.1667 8.33333 15.8333 10 15.8333" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        
        try {
            const response = await fetch('/api/load-players', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    game_id: gameId
                })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                alert(`Error loading players: ${data.error || 'Unknown error'}`);
                console.error('Load players error:', data);
            } else if (data.success) {
                alert('Players loaded and updated successfully! Refreshing page...');
                // Reload the page to show updated players
                window.location.reload();
            } else {
                alert(`Error: ${data.error || 'Unknown error'}`);
                console.error('Load players error:', data);
            }
        } catch (error) {
            alert(`Error loading players: ${error.message}`);
            console.error('Load players exception:', error);
        } finally {
            loadBtn.disabled = false;
            loadBtn.innerHTML = originalHTML;
        }
    }
    
    // Drag and drop handlers
    let draggedElement = null;
    let draggedFromTeam = null;
    
    function handleDragStart(event) {
        draggedElement = event.target.closest('.player-card');
        draggedFromTeam = draggedElement.getAttribute('data-team');
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/html', draggedElement.outerHTML);
        draggedElement.style.opacity = '0.5';
    }
    
    function handleDragEnd(event) {
        if (draggedElement) {
            const tag = draggedElement.querySelector('.player-tag');
            if (tag) {
                tag.style.opacity = '1';
            }
        }
        // Remove drag-over class from all grids
        document.querySelectorAll('.players-grid').forEach(grid => {
            grid.classList.remove('drag-over');
        });
    }
    
    function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
    }
    
    function handleDragEnter(event) {
        event.preventDefault();
        const grid = event.currentTarget;
        grid.classList.add('drag-over');
    }
    
    function handleDragLeave(event) {
        const grid = event.currentTarget;
        // Only remove class if we're actually leaving the grid (not just moving to a child)
        if (!grid.contains(event.relatedTarget)) {
            grid.classList.remove('drag-over');
        }
    }
    
    async function handleDrop(event, toTeam) {
        event.preventDefault();
        const grid = event.currentTarget;
        grid.classList.remove('drag-over');
        
        if (!draggedElement || !draggedFromTeam) {
            return;
        }
        
        // Don't do anything if dropped on the same team
        if (draggedFromTeam === toTeam) {
            return;
        }
        
        const tag = draggedElement.querySelector('.player-tag');
        const playerId = tag ? tag.getAttribute('data-player-id') : draggedElement.getAttribute('data-player-id');
        const season = '{{ season }}';
        
        try {
            const response = await fetch('/api/move-player', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    player_id: playerId,
                    from_team: draggedFromTeam,
                    to_team: toTeam,
                    season: season
                })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                alert(`Error moving player: ${data.error || 'Unknown error'}`);
                console.error('Move player error:', data);
                return;
            }
            
            if (data.success) {
                // Remove from source team
                draggedElement.remove();
                
                // Reload the page to show updated rosters
                window.location.reload();
            } else {
                alert(`Error: ${data.error || 'Unknown error'}`);
                console.error('Move player error:', data);
            }
        } catch (error) {
            alert(`Error moving player: ${error.message}`);
            console.error('Move player exception:', error);
        } finally {
            draggedElement = null;
            draggedFromTeam = null;
        }
    }
    
    async function generatePrediction() {
        const predictBtn = document.getElementById('generate-prediction-btn');
        // Validate required fields before sending
        if (!gameId || !gameDate || !homeTeam || !awayTeam) {
            const missing = [];
            if (!gameId) missing.push('game_id');
            if (!gameDate) missing.push('game_date');
            if (!homeTeam) missing.push('home_team');
            if (!awayTeam) missing.push('away_team');
            alert(`Error: Missing required fields: ${missing.join(', ')}`);
            console.error('Missing fields:', {gameId, gameDate, homeTeam, awayTeam});
            return;
        }
        
        const originalText = predictBtn.textContent;
        predictBtn.disabled = true;
        predictBtn.textContent = 'Generating Prediction...';
        
        const requestData = {
            game_id: gameId,
            game_date: gameDate,
            home_team: homeTeam,
            away_team: awayTeam,
            player_config: playerStatus
        };
        
        console.log('Sending prediction request:', requestData);
        
        try {
            const response = await fetch('/api/predict', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                // Handle HTTP error responses
                const errorMsg = data.error || `HTTP ${response.status}: ${response.statusText}`;
                alert(`Error: ${errorMsg}`);
                console.error('Prediction error:', data);
            } else if (data.success) {
                // Reload page to show saved prediction from database
                window.location.reload();
            } else {
                alert(`Error: ${data.error || 'Unknown error'}`);
                console.error('Prediction error:', data);
            }
        } catch (error) {
            alert(`Error: ${error.message}`);
            console.error('Prediction exception:', error);
        } finally {
            predictBtn.disabled = false;
            predictBtn.textContent = originalText;
        }
    }
    
    function displayPrediction(prediction, training_csv) {
        const winner = prediction.predicted_winner;
        const homeProb = prediction.home_win_prob;
        const awayProb = prediction.away_win_prob || (100 - homeProb);
        const homeOdds = prediction.home_odds;
        const awayOdds = prediction.away_odds;
        const odds = prediction.odds;
        
        // Update prediction badges in team headers
        const awayBadge = document.querySelector('.away-team .prediction-badge');
        const homeBadge = document.querySelector('.home-team .prediction-badge');
        
        // Get points predictions
        const predHomePoints = prediction.home_points_pred || prediction.home_pts;
        const predAwayPoints = prediction.away_points_pred || prediction.away_pts;
        
        // Update or create away team badge
        const awayHeader = document.querySelector('.away-team .team-header');
        if (awayHeader) {
            // Remove existing badges if they exist
            if (awayBadge) {
                awayBadge.remove();
            }
            const existingPointsBadge = awayHeader.querySelector('.points-prediction-badge');
            if (existingPointsBadge) {
                existingPointsBadge.remove();
            }
            
            // Create new win probability badge
            const newAwayBadge = document.createElement('span');
            newAwayBadge.className = 'prediction-badge';
            const awayOddsStr = awayOdds !== undefined ? 
                `(${awayOdds >= 0 ? '+' : ''}${Math.round(awayOdds)})` : 
                (odds !== undefined && winner === awayTeam ? `(${odds >= 0 ? '+' : ''}${Math.round(odds)})` : '');
            newAwayBadge.textContent = `${Math.round(awayProb)}% ${awayOddsStr}`;
            awayHeader.appendChild(newAwayBadge);
            
            // Add points prediction badge if available
            if (predAwayPoints) {
                const newAwayPointsBadge = document.createElement('span');
                newAwayPointsBadge.className = 'points-prediction-badge';
                newAwayPointsBadge.textContent = `${Math.round(predAwayPoints)} pts`;
                awayHeader.appendChild(newAwayPointsBadge);
            }
        }
        
        // Update or create home team badge
        const homeHeader = document.querySelector('.home-team .team-header');
        if (homeHeader) {
            // Remove existing badges if they exist
            if (homeBadge) {
                homeBadge.remove();
            }
            const existingPointsBadge = homeHeader.querySelector('.points-prediction-badge');
            if (existingPointsBadge) {
                existingPointsBadge.remove();
            }
            
            // Create new win probability badge
            const newHomeBadge = document.createElement('span');
            newHomeBadge.className = 'prediction-badge';
            const homeOddsStr = homeOdds !== undefined ? 
                `(${homeOdds >= 0 ? '+' : ''}${Math.round(homeOdds)})` : 
                (odds !== undefined && winner === homeTeam ? `(${odds >= 0 ? '+' : ''}${Math.round(odds)})` : '');
            newHomeBadge.textContent = `${Math.round(homeProb)}% ${homeOddsStr}`;
            homeHeader.appendChild(newHomeBadge);
            
            // Add points prediction badge if available
            if (predHomePoints) {
                const newHomePointsBadge = document.createElement('span');
                newHomePointsBadge.className = 'points-prediction-badge';
                newHomePointsBadge.textContent = `${Math.round(predHomePoints)} pts`;
                homeHeader.appendChild(newHomePointsBadge);
            }
        }
        
        // Prediction result is now only shown in team badges, no separate panel needed
    }
    
    // Feature values modal
    function showGameFeatures(gameId, gameDate, homeTeam, awayTeam) {
        // Show loading state
        const modal = document.getElementById('features-modal');
        const modalContent = document.getElementById('features-modal-content');
        modal.style.display = 'flex';
        modalContent.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner"></div><p>Loading feature values...</p></div>';
        
        // Fetch feature values
        fetch('/api/game-features', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_id: gameId,
                game_date: gameDate,
                home_team: homeTeam,
                away_team: awayTeam
            })
        })
        .then(response => {
            if (!response.ok && response.status === 404) {
                // Try to parse JSON even for 404, as our route handler returns JSON
                return response.json().catch(() => {
                    // If it's not JSON (Flask 404 page), throw an error
                    throw new Error('Route not found');
                });
            }
            return response.json();
        })
        .then(data => {
            if (!data.success) {
                modalContent.innerHTML = `<div style="padding: 20px; color: #d32f2f;"><p>Error: ${data.error || 'Failed to load features'}</p></div>`;
                return;
            }
            
            // Build modal content
            let html = `
                <div class="features-modal-header">
                    <h2>Feature Values</h2>
                    <button class="close-modal" onclick="closeFeaturesModal()">&times;</button>
                </div>
                <div class="features-modal-body">
                    <div class="game-info">
                        <strong>${data.away_team} @ ${data.home_team}</strong><br>
                        <small>${data.game_date} | ${Object.values(data.feature_categories || {}).reduce((sum, arr) => sum + arr.length, 0)} features</small>
                    </div>
            `;
            
            // Category descriptions
            const categoryDescriptions = {
                'outcome_strength': 'Outcome Strength',
                'shooting_efficiency': 'Shooting Efficiency',
                'offensive_engine': 'Offensive Engine',
                'defensive_engine': 'Defensive Engine',
                'pace_volatility': 'Pace & Volatility',
                'schedule_fatigue': 'Schedule & Fatigue',
                'sample_size': 'Sample Size',
                'elo_strength': 'Elo Strength',
                'era_normalization': 'Era Normalization',
                'player_talent': 'Player Talent',
                'absolute_magnitude': 'Absolute Magnitude',
                'injuries': 'Injuries',
                'point_predictions': 'Point Predictions'
            };
            
            // Display features by category
            if (data.feature_categories) {
                for (const [category, features] of Object.entries(data.feature_categories)) {
                    if (features.length === 0) continue;
                    
                    html += `
                        <div class="feature-category">
                            <h3>${categoryDescriptions[category] || category}</h3>
                            <table class="features-table">
                                <thead>
                                    <tr>
                                        <th>Feature</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;
                    
                    features.forEach(f => {
                        const value = typeof f.value === 'number' ? f.value.toFixed(4) : f.value;
                        html += `
                            <tr>
                                <td class="feature-name">${f.name}</td>
                                <td class="feature-value">${value}</td>
                            </tr>
                        `;
                    });
                    
                    html += `
                                </tbody>
                            </table>
                        </div>
                    `;
                }
            }
            
            // Add injured players section
            if (data.home_injured_players && data.home_injured_players.length > 0 || 
                data.away_injured_players && data.away_injured_players.length > 0) {
                html += `
                    <div class="feature-category">
                        <h3>Injured Players</h3>
                        <div style="padding: 10px;">
                `;
                if (data.home_injured_players && data.home_injured_players.length > 0) {
                    html += `
                        <div style="margin-bottom: 10px;">
                            <strong>${data.home_team}:</strong> ${data.home_injured_players.join(', ')}
                        </div>
                    `;
                }
                if (data.away_injured_players && data.away_injured_players.length > 0) {
                    html += `
                        <div>
                            <strong>${data.away_team}:</strong> ${data.away_injured_players.join(', ')}
                        </div>
                    `;
                }
                html += `
                        </div>
                    </div>
                `;
            }
            
            // Add player lists section for player-level features
            if (data.feature_players && Object.keys(data.feature_players).length > 0) {
                html += `
                    <div class="feature-category">
                        <h3>Players Involved in Feature Calculations</h3>
                        <div style="padding: 10px;">
                `;
                
                // Group PER features by type
                const perFeatureGroups = {
                    'player_team_per|season|avg': 'Team PER Average',
                    'player_team_per|season|weighted_MPG': 'Team PER Weighted (MPG)',
                    'player_starters_per|season|avg': 'Starters PER Average',
                    'player_per_1|season|top1_avg': 'Top Player PER (1st)',
                    'player_per_2|season|top1_avg': 'Top Player PER (2nd)',
                    'player_per_3|season|top1_avg': 'Top Player PER (3rd)'
                };
                
                for (const [featureBase, featureLabel] of Object.entries(perFeatureGroups)) {
                    const homeFeature = `${featureBase}|home`;
                    const awayFeature = `${featureBase}|away`;
                    
                    const homePlayers = data.feature_players[homeFeature] || [];
                    const awayPlayers = data.feature_players[awayFeature] || [];
                    
                    if (homePlayers.length > 0 || awayPlayers.length > 0) {
                        html += `
                            <div style="margin-bottom: 20px; border-bottom: 1px solid #e0e0e0; padding-bottom: 15px;">
                                <h4 style="margin-bottom: 10px; color: #1976d2;">${featureLabel}</h4>
                        `;
                        
                        if (homePlayers.length > 0) {
                            html += `
                                <div style="margin-bottom: 10px;">
                                    <strong>${data.home_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            homePlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        if (awayPlayers.length > 0) {
                            html += `
                                <div>
                                    <strong>${data.away_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            awayPlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                    }
                }
                
                // Group injury features by type
                const injuryFeatureGroups = {
                    'inj_per|none|weighted_MIN': 'Injury PER Value (Weighted)',
                    'inj_per|none|top1_avg': 'Injury Top 1 PER',
                    'inj_per|none|top3_sum': 'Injury Top 3 PER Sum',
                    'inj_min_lost|none|raw': 'Injury Minutes Lost',
                    'inj_rotation_per|none|raw': 'Injury Rotation Count'
                };
                
                for (const [featureBase, featureLabel] of Object.entries(injuryFeatureGroups)) {
                    const homeFeature = `${featureBase}|home`;
                    const awayFeature = `${featureBase}|away`;
                    
                    // Use new format only
                    const homePlayers = data.feature_players[homeFeature] || [];
                    const awayPlayers = data.feature_players[awayFeature] || [];
                    
                    if (homePlayers.length > 0 || awayPlayers.length > 0) {
                        html += `
                            <div style="margin-bottom: 20px; border-bottom: 1px solid #e0e0e0; padding-bottom: 15px;">
                                <h4 style="margin-bottom: 10px; color: #d32f2f;">${featureLabel}</h4>
                        `;
                        
                        if (homePlayers.length > 0) {
                            html += `
                                <div style="margin-bottom: 10px;">
                                    <strong>${data.home_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            homePlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                const weightedPerStr = player.weighted_per !== undefined ? ` (Weighted PER: ${player.weighted_per.toFixed(2)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}${weightedPerStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        if (awayPlayers.length > 0) {
                            html += `
                                <div>
                                    <strong>${data.away_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            awayPlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                const weightedPerStr = player.weighted_per !== undefined ? ` (Weighted PER: ${player.weighted_per.toFixed(2)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}${weightedPerStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                    }
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            modalContent.innerHTML = html;
        })
        .catch(error => {
            console.error('Error loading features:', error);
            modalContent.innerHTML = `<div style="padding: 20px; color: #d32f2f;"><p>Error loading features: ${error.message}</p></div>`;
        });
    }
    
    function closeFeaturesModal() {
        document.getElementById('features-modal').style.display = 'none';
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
        const modal = document.getElementById('features-modal');
        if (event.target === modal) {
            closeFeaturesModal();
        }
    }
</script>

<!-- Matchup Chat Modal -->
{% include 'matchup_chat_modal.html' %}

<script>
// Matchup Chat Functions
let matchupChatSessionId = null;

async function openMatchupChat(gameId, homeTeam, awayTeam, gameDate) {
    try {
        // Get game info for header from page context
        let gameInfo = {
            home_team: homeTeam,
            away_team: awayTeam,
            date: gameDate,
            game_id: gameId,
            home_team_logo: {{ home_team_logo|tojson|safe if home_team_logo else 'null' }},
            away_team_logo: {{ away_team_logo|tojson|safe if away_team_logo else 'null' }},
            home_team_color: {{ home_team_color|tojson|safe }} || '667eea',
            away_team_color: {{ away_team_color|tojson|safe }} || '666666',
            pregame_lines: {{ pregame_lines|tojson|safe if pregame_lines else '{}' }},
            last_prediction: {{ last_prediction|tojson|safe if last_prediction else '{}' }},
            home_points: null,
            away_points: null
        };
        
        // Create or get session
        const sessionResponse = await fetch('/api/matchup-chat/sessions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_id: gameId,
                home_team: homeTeam,
                away_team: awayTeam,
                game_date: gameDate
            })
        });
        
        if (!sessionResponse.ok) {
            const errorData = await sessionResponse.json().catch(() => ({ error: 'Failed to create session' }));
            alert(`Error: ${errorData.error || 'Failed to create chat session'}`);
            return;
        }
        
        const sessionData = await sessionResponse.json();
        matchupChatSessionId = sessionData.session_id;
        
        // Update game card in header
        updateMatchupChatGameCard(gameInfo);
        
        // Load existing messages
        await loadMatchupChatMessages();
        
        // Show modal
        const modal = document.getElementById('matchupChatModal');
        if (modal) {
            modal.style.display = 'flex';
            // Focus input
            const input = document.getElementById('matchupChatInput');
            if (input) {
                setTimeout(() => input.focus(), 100);
            }
        }
    } catch (error) {
        console.error('Error opening matchup chat:', error);
        alert(`Error: ${error.message}`);
    }
}

function updateMatchupChatGameCard(game) {
    const gameCardEl = document.getElementById('matchupChatGameCard');
    if (!gameCardEl) return;
    
    const homeTeam = game.home_team || game.homeTeam?.name || '';
    const awayTeam = game.away_team || game.awayTeam?.name || '';
    const gameDate = game.date || '';
    const homeLogo = game.home_team_logo || '';
    const awayLogo = game.away_team_logo || '';
    const homeColor = game.home_team_color || '667eea';
    const awayColor = game.away_team_color || '666666';
    const pregameLines = game.pregame_lines || {};
    const lastPrediction = game.last_prediction || {};
    const homePoints = game.home_points || game.homeTeam?.points;
    const awayPoints = game.away_points || game.awayTeam?.points;
    
    let html = '<div class="game-teams">';
    
    // Away team
    html += '<div class="team-panel away">';
    if (awayLogo) {
        html += `<img src="${awayLogo}" alt="${awayTeam} logo" class="team-logo-small">`;
    }
    html += `<div class="team-abbreviation" style="color: #${awayColor};">${awayTeam}`;
    if (pregameLines.away_ml !== undefined && pregameLines.away_ml !== null) {
        html += `<span class="moneyline">(${pregameLines.away_ml >= 0 ? '+' : ''}${pregameLines.away_ml})</span>`;
    }
    html += '</div>';
    if (awayPoints !== undefined && awayPoints !== null) {
        html += `<div class="team-score" style="color: #${awayColor};">${awayPoints}</div>`;
    } else if (pregameLines.spread !== undefined && pregameLines.spread !== null) {
        const awaySpread = -pregameLines.spread;
        html += `<div class="spread" style="color: #${awayColor};">${awaySpread >= 0 ? '+' : ''}${awaySpread.toFixed(1)}</div>`;
    }
    if (lastPrediction.away_win_prob !== undefined && lastPrediction.away_win_prob !== null) {
        html += `<div class="prediction-banner">${Math.round(lastPrediction.away_win_prob)}%`;
        if (lastPrediction.away_odds !== undefined && lastPrediction.away_odds !== null) {
            html += ` (${lastPrediction.away_odds >= 0 ? '+' : ''}${Math.round(lastPrediction.away_odds)})`;
        }
        html += '</div>';
    }
    if (lastPrediction.away_points_pred !== undefined && lastPrediction.away_points_pred !== null) {
        html += `<div class="points-prediction">${Math.round(lastPrediction.away_points_pred)} pts</div>`;
    }
    html += '</div>';
    
    html += '<div class="vs">@</div>';
    
    // Home team
    html += '<div class="team-panel home">';
    if (homeLogo) {
        html += `<img src="${homeLogo}" alt="${homeTeam} logo" class="team-logo-small">`;
    }
    html += `<div class="team-abbreviation" style="color: #${homeColor};">${homeTeam}`;
    if (pregameLines.home_ml !== undefined && pregameLines.home_ml !== null) {
        html += `<span class="moneyline">(${pregameLines.home_ml >= 0 ? '+' : ''}${pregameLines.home_ml})</span>`;
    }
    html += '</div>';
    if (homePoints !== undefined && homePoints !== null) {
        html += `<div class="team-score" style="color: #${homeColor};">${homePoints}</div>`;
    } else if (pregameLines.spread !== undefined && pregameLines.spread !== null) {
        html += `<div class="spread" style="color: #${homeColor};">${pregameLines.spread >= 0 ? '+' : ''}${pregameLines.spread.toFixed(1)}</div>`;
    }
    if (lastPrediction.home_win_prob !== undefined && lastPrediction.home_win_prob !== null) {
        html += `<div class="prediction-banner">${Math.round(lastPrediction.home_win_prob)}%`;
        if (lastPrediction.home_odds !== undefined && lastPrediction.home_odds !== null) {
            html += ` (${lastPrediction.home_odds >= 0 ? '+' : ''}${Math.round(lastPrediction.home_odds)})`;
        }
        html += '</div>';
    }
    if (lastPrediction.home_points_pred !== undefined && lastPrediction.home_points_pred !== null) {
        html += `<div class="points-prediction">${Math.round(lastPrediction.home_points_pred)} pts</div>`;
    }
    html += '</div>';
    
    html += '</div>';
    if (gameDate) {
        html += `<div class="game-date">${gameDate}</div>`;
    }
    
    gameCardEl.innerHTML = html;
}

function closeMatchupChat() {
    const modal = document.getElementById('matchupChatModal');
    if (modal) {
        modal.style.display = 'none';
    }
    matchupChatSessionId = null;
}

async function loadMatchupChatMessages() {
    if (!matchupChatSessionId) return;
    
    try {
        const response = await fetch(`/api/matchup-chat/sessions/${matchupChatSessionId}`);
        if (!response.ok) return;
        
        const data = await response.json();
        if (!data.success) return;
        
        const messages = data.session.messages || [];
        const messagesDiv = document.getElementById('matchupChatMessages');
        if (!messagesDiv) return;
        
        messagesDiv.innerHTML = '';
        
        for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            if (msg.role === 'user' || msg.role === 'assistant') {
                addMatchupMessage(msg.role, msg.content, i);
            }
        }
        
        scrollMatchupChatToBottom();
    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function addMatchupMessage(role, content, index = null) {
    const messagesDiv = document.getElementById('matchupChatMessages');
    if (!messagesDiv) return null;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `matchup-chat-message ${role}`;
    
    // Store message index and role for deletion
    if (index !== null) {
        messageDiv.setAttribute('data-message-index', index);
    }
    messageDiv.setAttribute('data-message-role', role);
    
    // Store plain text content for deletion
    const plainText = typeof content === 'string' ? content : String(content);
    messageDiv.setAttribute('data-plain-text', plainText.replace(/\\n/g, '\n'));
    
    // Create message bubble wrapper
    const messageBubble = document.createElement('div');
    messageBubble.className = 'message-bubble';
    
    // Add delete button
    const deleteButton = document.createElement('button');
    deleteButton.className = 'matchup-chat-delete-button';
    deleteButton.innerHTML = '×';
    deleteButton.title = 'Delete message';
    deleteButton.onclick = () => deleteMatchupMessage(deleteButton);
    messageBubble.appendChild(deleteButton);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    
    // Handle user messages - preserve newlines using CSS white-space: pre-wrap
    if (role === 'user') {
        if (typeof content === 'string') {
            // Unescape any escaped newlines and escape HTML to prevent XSS
            let contentToRender = content.replace(/\\n/g, '\n');
            contentToRender = contentToRender
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            contentDiv.textContent = contentToRender;
        }
    }
    // Render markdown for assistant messages
    else if (role === 'assistant') {
        try {
            // Check if marked is available
            const markedAvailable = typeof marked !== 'undefined' && (marked.parse || typeof marked === 'function');
            
            if (markedAvailable) {
                // Configure marked options
                if (typeof marked.setOptions === 'function') {
                    marked.setOptions({
                        breaks: true,
                        gfm: true
                    });
                } else if (typeof marked.use === 'function') {
                    marked.use({
                        breaks: true,
                        gfm: true
                    });
                }
                
                // Ensure content has proper line breaks preserved
                let contentToRender = content;
                if (typeof content === 'string') {
                    contentToRender = content.replace(/\\n/g, '\n');
                }
                
                // Render markdown to HTML
                let renderedContent;
                if (typeof marked.parse === 'function') {
                    renderedContent = marked.parse(contentToRender);
                } else if (typeof marked === 'function') {
                    renderedContent = marked(contentToRender);
                } else {
                    throw new Error('marked.parse is not available');
                }
                
                // Verify it's actually HTML
                if (!renderedContent || !renderedContent.includes('<')) {
                    renderedContent = contentToRender.replace(/\n/g, '<br>');
                }
                
                contentDiv.innerHTML = renderedContent;
            } else {
                // marked.js not loaded, use fallback
                let fallbackContent = content;
                if (typeof content === 'string') {
                    fallbackContent = content.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
                }
                contentDiv.innerHTML = fallbackContent;
            }
        } catch (e) {
            console.error('Error rendering markdown:', e);
            // Fallback: preserve newlines as <br> tags
            let fallbackContent = content;
            if (typeof content === 'string') {
                fallbackContent = content.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
            }
            contentDiv.innerHTML = fallbackContent;
        }
    }
    
    messageBubble.appendChild(contentDiv);
    messageDiv.appendChild(messageBubble);
    messagesDiv.appendChild(messageDiv);
    
    scrollMatchupChatToBottom();
    return messageDiv;
}

async function deleteMatchupMessage(button) {
    const messageDiv = button.closest('.matchup-chat-message');
    if (!messageDiv) return;
    
    const messageIndex = messageDiv.getAttribute('data-message-index');
    const role = messageDiv.getAttribute('data-message-role');
    const messageContent = messageDiv.getAttribute('data-plain-text') || '';
    
    if (!matchupChatSessionId) {
        // Just remove from DOM if no session
        messageDiv.remove();
        return;
    }
    
    try {
        const response = await fetch(`/api/matchup-chat/sessions/${matchupChatSessionId}/messages`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message_index: messageIndex !== null && messageIndex !== '' ? parseInt(messageIndex) : null,
                message_content: messageContent,
                message_role: role
            })
        });
        
        const data = await response.json();
        if (data.success) {
            // If this is a user message, populate the input field with its text
            if (role === 'user' && messageContent) {
                const input = document.getElementById('matchupChatInput');
                if (input) {
                    input.value = messageContent;
                    input.focus();
                    input.setSelectionRange(input.value.length, input.value.length);
                }
            }
            
            // Remove from DOM
            messageDiv.remove();
            
            // Reload messages to update indices
            await loadMatchupChatMessages();
        } else {
            alert('Error deleting message: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error deleting message:', error);
        alert('Error deleting message');
    }
}

function scrollMatchupChatToBottom() {
    const messagesDiv = document.getElementById('matchupChatMessages');
    if (messagesDiv) {
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
}

async function sendMatchupMessage(event) {
    event.preventDefault();
    
    const input = document.getElementById('matchupChatInput');
    if (!input) return;
    
    const message = input.value.trim();
    if (!message || !matchupChatSessionId) return;
    
    // Add user message to UI
    addMatchupMessage('user', message);
    input.value = '';
    
    // Show loading - create loading element properly
    const messagesDiv = document.getElementById('matchupChatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'matchup-chat-message assistant';
    loadingDiv.id = 'matchup-loading-message';
    const loadingContent = document.createElement('div');
    loadingContent.className = 'message-content';
    const loadingSpinner = document.createElement('div');
    loadingSpinner.className = 'matchup-chat-loading';
    loadingContent.appendChild(loadingSpinner);
    loadingDiv.appendChild(loadingContent);
    messagesDiv.appendChild(loadingDiv);
    scrollMatchupChatToBottom();
    
    try {
        const response = await fetch('/api/matchup-chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                session_id: matchupChatSessionId,
                memory: (() => {
                    const memoryInput = document.getElementById('matchupChatMemoryInput');
                    const memoryValue = memoryInput ? memoryInput.value.trim() : '';
                    return memoryValue === '' ? null : (parseInt(memoryValue) || null);
                })()
            })
        });
        
        // Remove loading message
        const loadingMsg = document.getElementById('matchup-loading-message');
        if (loadingMsg) {
            loadingMsg.remove();
        }
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Request failed' }));
            addMatchupMessage('assistant', `Error: ${errorData.error || 'Request failed'}`);
            return;
        }
        
        const data = await response.json();
        if (data.success) {
            addMatchupMessage('assistant', data.response);
        } else {
            addMatchupMessage('assistant', `Error: ${data.error || 'Unknown error'}`);
        }
    } catch (error) {
        // Remove loading message
        const loadingMsg = document.getElementById('matchup-loading-message');
        if (loadingMsg) {
            loadingMsg.remove();
        }
        
        addMatchupMessage('assistant', `Error: ${error.message}`);
    }
}

// Initialize matchup chat input handlers
document.addEventListener('DOMContentLoaded', function() {
    const matchupChatInput = document.getElementById('matchupChatInput');
    if (matchupChatInput) {
        matchupChatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const form = document.getElementById('matchupChatForm');
                if (form) {
                    form.dispatchEvent(new Event('submit'));
                }
            }
        });
    }
    
    // Close modal on escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const modal = document.getElementById('matchupChatModal');
            if (modal && modal.style.display !== 'none') {
                closeMatchupChat();
            }
        }
    });
});
</script>

<!-- Features Modal -->
<div id="features-modal" class="features-modal" style="display: none;">
    <div id="features-modal-content" class="features-modal-content"></div>
</div>

{% endblock %}


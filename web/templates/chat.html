{% extends "base.html" %}

{% block title %}NBA Modeler Chat{% endblock %}

{% block extra_head %}
<script>
    // Define functions before the script tag that uses them
    function configureMarked() {
        if (typeof marked === 'undefined') {
            console.error('marked.js script loaded but marked is undefined');
            return;
        }
        console.log('marked.js loaded successfully');
        // Configure marked with default options
        if (typeof marked.setOptions === 'function') {
            marked.setOptions({
                breaks: true,
                gfm: true
            });
        }
        // Test that it works
        const testMarkdown = '# Test\n\nThis is **bold** text.';
        let testHtml;
        if (typeof marked.parse === 'function') {
            testHtml = marked.parse(testMarkdown);
        } else if (typeof marked === 'function') {
            testHtml = marked(testMarkdown);
        }
        console.log('marked.js test - input:', testMarkdown);
        console.log('marked.js test - output:', testHtml);
        if (!testHtml || !testHtml.includes('<')) {
            console.error('marked.js is not producing HTML!');
        }
        // Set a flag that marked is ready
        window.markedReady = true;
    }
    
    function handleMarkedError() {
        console.error('Failed to load marked.js from CDN');
        // Try fallback CDN
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/marked@9.1.6/marked.min.js';
        script.onload = configureMarked;
        script.onerror = function() {
            console.error('Both marked.js CDN sources failed');
        };
        document.head.appendChild(script);
    }
</script>
<!-- Marked.js for markdown rendering - using stable version with global access -->
<script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js" onload="configureMarked()" onerror="handleMarkedError()"></script>
<script>
    // Also check on DOMContentLoaded in case script loaded before this
    window.addEventListener('DOMContentLoaded', function() {
        if (typeof marked !== 'undefined') {
            configureMarked();
        }
    });
</script>
{% endblock %}

{% block styles %}
<style>
    .chat-container {
        display: flex;
        height: 100vh;
        gap: 20px;
        position: relative;
        overflow: hidden;
    }
    
    .chat-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
        border-radius: 8px;
        position: relative;
        height: 100%;
        overflow: hidden;
        max-height: 100vh;
    }
    
    .session-name-header {
        padding: 15px 20px;
        background: white;
        border-bottom: 1px solid #ddd;
        flex-shrink: 0;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .info-icon {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #667eea;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        transition: background 0.2s;
        flex-shrink: 0;
    }
    
    .info-icon:hover {
        background: #5568d3;
    }
    
    .info-panel-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.3);
        z-index: 999;
        display: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .info-panel-backdrop.open {
        display: block;
        opacity: 1;
    }
    
    .info-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 50vw;
        height: 100vh;
        background: white;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
    }
    
    .info-panel.open {
        transform: translateX(0);
    }
    
    .info-panel-header {
        padding: 20px;
        border-bottom: 1px solid #ddd;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .info-panel-title {
        font-size: 1.2em;
        font-weight: 600;
    }
    
    .info-panel-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .info-panel-close:hover {
        color: #333;
    }
    
    .info-panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    
    .info-panel-form {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .info-panel-textarea {
        width: 100%;
        min-height: 100px;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        resize: vertical;
        font-family: inherit;
    }
    
    .info-panel-textarea:focus {
        outline: none;
        border-color: #667eea;
    }
    
    .info-panel-add-button {
        padding: 10px 20px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        align-self: flex-start;
    }
    
    .info-panel-add-button:hover {
        background: #5568d3;
    }
    
    .info-items-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .info-item {
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #f8f9fa;
        overflow: hidden;
    }
    
    .info-item-header {
        padding: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        background: white;
        border-bottom: 1px solid #ddd;
    }
    
    .info-item-header:hover {
        background: #f8f9fa;
    }
    
    .info-item-content {
        padding: 12px;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    
    .info-item-content.collapsed {
        max-height: 3em;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
    }
    
    .info-item-actions {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    
    .info-item-edit-button,
    .info-item-delete-button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 14px;
        color: #666;
        border-radius: 4px;
    }
    
    .info-item-edit-button:hover {
        background: #e9ecef;
        color: #333;
    }
    
    .info-item-delete-button {
        color: #dc3545;
    }
    
    .info-item-delete-button:hover {
        background: #f8d7da;
        color: #c82333;
    }
    
    .info-item-edit-form {
        display: none;
        padding: 12px;
        border-top: 1px solid #ddd;
    }
    
    .info-item-edit-form.active {
        display: block;
    }
    
    .info-item-edit-textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        border: 2px solid #667eea;
        border-radius: 4px;
        font-size: 14px;
        resize: vertical;
        font-family: inherit;
    }
    
    .info-item-edit-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
    }
    
    .info-item-save-button,
    .info-item-cancel-button {
        padding: 6px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    .info-item-save-button {
        background: #667eea;
        color: white;
    }
    
    .info-item-save-button:hover {
        background: #5568d3;
    }
    
    .info-item-cancel-button {
        background: #e9ecef;
        color: #666;
    }
    
    .info-item-cancel-button:hover {
        background: #dee2e6;
    }
    
    .info-item-toggle {
        flex: 1;
        text-align: left;
        font-size: 0.9em;
        color: #666;
    }
    
    .session-name-input-wrapper {
        flex: 1;
    }
    
    .session-name-input {
        width: 100%;
        border: none;
        outline: none;
        font-size: 1.1em;
        font-weight: 500;
        padding: 8px 12px;
        border-radius: 4px;
        background: #f8f9fa;
        transition: background 0.2s;
    }
    
    .session-name-input:focus {
        background: white;
        box-shadow: 0 0 0 2px #667eea;
    }
    
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        min-height: 0; /* Allow flex child to shrink */
    }
    
    .message {
        display: flex;
        gap: 10px;
        max-width: 80%;
    }
    
    .message.user {
        align-self: flex-end;
        flex-direction: row-reverse;
    }
    
    .message.assistant {
        align-self: flex-start;
    }
    
    .message-bubble {
        padding: 12px 16px;
        border-radius: 12px;
        word-wrap: break-word;
    }
    
    .message.user .message-bubble {
        background: #667eea;
        color: white;
    }
    
    .message.assistant .message-bubble {
        background: white;
        color: #333;
        border: 1px solid #ddd;
        position: relative;
    }
    
    .message.user .message-bubble {
        position: relative;
    }
    
    .message.assistant {
        position: relative;
    }
    
    .message.user {
        position: relative;
    }
    
    .copy-button {
        position: absolute;
        top: 8px;
        right: 8px;
        background: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 6px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s, background 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
    }
    
    .message.assistant:hover .copy-button {
        opacity: 1;
    }
    
    .message:hover .delete-button {
        opacity: 1;
    }
    
    .copy-button:hover {
        background: #e0e0e0;
    }
    
    .delete-button {
        position: absolute;
        top: 8px;
        background: #ff4444;
        border: 1px solid #cc0000;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        color: white;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }
    
    .message.user .delete-button {
        right: 8px;
    }
    
    .message.assistant .delete-button {
        right: 40px; /* Position to the left of copy button */
    }
    
    .delete-button:hover {
        background: #cc0000;
    }
    
    .copy-button:active {
        background: #d0d0d0;
    }
    
    .copy-button svg {
        width: 16px;
        height: 16px;
        stroke: #666;
    }
    
    .copy-button.copied {
        background: #4caf50;
        border-color: #4caf50;
    }
    
    .copy-button.copied svg {
        stroke: white;
    }
    
    .message-content {
        line-height: 1.6;
        padding-right: 40px; /* Space for copy/delete button */
    }
    
    .message.user .message-content {
        padding-right: 40px; /* Space for delete button */
        white-space: pre-wrap; /* Preserve newlines and wrap text */
        word-wrap: break-word;
    }
    
    /* Markdown styling for assistant messages */
    .message.assistant .message-content h1,
    .message.assistant .message-content h2,
    .message.assistant .message-content h3,
    .message.assistant .message-content h4 {
        margin-top: 1em;
        margin-bottom: 0.5em;
        font-weight: 600;
    }
    
    .message.assistant .message-content h1 {
        font-size: 1.5em;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 0.3em;
    }
    
    .message.assistant .message-content h2 {
        font-size: 1.3em;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 0.3em;
    }
    
    .message.assistant .message-content h3 {
        font-size: 1.1em;
    }
    
    .message.assistant .message-content p {
        margin: 0.5em 0;
        line-height: 1.6;
    }
    
    .message.assistant .message-content ul,
    .message.assistant .message-content ol {
        margin: 0.5em 0;
        padding-left: 1.5em;
    }
    
    .message.assistant .message-content li {
        margin: 0.25em 0;
    }
    
    .message.assistant .message-content code {
        background-color: #f4f4f4;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 0.9em;
    }
    
    .message.assistant .message-content pre {
        background-color: #f4f4f4;
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        margin: 0.5em 0;
    }
    
    .message.assistant .message-content pre code {
        background-color: transparent;
        padding: 0;
    }
    
    .message.assistant .message-content blockquote {
        border-left: 3px solid #ddd;
        padding-left: 1em;
        margin: 0.5em 0;
        color: #666;
    }
    
    .message.assistant .message-content table {
        border-collapse: collapse;
        width: 100%;
        margin: 0.5em 0;
    }
    
    .message.assistant .message-content table th,
    .message.assistant .message-content table td {
        border: 1px solid #ddd;
        padding: 0.5em;
        text-align: left;
    }
    
    .message.assistant .message-content table th {
        background-color: #f4f4f4;
        font-weight: 600;
    }
    
    .message.assistant .message-content strong {
        font-weight: 600;
    }
    
    .message.assistant .message-content em {
        font-style: italic;
    }
    
    .message.assistant .message-content a {
        color: #0066cc;
        text-decoration: none;
    }
    
    .message.assistant .message-content a:hover {
        text-decoration: underline;
    }
    
    .message.assistant .message-content ul,
    .message.assistant .message-content ol {
        margin: 0.5em 0;
        padding-left: 1.5em;
    }
    
    .message.assistant .message-content li {
        margin: 0.25em 0;
    }
    
    .message.assistant .message-content code {
        background: #f4f4f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 0.9em;
    }
    
    .message.assistant .message-content pre {
        background: #f4f4f4;
        padding: 12px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 0.5em 0;
    }
    
    .message.assistant .message-content pre code {
        background: none;
        padding: 0;
    }
    
    .message.assistant .message-content blockquote {
        border-left: 4px solid #ddd;
        padding-left: 1em;
        margin: 0.5em 0;
        color: #666;
    }
    
    .message.assistant .message-content table {
        width: 100%;
        border-collapse: collapse;
        margin: 10px 0;
        font-size: 0.9em;
    }
    
    .message.assistant .message-content table th,
    .message.assistant .message-content table td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid #ddd;
    }
    
    .message.assistant .message-content table th {
        background: #f8f9fa;
        font-weight: 600;
    }
    
    .message.assistant .message-content a {
        color: #0066cc;
        text-decoration: none;
    }
    
    .message.assistant .message-content a:hover {
        text-decoration: underline;
    }
    
    .message.assistant .message-content strong {
        font-weight: 600;
    }
    
    .message.assistant .message-content em {
        font-style: italic;
    }
    
    .chat-input-area {
        flex-shrink: 0;
        padding: 20px;
        border-top: 1px solid #ddd;
        background: white;
        z-index: 10;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .chat-input-form {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .input-row {
        display: flex;
        gap: 10px;
        align-items: flex-end;
    }
    
    .chat-input {
        flex: 1;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        resize: vertical;
        min-height: 44px;
        max-height: 300px;
        overflow-y: auto;
        line-height: 1.5;
    }
    
    .chat-input:focus {
        outline: none;
        border-color: #667eea;
    }
    
    .send-button {
        padding: 12px 24px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
    }
    
    .send-button:hover {
        background: #5568d3;
    }
    
    .send-button:disabled {
        background: #ccc;
        cursor: not-allowed;
    }
    
    .memory-control {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #666;
    }
    
    .memory-control label {
        font-weight: 500;
    }
    
    .memory-input {
        width: 60px;
        padding: 4px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
        font-family: inherit;
    }
    
    .memory-input:focus {
        outline: none;
        border-color: #667eea;
    }
    
    .session-selector {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #666;
    }
    
    .session-selector label {
        font-weight: 500;
    }
    
    .session-select {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
        font-family: inherit;
        background: white;
    }
    
    .session-select:focus {
        outline: none;
        border-color: #667eea;
    }
    
    .new-session-btn {
        width: 28px;
        height: 28px;
        border-radius: 4px;
        border: none;
        background: #667eea;
        color: white;
        font-size: 1.2em;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
        flex-shrink: 0;
    }
    
    .new-session-btn:hover {
        background: #5568d3;
    }
    
    .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        background: white;
        border-top: 1px solid #ddd;
        flex-shrink: 0;
    }
    
    .run-budget {
        font-size: 0.9em;
        color: #666;
    }
    
    .run-budget-value {
        font-weight: 600;
        color: #667eea;
    }
    
    .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .empty-state {
        text-align: center;
        color: #999;
        padding: 40px;
    }
    
    .tool-call-panel {
        margin: 10px 0;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        background: #f8f9fa;
        overflow: visible; /* Changed from hidden to visible so content can show */
        min-height: 40px; /* Ensure panel has minimum height */
        display: block; /* Ensure it's a block element in normal flow */
        width: 100%; /* Take full width */
        flex-shrink: 0; /* Prevent flex from shrinking the panel */
        flex-grow: 0; /* Don't grow, just take natural height */
    }
    
    .tool-call-header {
        padding: 10px 12px;
        background: #e9ecef;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9em;
        font-weight: 600;
        color: #495057;
        min-height: 36px; /* Ensure header has minimum height and is always visible */
        border-bottom: 1px solid #dee2e6;
    }
    
    .tool-call-header:hover {
        background: #dee2e6;
    }
    
    .tool-call-header .tool-name {
        font-family: monospace;
        color: #667eea;
    }
    
    .tool-call-header .toggle-icon {
        transition: transform 0.2s;
        font-size: 0.8em;
        color: #667eea;
        margin-left: 8px;
        flex-shrink: 0; /* Prevent icon from shrinking */
    }
    
    .tool-call-header.collapsed .toggle-icon {
        transform: rotate(-90deg);
    }
    
    .tool-call-header span:first-child {
        flex: 1; /* Allow text to take available space */
        display: flex;
        align-items: center;
        gap: 6px;
    }
    
    .tool-call-content {
        padding: 12px;
        max-height: 500px;
        overflow-y: auto;
        background: #ffffff;
        color: #333;
        display: block;
        width: 100%;
        box-sizing: border-box;
        position: static !important; /* Force static positioning to ensure normal flow */
        clear: both; /* Clear any floats */
        margin: 0; /* No margins that could cause issues */
    }
    
    .tool-call-content.collapsed {
        display: none !important;
    }
    
    .tool-call-input {
        margin-bottom: 10px;
    }
    
    .tool-call-input-label {
        font-size: 0.85em;
        color: #666;
        font-weight: 600;
        margin-bottom: 4px;
    }
    
    .tool-call-input-value {
        background: white;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        font-family: monospace;
        font-size: 0.85em;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-x: auto;
        max-height: 200px;
        overflow-y: auto;
        margin: 0;
    }
    
    .tool-call-output {
        margin-top: 10px;
    }
    
    .tool-call-output-label {
        font-size: 0.85em;
        color: #666;
        font-weight: 600;
        margin-bottom: 4px;
    }
    
    .tool-call-output-value {
        background: white;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        font-family: monospace;
        font-size: 0.85em;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-x: auto;
        max-height: 300px;
        overflow-y: auto;
        margin: 0;
    }
</style>
{% endblock %}

{% block content %}
<div class="chat-container">
    <div class="chat-main">
        <!-- Session Name Input -->
        <div class="session-name-header">
            <div class="info-icon" id="infoIcon" title="Add contextual information">ℹ</div>
            <div class="session-name-input-wrapper">
                <input 
                    type="text" 
                    class="session-name-input" 
                    id="sessionNameInput" 
                    placeholder="Session Name"
                />
            </div>
        </div>
        
        <!-- Info Panel Backdrop -->
        <div class="info-panel-backdrop" id="infoPanelBackdrop"></div>
        
        <!-- Info Panel -->
        <div class="info-panel" id="infoPanel">
            <div class="info-panel-header">
                <div class="info-panel-title">Additional Context</div>
                <button class="info-panel-close" id="infoPanelClose">×</button>
            </div>
            <div class="info-panel-content">
                <div class="info-panel-form">
                    <textarea 
                        class="info-panel-textarea" 
                        id="infoPanelTextarea" 
                        placeholder="Enter contextual information that should be considered in this conversation..."
                    ></textarea>
                    <button class="info-panel-add-button" id="infoPanelAddButton">Add</button>
                </div>
                <div class="info-items-list" id="infoItemsList">
                    <!-- Info items will be dynamically added here -->
                </div>
            </div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="empty-state">
                <p>Start a conversation with the NBA Modeler agent.</p>
                <p style="font-size: 0.9em; margin-top: 10px;">Ask questions about features, model configurations, or request experiments.</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="run-budget">
                Run Budget: <span class="run-budget-value" id="runBudget">15</span> remaining
            </div>
        </div>
        
        <div class="chat-input-area">
            <form class="chat-input-form" id="chatForm">
                <div class="input-row">
                    <textarea 
                        class="chat-input" 
                        id="messageInput" 
                        placeholder="Ask about features, models, or request an experiment... (Shift+Enter for new line)"
                        rows="2"
                    ></textarea>
                    <button type="submit" class="send-button" id="sendButton">Send</button>
                </div>
                <div class="memory-control">
                    <label for="memoryInput">Memory (messages):</label>
                    <input 
                        type="number" 
                        id="memoryInput" 
                        class="memory-input" 
                        value="5" 
                        min="1" 
                        max="100"
                        title="Number of previous messages to include in context"
                    />
                </div>
                <div class="session-selector">
                    <label for="sessionSelect">Session:</label>
                    <select id="sessionSelect" class="session-select">
                        <option value="">Loading sessions...</option>
                    </select>
                    <button type="button" class="new-session-btn" id="newSessionBtn" title="New Chat">+</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let sessionId = null;
let baselineRunId = null;
let currentSessionName = '';

// Get session ID from URL path
const pathMatch = window.location.pathname.match(/^\/chat\/([^\/]+)$/);
if (pathMatch) {
    sessionId = pathMatch[1];
}

// Initialize session
function scrollToBottom() {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) {
        return;
    }
    
    // Scroll to the maximum scroll position
    // Use a large number to ensure we scroll to the absolute bottom
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    
    // Also try scrolling the last element into view as a fallback
    const lastChild = messagesDiv.lastElementChild;
    if (lastChild) {
        lastChild.scrollIntoView({ behavior: 'auto', block: 'end' });
    }
}

async function initSession() {
    // Load sessions list
    await loadSessions();
    
    // If sessionId from URL, load that session
    if (sessionId) {
        await loadSession(sessionId);
    } else {
        // Try to get most recent session or create new one
        const response = await fetch('/api/chat/sessions');
        const data = await response.json();
        if (data.success && data.sessions.length > 0) {
            // Load most recent session
            sessionId = data.sessions[0]._id;
            await loadSession(sessionId);
            // Update URL
            window.history.pushState({}, '', `/chat/${sessionId}`);
        } else {
            // Create new session
            await createNewSession();
        }
    }
    
    // Scroll will be handled by loadSession after messages are rendered
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Load sessions list
async function loadSessions() {
    try {
        const response = await fetch('/api/chat/sessions');
        const data = await response.json();
        if (data.success) {
            renderSessionsSelect(data.sessions);
        }
    } catch (error) {
        console.error('Error loading sessions:', error);
        const select = document.getElementById('sessionSelect');
        if (select) {
            select.innerHTML = '<option value="">Error loading sessions</option>';
        }
    }
}

// Render sessions select
function renderSessionsSelect(sessions) {
    const select = document.getElementById('sessionSelect');
    if (!select) return;
    
    if (sessions.length === 0) {
        select.innerHTML = '<option value="">No sessions yet</option>';
        return;
    }
    
    // Sort sessions by updated_at (most recent first)
    sessions.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    
    select.innerHTML = sessions.map(session => {
        const date = new Date(session.updated_at);
        const dateStr = date.toLocaleDateString();
        const isSelected = session._id === sessionId;
        return `<option value="${session._id}" ${isSelected ? 'selected' : ''}>${escapeHtml(session.name)} (${session.message_count} msgs, ${dateStr})</option>`;
    }).join('');
}

// Load a specific session
async function loadSession(id) {
    try {
        sessionId = id;
        window.history.pushState({}, '', `/chat/${sessionId}`);
        
        const response = await fetch(`/api/chat/sessions/${sessionId}`);
        const data = await response.json();
        
        if (data.success) {
            const session = data.session;
            currentSessionName = session.name;
            
            // Update session name input
            document.getElementById('sessionNameInput').value = session.name;
            
            // Load info items if panel is open
            const infoPanel = document.getElementById('infoPanel');
            if (infoPanel && infoPanel.classList.contains('open')) {
                loadInfoItems();
            }
            
            // Clear messages
            const messagesDiv = document.getElementById('chatMessages');
            messagesDiv.innerHTML = '';
            
                // Load messages - ensure marked.js is ready first
            if (session.messages && session.messages.length > 0) {
                // Wait a bit for marked.js to load if it's not ready yet
                const loadMessages = async () => {
                    // Add all messages to DOM
                    for (const [index, msg] of session.messages.entries()) {
                        // Add the message first
                        const messageElement = addMessage(msg.role, msg.content, index);
                        // Add tool calls BEFORE the message (if they exist)
                        if (msg.tool_calls && msg.tool_calls.length > 0) {
                            addToolCalls(msg.tool_calls, messageElement);
                        }
                    }
                    
                    // Wait for DOM to update and markdown to render
                    // Use requestAnimationFrame to wait for browser to paint
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // Now scroll to bottom after all rendering is complete
                            scrollToBottom();
                            // Also scroll again after a short delay to catch any late rendering
                            setTimeout(() => {
                                scrollToBottom();
                            }, 100);
                        });
                    });
                };
                
                // If marked is not ready, wait a bit (max 2 seconds)
                if (typeof marked === 'undefined' && !window.markedReady) {
                    let attempts = 0;
                    const checkMarked = setInterval(() => {
                        attempts++;
                        if (typeof marked !== 'undefined' || attempts > 20) {
                            clearInterval(checkMarked);
                            loadMessages();
                        }
                    }, 100);
                } else {
                    loadMessages();
                }
            } else {
                messagesDiv.innerHTML = `
                    <div class="empty-state">
                        <p>Start a conversation with the NBA Modeler agent.</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">Ask questions about features, model configurations, or request experiments.</p>
                    </div>
                `;
            }
            
            // Reload sessions select to update active state
            await loadSessions();
        }
    } catch (error) {
        console.error('Error loading session:', error);
        alert('Error loading session');
    }
}

// Create new session
async function createNewSession() {
    try {
        const response = await fetch('/api/chat/sessions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                name: 'New Chat'
            })
        });
        
        const data = await response.json();
        if (data.success) {
            sessionId = data.session_id;
            currentSessionName = data.name;
            document.getElementById('sessionNameInput').value = data.name;
            window.history.pushState({}, '', `/chat/${sessionId}`);
            await loadSessions();
            // Clear messages and show empty state for new session
            const messagesDiv = document.getElementById('chatMessages');
            messagesDiv.innerHTML = `
                <div class="empty-state">
                    <p>Start a conversation with the NBA Modeler agent.</p>
                    <p style="font-size: 0.9em; margin-top: 10px;">Ask questions about features, model configurations, or request experiments.</p>
                </div>
            `;
        }
    } catch (error) {
        console.error('Error creating session:', error);
        alert('Error creating new session');
    }
}

// Update session name
async function updateSessionName(newName) {
    if (!sessionId || !newName.trim()) return;
    
    try {
        const response = await fetch(`/api/chat/sessions/${sessionId}/name`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                name: newName.trim()
            })
        });
        
        const data = await response.json();
        if (data.success) {
            currentSessionName = data.name;
            await loadSessions(); // Refresh list
        }
    } catch (error) {
        console.error('Error updating session name:', error);
    }
}

// Handle session name input
document.getElementById('sessionNameInput').addEventListener('blur', (e) => {
    const newName = e.target.value.trim();
    if (newName && newName !== currentSessionName) {
        updateSessionName(newName);
    } else if (!newName) {
        e.target.value = currentSessionName; // Restore if empty
    }
});

document.getElementById('sessionNameInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.target.blur();
    }
});

// New session button
document.getElementById('newSessionBtn').addEventListener('click', () => {
    createNewSession();
});

// Session select change handler
document.getElementById('sessionSelect').addEventListener('change', (e) => {
    const selectedSessionId = e.target.value;
    if (selectedSessionId && selectedSessionId !== sessionId) {
        loadSession(selectedSessionId);
    }
});

// Delete session
async function deleteSession(id) {
    if (!confirm('Are you sure you want to delete this session? This will delete all messages in this conversation.')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/chat/sessions/${id}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        if (data.success) {
            // If deleted session was current, load most recent or create new
            if (id === sessionId) {
                const sessionsResponse = await fetch('/api/chat/sessions');
                const sessionsData = await sessionsResponse.json();
                if (sessionsData.success && sessionsData.sessions.length > 0) {
                    await loadSession(sessionsData.sessions[0]._id);
                } else {
                    await createNewSession();
                }
            } else {
                // Just reload sessions list
                await loadSessions();
            }
        } else {
            alert('Error deleting session: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error deleting session:', error);
        alert('Error deleting session');
    }
}

// Auto-resize textarea function
function autoResizeTextarea(textarea) {
    textarea.style.height = 'auto';
    const newHeight = Math.min(textarea.scrollHeight, 300); // Max height 300px
    textarea.style.height = newHeight + 'px';
}

// Initialize auto-resize for message input
const messageInput = document.getElementById('messageInput');
if (messageInput) {
    // Auto-resize on input
    messageInput.addEventListener('input', function() {
        autoResizeTextarea(this);
    });
    
    // Initial resize
    autoResizeTextarea(messageInput);
    
    // Handle Shift+Enter for new line, Enter to submit, Command+Enter to resend last user message
    messageInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            // Command+Enter (Mac) or Ctrl+Enter (Windows/Linux) - resend last user message
            if (e.metaKey || e.ctrlKey) {
                e.preventDefault();
                const lastUserMessage = getLastUserMessage();
                if (lastUserMessage) {
                    // Resend the last user message
                    const input = document.getElementById('messageInput');
                    input.value = lastUserMessage;
                    autoResizeTextarea(input);
                    document.getElementById('chatForm').dispatchEvent(new Event('submit'));
                }
                return;
            }
            // Regular Enter - submit current message
            e.preventDefault();
            document.getElementById('chatForm').dispatchEvent(new Event('submit'));
        }
    });
}

// Send message
document.getElementById('chatForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Add user message to chat
    addMessage('user', message);
    input.value = '';
    autoResizeTextarea(input);
    input.value = '';
    autoResizeTextarea(input);
    
    // Show loading
    const loadingId = addMessage('assistant', '<div class="loading"></div>');
    
    try {
        // Create AbortController for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 600000); // 10 minute timeout (increased for long-running experiments)
        
        // Get memory value
        const memoryInput = document.getElementById('memoryInput');
        const memory = memoryInput ? parseInt(memoryInput.value) || 5 : 5;
        
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                session_id: sessionId,
                memory: memory
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        // Check if response is ok
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: `HTTP ${response.status}: ${response.statusText}` }));
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Remove loading message
        removeMessage(loadingId);
        
        if (data.success) {
            // Update session ID if provided
            if (data.session_id) {
                sessionId = data.session_id;
                window.history.pushState({}, '', `/chat/${sessionId}`);
                // Reload sessions list
                await loadSessions();
            }
            
            // Add assistant response first
            const messageElement = addMessage('assistant', data.response);
            
            // Add tool calls BEFORE the message (insert them before the message element)
            if (data.tool_calls && data.tool_calls.length > 0) {
                addToolCalls(data.tool_calls, messageElement);
            }
            
            // Update run budget
            if (data.run_budget_remaining !== undefined) {
                document.getElementById('runBudget').textContent = data.run_budget_remaining;
            }
            
            // Update baseline
            if (data.baseline_run_id) {
                baselineRunId = data.baseline_run_id;
            }
            
        } else {
            addMessage('assistant', `Error: ${data.error || 'Unknown error'}`);
        }
    } catch (error) {
        removeMessage(loadingId);
        let errorMessage = 'Unknown error';
        if (error.name === 'AbortError') {
            errorMessage = 'Request timed out after 10 minutes. The agent may still be processing your request in the background. Please check the backend logs or try again. If the agent was running an experiment, it may complete successfully despite the timeout.';
        } else if (error.message) {
            errorMessage = error.message;
        } else if (error.toString) {
            errorMessage = error.toString();
        }
        console.error('Chat API error:', error);
        addMessage('assistant', `Error: ${errorMessage}`);
    }
});

function addMessage(role, content, messageIndex = null) {
    const messagesDiv = document.getElementById('chatMessages');
    
    // Remove empty state if present
    const emptyState = messagesDiv.querySelector('.empty-state');
    if (emptyState) {
        emptyState.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    
    // Generate message ID if not provided
    const messageId = messageIndex !== null ? `msg-${messageIndex}` : 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    messageDiv.setAttribute('data-message-id', messageId);
    messageDiv.setAttribute('data-message-role', role);
    if (messageIndex !== null) {
        messageDiv.setAttribute('data-message-index', messageIndex);
    }
    
    // Store raw text content for copying (before markdown rendering)
    let plainText = content;
    let renderedContent = content;
    
    // Handle user messages - preserve newlines using CSS white-space: pre-wrap
    if (role === 'user') {
        // Unescape any escaped newlines and escape HTML to prevent XSS
        if (typeof content === 'string') {
            // Unescape any escaped newlines first
            let contentToRender = content.replace(/\\n/g, '\n');
            // Escape HTML to prevent XSS (newlines will be preserved by CSS white-space: pre-wrap)
            // Use a simple HTML escape function that preserves newlines
            renderedContent = contentToRender
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
    }
    // Render markdown for assistant messages
    else if (role === 'assistant') {
        try {
            // Check if marked is available
            // marked v9 exposes marked.parse() or marked() as a function
            const markedAvailable = typeof marked !== 'undefined' && (marked.parse || typeof marked === 'function');
            
            if (markedAvailable) {
                // Configure marked options for v11+
                // marked v11+ uses marked.use() with an extension or marked.setOptions()
                if (typeof marked.setOptions === 'function') {
                    marked.setOptions({
                        breaks: true,
                        gfm: true
                    });
                } else if (typeof marked.use === 'function') {
                    // For marked v11+, use the marked.use() API with options
                    marked.use({
                        breaks: true,
                        gfm: true
                    });
                }
                
                // Ensure content has proper line breaks preserved
                let contentToRender = content;
                if (typeof content === 'string') {
                    // If content has escaped newlines (from JSON), unescape them
                    contentToRender = content.replace(/\\n/g, '\n');
                }
                
                // Render markdown to HTML using marked.parse() or marked()
                if (typeof marked.parse === 'function') {
                    renderedContent = marked.parse(contentToRender);
                } else if (typeof marked === 'function') {
                    // marked might be a function directly (older versions)
                    renderedContent = marked(contentToRender);
                } else {
                    console.error('marked.parse is not a function. marked type:', typeof marked, 'marked:', marked);
                    throw new Error('marked.parse is not available');
                }
                
                // Debug logging
                console.log('Markdown rendering:', {
                    originalLength: contentToRender.length,
                    originalPreview: contentToRender.substring(0, 100),
                    renderedLength: renderedContent.length,
                    renderedPreview: renderedContent.substring(0, 100),
                    hasHtml: renderedContent.includes('<')
                });
                
                // Verify it's actually HTML (should contain tags)
                if (!renderedContent || !renderedContent.includes('<')) {
                    // If no HTML tags, marked might not be working - fallback to <br>
                    console.warn('Marked.js did not produce HTML, using fallback');
                    console.warn('Rendered content preview:', renderedContent.substring(0, 200));
                    renderedContent = contentToRender.replace(/\n/g, '<br>');
                }
                
                // Store plain text (strip HTML for copying)
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = renderedContent;
                plainText = tempDiv.textContent || tempDiv.innerText || content;
            } else {
                // marked.js not loaded or not available
                console.warn('marked.js not available, using fallback rendering');
                let fallbackContent = content;
                if (typeof content === 'string') {
                    fallbackContent = content.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
                }
                renderedContent = fallbackContent;
            }
        } catch (e) {
            console.error('Error rendering markdown:', e);
            // Fallback: preserve newlines as <br> tags
            let fallbackContent = content;
            if (typeof content === 'string') {
                fallbackContent = content.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
            }
            renderedContent = fallbackContent;
        }
    }
    
    // Store plain text for copying/resending
    messageDiv.setAttribute('data-plain-text', plainText);
    // Store raw markdown content (before rendering) for copying
    // Use the original content string, ensuring newlines are preserved
    if (role === 'assistant') {
        const rawMarkdown = typeof content === 'string' ? content.replace(/\\n/g, '\n') : String(content);
        messageDiv.setAttribute('data-raw-markdown', rawMarkdown);
    }
    
    // Add copy button for assistant messages
    let actionButtonHtml = '';
    if (role === 'assistant') {
        actionButtonHtml = `
            <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        `;
    }
    
    // Add delete button for all messages
    actionButtonHtml += `
        <button class="delete-button" onclick="deleteMessage(this)" title="Delete message">×</button>
    `;
    
    // Create message structure
    const messageBubble = document.createElement('div');
    messageBubble.className = 'message-bubble';
    messageBubble.innerHTML = actionButtonHtml;
    
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    // Use innerHTML to insert the rendered markdown HTML
    messageContent.innerHTML = renderedContent;
    
    messageBubble.appendChild(messageContent);
    messageDiv.appendChild(messageBubble);
    
    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    
    return messageDiv;
}

function copyMessage(button) {
    // Get the raw markdown from the parent message div (for assistant messages)
    const messageDiv = button.closest('.message');
    const role = messageDiv.getAttribute('data-message-role');
    
    let textToCopy = '';
    if (role === 'assistant') {
        // For assistant messages, copy the raw markdown (before HTML rendering)
        textToCopy = messageDiv.getAttribute('data-raw-markdown') || messageDiv.getAttribute('data-plain-text') || '';
    } else {
        // For user messages, copy plain text
        textToCopy = messageDiv.getAttribute('data-plain-text') || '';
    }
    
    // Copy to clipboard
    navigator.clipboard.writeText(textToCopy).then(() => {
        // Show feedback
        const originalHtml = button.innerHTML;
        button.classList.add('copied');
        button.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 6L9 17L4 12" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        `;
        
        setTimeout(() => {
            button.classList.remove('copied');
            button.innerHTML = originalHtml;
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard');
    });
}

function addToolCalls(toolCalls, insertBeforeElement = null) {
    const messagesDiv = document.getElementById('chatMessages');
    
    // Remove empty state if present
    const emptyState = messagesDiv.querySelector('.empty-state');
    if (emptyState) {
        emptyState.remove();
    }
    
    toolCalls.forEach(toolCall => {
        const toolPanel = document.createElement('div');
        toolPanel.className = 'tool-call-panel';
        toolPanel.innerHTML = `
            <div class="tool-call-header collapsed" onclick="toggleToolCall(this)">
                <span><span class="tool-name">${escapeHtml(toolCall.name || 'tool')}</span> called</span>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="tool-call-content collapsed">
                ${toolCall.input ? `
                    <div class="tool-call-input">
                        <div class="tool-call-input-label">Input:</div>
                        <pre class="tool-call-input-value">${escapeHtml(JSON.stringify(toolCall.input, null, 2))}</pre>
                    </div>
                ` : `
                    <div class="tool-call-input">
                        <div class="tool-call-input-label">Input:</div>
                        <pre class="tool-call-input-value">(no input)</pre>
                    </div>
                `}
                ${toolCall.output ? `
                    <div class="tool-call-output">
                        <div class="tool-call-output-label">Output:</div>
                        <pre class="tool-call-output-value">${escapeHtml(typeof toolCall.output === 'string' ? toolCall.output : JSON.stringify(toolCall.output, null, 2))}</pre>
                    </div>
                ` : `
                    <div class="tool-call-output">
                        <div class="tool-call-output-label">Output:</div>
                        <pre class="tool-call-output-value">(no output yet)</pre>
                    </div>
                `}
            </div>
        `;
        
        // Insert before the specified element, or append to end
        if (insertBeforeElement) {
            messagesDiv.insertBefore(toolPanel, insertBeforeElement);
        } else {
            messagesDiv.appendChild(toolPanel);
        }
    });
    
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function toggleToolCall(header) {
    const panel = header.closest('.tool-call-panel');
    const content = panel.querySelector('.tool-call-content');
    if (!content) {
        console.error('Tool call content not found');
        return;
    }
    
    const isCollapsed = content.classList.contains('collapsed');
    
    if (isCollapsed) {
        // Expand: show content
        content.classList.remove('collapsed');
        
        // Remove ALL positioning that might take it out of flow
        content.style.position = 'static';
        content.style.top = '';
        content.style.left = '';
        content.style.right = '';
        content.style.bottom = '';
        content.style.margin = '';
        content.style.transform = '';
        content.style.float = '';
        content.style.zIndex = '';
        
        // Set display and visibility - ensure it takes up space
        content.style.display = 'block';
        content.style.visibility = 'visible';
        content.style.opacity = '1';
        content.style.height = 'auto';
        content.style.minHeight = '50px';
        content.style.maxHeight = '500px';
        content.style.overflowY = 'auto';
        content.style.width = '100%';
        content.style.clear = 'both';
        
        // Ensure panel expands with content - calculate explicit height
        const headerHeight = header.offsetHeight;
        const contentHeight = content.scrollHeight; // Use scrollHeight to get full content height
        const totalHeight = headerHeight + contentHeight;
        
        // Set panel to explicit height to ensure it takes up space
        panel.style.height = totalHeight + 'px';
        panel.style.minHeight = '';
        panel.style.maxHeight = '';
        panel.style.overflow = 'visible';
        
        header.classList.remove('collapsed');
        
        // Force reflow to ensure layout updates
        void content.offsetHeight;
        void panel.offsetHeight;
        
        // After a brief delay, set back to auto to allow natural expansion
        setTimeout(() => {
            panel.style.height = 'auto';
        }, 100);
        
        // Debug logging - please check browser console
        setTimeout(() => {
            const computed = window.getComputedStyle(content);
            const panelComputed = window.getComputedStyle(panel);
            console.log('=== TOOL CALL EXPAND DEBUG ===');
            console.log('Content:', {
                display: computed.display,
                position: computed.position,
                height: computed.height,
                offsetHeight: content.offsetHeight,
                scrollHeight: content.scrollHeight
            });
            console.log('Panel:', {
                height: panelComputed.height,
                offsetHeight: panel.offsetHeight,
                display: panelComputed.display
            });
            console.log('Next sibling:', panel.nextElementSibling?.tagName, panel.nextElementSibling?.className);
            console.log('=============================');
        }, 50);
    } else {
        // Collapse: hide content
        content.classList.add('collapsed');
        content.style.display = 'none';
        header.classList.add('collapsed'); // Icon points right
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function removeMessage(messageDiv) {
    if (typeof messageDiv === 'string') {
        // If it's an ID, find the element
        messageDiv = document.getElementById(messageDiv);
    }
    if (messageDiv) {
        messageDiv.remove();
    }
}

// Delete a message
async function deleteMessage(button) {
    const messageDiv = button.closest('.message');
    const messageIndex = messageDiv.getAttribute('data-message-index');
    const role = messageDiv.getAttribute('data-message-role');
    const messageId = messageDiv.getAttribute('data-message-id');
    
    // If message doesn't have an index, it might be a newly sent message that was saved to DB
    // Try to delete it by matching content
    if (!messageIndex || messageIndex === '') {
        // Get message content for matching
        // For assistant messages, prefer raw markdown (original content)
        // For user messages, use plain text (original content)
        let messageContent = '';
        if (role === 'assistant') {
            messageContent = messageDiv.getAttribute('data-raw-markdown') || 
                           messageDiv.getAttribute('data-plain-text') || 
                           messageDiv.querySelector('.message-content')?.textContent?.trim() || '';
        } else {
            messageContent = messageDiv.getAttribute('data-plain-text') || 
                           messageDiv.querySelector('.message-content')?.textContent?.trim() || '';
        }
        
        // If we have content and it's not a loading/temporary message, try to delete from DB
        if (messageContent && !messageContent.includes('loading') && !messageContent.includes('<div class="loading"></div>') && messageContent.length > 0) {
            try {
                const response = await fetch(`/api/chat/sessions/${sessionId}/messages`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message_content: messageContent,
                        message_role: role,
                        message_id: messageId
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Successfully deleted from DB
                    if (role === 'assistant') {
                        deleteToolCallsBeforeMessage(messageDiv);
                    }
                    if (role === 'user') {
                        const plainText = messageDiv.getAttribute('data-plain-text') || messageContent;
                        if (plainText) {
                            const messageInput = document.getElementById('messageInput');
                            if (messageInput) {
                                messageInput.value = plainText;
                                autoResizeTextarea(messageInput);
                                messageInput.focus();
                                messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                            }
                        }
                    }
                    messageDiv.remove();
                    checkForResend();
                    return;
                }
            } catch (error) {
                console.error('Error deleting message by content:', error);
                // Fall through to DOM-only removal
            }
        }
        
        // If deletion by content failed or it's a temporary message, just remove from DOM
        // If this is an assistant message, also delete tool calls that precede it
        if (role === 'assistant') {
            deleteToolCallsBeforeMessage(messageDiv);
        }
        
        // If this is a user message, populate the input field with its text
        if (role === 'user') {
            const plainText = messageDiv.getAttribute('data-plain-text') || messageContent;
            if (plainText) {
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.value = plainText;
                    autoResizeTextarea(messageInput);
                    messageInput.focus();
                    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                }
            }
        }
        
        // Just remove from DOM without calling API (for temporary messages)
        messageDiv.remove();
        checkForResend();
        return;
    }
    
    if (!sessionId) {
        alert('No active session');
        return;
    }
    
    try {
        const response = await fetch(`/api/chat/sessions/${sessionId}/messages`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message_index: parseInt(messageIndex),
                message_id: messageId
            })
        });
        
        const data = await response.json();
        if (data.success) {
            // If this is an assistant message, also delete tool calls that precede it
            if (role === 'assistant') {
                deleteToolCallsBeforeMessage(messageDiv);
            }
            
            // If this is a user message, populate the input field with its text
            if (role === 'user') {
                const plainText = messageDiv.getAttribute('data-plain-text') || '';
                if (plainText) {
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) {
                        messageInput.value = plainText;
                        autoResizeTextarea(messageInput);
                        // Focus the input field
                        messageInput.focus();
                        // Move cursor to end
                        messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    }
                }
            }
            
            // Remove from DOM
            messageDiv.remove();
            
            // If we deleted the last message and the previous one is a user message, 
            // prepare for resend (Command+Enter will work)
            checkForResend();
        } else {
            alert('Error deleting message: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error deleting message:', error);
        alert('Error deleting message');
    }
}

// Delete tool calls that precede an assistant message (between previous user message and this assistant message)
function deleteToolCallsBeforeMessage(assistantMessageDiv) {
    const messagesDiv = document.getElementById('chatMessages');
    const allElements = Array.from(messagesDiv.children);
    
    // Find the index of the assistant message
    const assistantIndex = allElements.indexOf(assistantMessageDiv);
    if (assistantIndex === -1) return;
    
    // Find the previous user message (or start of messages)
    let previousUserIndex = -1;
    for (let i = assistantIndex - 1; i >= 0; i--) {
        const element = allElements[i];
        if (element.classList.contains('message')) {
            const role = element.getAttribute('data-message-role');
            if (role === 'user') {
                previousUserIndex = i;
                break;
            }
        }
    }
    
    // Delete all tool-call-panel elements between previous user message and this assistant message
    // (including tool calls that come after the previous user message but before this assistant message)
    for (let i = assistantIndex - 1; i > previousUserIndex; i--) {
        const element = allElements[i];
        if (element && element.classList.contains('tool-call-panel')) {
            element.remove();
        }
    }
}

// Get the last user message from the chat
function getLastUserMessage() {
    const messagesDiv = document.getElementById('chatMessages');
    const messages = Array.from(messagesDiv.querySelectorAll('.message'));
    
    // Find last user message
    for (let i = messages.length - 1; i >= 0; i--) {
        const msg = messages[i];
        if (msg.getAttribute('data-message-role') === 'user') {
            return msg.getAttribute('data-plain-text') || '';
        }
    }
    return null;
}

// Check if we should enable resend (last message deleted, previous is user message)
function checkForResend() {
    const messagesDiv = document.getElementById('chatMessages');
    const messages = Array.from(messagesDiv.querySelectorAll('.message'));
    
    if (messages.length === 0) return;
    
    const lastMessage = messages[messages.length - 1];
    const lastRole = lastMessage.getAttribute('data-message-role');
    
    // If last message is a user message, we can resend it
    if (lastRole === 'user') {
        // Could show a hint here if desired
    }
}

function formatResponse(text) {
    // Markdown is now handled by marked.js in addMessage()
    // This function is kept for backward compatibility but just returns the text
    return text;
}

async function setBaseline(runId) {
    try {
        const response = await fetch('/api/chat/set-baseline', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                session_id: sessionId,
                run_id: runId
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            baselineRunId = runId;
        }
    } catch (error) {
        console.error('Error setting baseline:', error);
    }
}

// Initialize on page load
// Info Panel Functions
let infoItems = [];

function toggleInfoPanel() {
    const panel = document.getElementById('infoPanel');
    const backdrop = document.getElementById('infoPanelBackdrop');
    panel.classList.toggle('open');
    backdrop.classList.toggle('open');
    if (panel.classList.contains('open')) {
        loadInfoItems();
    }
}

function closeInfoPanel() {
    const panel = document.getElementById('infoPanel');
    const backdrop = document.getElementById('infoPanelBackdrop');
    panel.classList.remove('open');
    backdrop.classList.remove('open');
}

async function loadInfoItems() {
    if (!sessionId) return;
    
    try {
        const response = await fetch(`/api/chat/sessions/${sessionId}/system-info`);
        const data = await response.json();
        if (data.success) {
            infoItems = data.system_info || [];
            renderInfoItems();
        }
    } catch (error) {
        console.error('Error loading info items:', error);
    }
}

function renderInfoItems() {
    const list = document.getElementById('infoItemsList');
    list.innerHTML = '';
    
    infoItems.forEach((item, index) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'info-item';
        itemDiv.setAttribute('data-index', index);
        
        itemDiv.innerHTML = `
            <div class="info-item-header" onclick="toggleInfoItem(${index})">
                <div class="info-item-toggle">${item.substring(0, 50)}${item.length > 50 ? '...' : ''}</div>
                <div class="info-item-actions">
                    <button class="info-item-edit-button" onclick="event.stopPropagation(); startEditInfoItem(${index})">Edit</button>
                    <button class="info-item-delete-button" onclick="event.stopPropagation(); deleteInfoItem(${index})">×</button>
                </div>
            </div>
            <div class="info-item-content collapsed" id="infoItemContent-${index}">${escapeHtml(item)}</div>
            <div class="info-item-edit-form" id="infoItemEditForm-${index}">
                <textarea class="info-item-edit-textarea" id="infoItemEditTextarea-${index}">${escapeHtml(item)}</textarea>
                <div class="info-item-edit-actions">
                    <button class="info-item-save-button" onclick="saveInfoItem(${index})">Save</button>
                    <button class="info-item-cancel-button" onclick="cancelEditInfoItem(${index})">Cancel</button>
                </div>
            </div>
        `;
        
        list.appendChild(itemDiv);
    });
}

function toggleInfoItem(index) {
    const content = document.getElementById(`infoItemContent-${index}`);
    if (content) {
        content.classList.toggle('collapsed');
    }
}

function startEditInfoItem(index) {
    const form = document.getElementById(`infoItemEditForm-${index}`);
    if (form) {
        form.classList.add('active');
        const textarea = document.getElementById(`infoItemEditTextarea-${index}`);
        if (textarea) {
            textarea.focus();
        }
    }
}

function cancelEditInfoItem(index) {
    const form = document.getElementById(`infoItemEditForm-${index}`);
    if (form) {
        form.classList.remove('active');
        const textarea = document.getElementById(`infoItemEditTextarea-${index}`);
        if (textarea) {
            textarea.value = infoItems[index];
        }
    }
}

async function saveInfoItem(index) {
    const textarea = document.getElementById(`infoItemEditTextarea-${index}`);
    if (!textarea) return;
    
    const newValue = textarea.value.trim();
    if (!newValue) {
        alert('Info item cannot be empty');
        return;
    }
    
    infoItems[index] = newValue;
    
    try {
        const response = await fetch(`/api/chat/sessions/${sessionId}/system-info`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({system_info: infoItems})
        });
        
        const data = await response.json();
        if (data.success) {
            renderInfoItems();
            // Invalidate agent session to reload with new system info
            if (sessionId) {
                await fetch(`/api/chat/sessions/${sessionId}/invalidate-agent`, {method: 'POST'});
            }
        } else {
            alert('Error saving info item: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error saving info item:', error);
        alert('Error saving info item');
    }
}

async function deleteInfoItem(index) {
    if (!confirm('Delete this info item?')) return;
    
    infoItems.splice(index, 1);
    
    try {
        const response = await fetch(`/api/chat/sessions/${sessionId}/system-info`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({system_info: infoItems})
        });
        
        const data = await response.json();
        if (data.success) {
            renderInfoItems();
            // Invalidate agent session to reload with new system info
            if (sessionId) {
                await fetch(`/api/chat/sessions/${sessionId}/invalidate-agent`, {method: 'POST'});
            }
        } else {
            alert('Error deleting info item: ' + (data.error || 'Unknown error'));
            // Restore on error
            loadInfoItems();
        }
    } catch (error) {
        console.error('Error deleting info item:', error);
        alert('Error deleting info item');
        // Restore on error
        loadInfoItems();
    }
}

async function addInfoItem() {
    const textarea = document.getElementById('infoPanelTextarea');
    const text = textarea.value.trim();
    
    if (!text) {
        alert('Please enter some text');
        return;
    }
    
    if (!sessionId) {
        alert('No session selected');
        return;
    }
    
    infoItems.push(text);
    
    try {
        const response = await fetch(`/api/chat/sessions/${sessionId}/system-info`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({system_info: infoItems})
        });
        
        const data = await response.json();
        if (data.success) {
            textarea.value = '';
            renderInfoItems();
            // Invalidate agent session to reload with new system info
            await fetch(`/api/chat/sessions/${sessionId}/invalidate-agent`, {method: 'POST'});
        } else {
            alert('Error adding info item: ' + (data.error || 'Unknown error'));
            infoItems.pop(); // Remove on error
        }
    } catch (error) {
        console.error('Error adding info item:', error);
        alert('Error adding info item');
        infoItems.pop(); // Remove on error
    }
}

// Event listeners for info panel
document.addEventListener('DOMContentLoaded', function() {
    const infoIcon = document.getElementById('infoIcon');
    const infoPanelClose = document.getElementById('infoPanelClose');
    const infoPanelAddButton = document.getElementById('infoPanelAddButton');
    
    if (infoIcon) {
        infoIcon.addEventListener('click', toggleInfoPanel);
    }
    
    if (infoPanelClose) {
        infoPanelClose.addEventListener('click', closeInfoPanel);
    }
    
    if (infoPanelAddButton) {
        infoPanelAddButton.addEventListener('click', addInfoItem);
    }
    
    // Close panel when clicking backdrop
    const infoPanelBackdrop = document.getElementById('infoPanelBackdrop');
    if (infoPanelBackdrop) {
        infoPanelBackdrop.addEventListener('click', closeInfoPanel);
    }
});

initSession();

// Scroll to bottom after page fully loads (fallback for cases where initSession hasn't loaded messages yet)
window.addEventListener('load', () => {
    // Wait a bit for any async loading to complete
    setTimeout(() => {
        const messagesDiv = document.getElementById('chatMessages');
        if (messagesDiv && messagesDiv.children.length > 0) {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    scrollToBottom();
                });
            });
        }
    }, 500);
});
</script>
{% endblock %}


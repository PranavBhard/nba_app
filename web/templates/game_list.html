{% extends "base.html" %}

{% block title %}{{ g.league.display_name }} Games - {{ game_date }}{% endblock %}

{% block content %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <div>
        <h1>{{ g.league.display_name }} Games</h1>
        <p class="subtitle">Select a game to manage players and generate predictions</p>
    </div>
    <a href="/{{ g.league_id }}/model-config" target="_blank" class="gear-icon" title="Model Configuration">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M19.4 15C19.2669 15.3016 19.2272 15.6362 19.286 15.9606C19.3448 16.285 19.4995 16.5843 19.73 16.82L19.79 16.88C19.976 17.0657 20.1235 17.2863 20.2241 17.5291C20.3248 17.7719 20.3766 18.0322 20.3766 18.295C20.3766 18.5578 20.3248 18.8181 20.2241 19.0609C20.1235 19.3037 19.976 19.5243 19.79 19.71C19.6043 19.896 19.3837 20.0435 19.1409 20.1441C18.8981 20.2448 18.6378 20.2966 18.375 20.2966C18.1122 20.2966 17.8519 20.2448 17.6091 20.1441C17.3663 20.0435 17.1457 19.896 16.96 19.71L16.9 19.65C16.6643 19.4195 16.365 19.2648 16.0406 19.206C15.7162 19.1472 15.3816 19.1869 15.08 19.32C14.7842 19.4468 14.532 19.6572 14.3543 19.9255C14.1766 20.1938 14.0813 20.5082 14.08 20.83V21C14.08 21.5304 13.8693 22.0391 13.4942 22.4142C13.1191 22.7893 12.6104 23 12.08 23C11.5496 23 11.0409 22.7893 10.6658 22.4142C10.2907 22.0391 10.08 21.5304 10.08 21V20.91C10.0723 20.579 9.96512 20.258 9.77251 19.9887C9.5799 19.7194 9.31074 19.5143 9 19.4C8.69838 19.2669 8.36381 19.2272 8.03941 19.286C7.71502 19.3448 7.41568 19.4995 7.18 19.73L7.12 19.79C6.93425 19.976 6.71368 20.1235 6.47088 20.2241C6.22808 20.3248 5.96783 20.3766 5.705 20.3766C5.44217 20.3766 5.18192 20.3248 4.93912 20.2241C4.69632 20.1235 4.47575 19.976 4.29 19.79C4.10405 19.6043 3.95653 19.3837 3.85588 19.1409C3.75523 18.8981 3.70343 18.6378 3.70343 18.375C3.70343 18.1122 3.75523 17.8519 3.85588 17.6091C3.95653 17.3663 4.10405 17.1457 4.29 16.96L4.35 16.9C4.58054 16.6643 4.73519 16.365 4.794 16.0406C4.85282 15.7162 4.81312 15.3816 4.68 15.08C4.55324 14.7842 4.34276 14.532 4.07447 14.3543C3.80618 14.1766 3.49179 14.0813 3.17 14.08H3C2.46957 14.08 1.96086 13.8693 1.58579 13.4942C1.21071 13.1191 1 12.6104 1 12.08C1 11.5496 1.21071 11.0409 1.58579 10.6658C1.96086 10.2907 2.46957 10.08 3 10.08H3.09C3.42099 10.0723 3.742 9.96512 4.01131 9.77251C4.28062 9.5799 4.48568 9.31074 4.6 9C4.73312 8.69838 4.77282 8.36381 4.714 8.03941C4.65519 7.71502 4.50054 7.41568 4.27 7.18L4.21 7.12C4.02405 6.93425 3.87653 6.71368 3.77588 6.47088C3.67523 6.22808 3.62343 5.96783 3.62343 5.705C3.62343 5.44217 3.67523 5.18192 3.77588 4.93912C3.87653 4.69632 4.02405 4.47575 4.21 4.29C4.39575 4.10405 4.61632 3.95653 4.85912 3.85588C5.10192 3.75523 5.36217 3.70343 5.625 3.70343C5.88783 3.70343 6.14808 3.75523 6.39088 3.85588C6.63368 3.95653 6.85425 4.10405 7.04 4.29L7.1 4.35C7.33568 4.58054 7.63502 4.73519 7.95941 4.794C8.28381 4.85282 8.61838 4.81312 8.92 4.68H9C9.29577 4.55324 9.54802 4.34276 9.72569 4.07447C9.90337 3.80618 9.99872 3.49179 10 3.17V3C10 2.46957 10.2107 1.96086 10.5858 1.58579C10.9609 1.21071 11.4696 1 12 1C12.5304 1 13.0391 1.21071 13.4142 1.58579C13.7893 1.96086 14 2.46957 14 3V3.09C14.0013 3.41179 14.0966 3.72618 14.2743 3.99447C14.452 4.26276 14.7042 4.47324 15 4.6C15.3016 4.73312 15.6362 4.77282 15.9606 4.714C16.285 4.65519 16.5843 4.50054 16.82 4.27L16.88 4.21C17.0657 4.02405 17.2863 3.87653 17.5291 3.77588C17.7719 3.67523 18.0322 3.62343 18.295 3.62343C18.5578 3.62343 18.8181 3.67523 19.0609 3.77588C19.3037 3.87653 19.5243 4.02405 19.71 4.21C19.896 4.39575 20.0435 4.61632 20.1441 4.85912C20.2448 5.10192 20.2966 5.36217 20.2966 5.625C20.2966 5.88783 20.2448 6.14808 20.1441 6.39088C20.0435 6.63368 19.896 6.85425 19.71 7.04L19.65 7.1C19.4195 7.33568 19.2648 7.63502 19.206 7.95941C19.1472 8.28381 19.1869 8.61838 19.32 8.92V9C19.4468 9.29577 19.6572 9.54802 19.9255 9.72569C20.1938 9.90337 20.5082 9.99872 20.83 10H21C21.5304 10 22.0391 10.2107 22.4142 10.5858C22.7893 10.9609 23 11.4696 23 12C23 12.5304 22.7893 13.0391 22.4142 13.4142C22.0391 13.7893 21.5304 14 21 14H20.91C20.5882 14.0013 20.2738 14.0966 20.0055 14.2743C19.7372 14.452 19.5268 14.7042 19.4 15Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>

<div class="date-selector">
    <label for="game-date">Date:</label>
    <input type="date" id="game-date" value="{{ game_date }}" />
    <button onclick="goToDate()">Go</button>
    <button onclick="goToDate('{{ prev_date }}')">← Previous</button>
    <button onclick="goToDate('{{ next_date }}')">Next →</button>
    <button class="run-predictions-btn" onclick="runAllPredictions()">Run Predictions</button>
    <button class="run-predictions-btn" onclick="autoSetLineups()" id="auto-lineup-btn" style="background-color: #6c757d;">Auto-set Lineups</button>
    <div class="betting-report-controls" id="betting-report-controls" style="display: inline-flex; align-items: center; gap: 6px; margin-left: 10px;">
        <label for="bankroll-input" style="font-size: 13px; color: #666;">$</label>
        <input type="number" id="bankroll-input" value="1000" min="1" step="100" style="width: 70px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" title="Bankroll amount" onchange="lastBettingReport = null;">
        <label for="edge-threshold-input" style="font-size: 13px; color: #666; margin-left: 4px;">Edge%</label>
        <input type="number" id="edge-threshold-input" value="7" min="1" max="50" step="1" style="width: 45px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" title="Minimum edge threshold %" onchange="lastBettingReport = null;">
        <button class="generate-report-btn" onclick="generateBettingReport()" title="Generate betting report">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
            Report
        </button>
    </div>
    <button class="pull-data-btn" onclick="pullGameData()" title="Pull game data from ESPN API">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; margin-right: 4px;">
            <path d="M8 2V14M8 14L3 9M8 14L13 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        Pull
    </button>
    <div class="pull-status" id="pull-status">
        {{ games_pulled }}/{{ total_games }} Pulled
    </div>
    <div class="job-progress-container" id="job-progress-container" style="display: none;">
        <div class="job-progress-bar">
            <div class="job-progress-fill" id="job-progress-fill"></div>
        </div>
        <span class="job-progress-text" id="job-progress-text">Starting...</span>
    </div>
</div>

<div class="live-controls-row">
    <div class="live-mode-container">
        <label class="live-mode-toggle">
            <input type="checkbox" id="live-mode-checkbox" onchange="toggleLiveMode(this.checked)">
            <span class="toggle-slider"></span>
        </label>
        <span class="live-mode-label">LIVE MODE</span>
        <div class="poll-interval-container" id="poll-interval-container" style="display: none;">
            <input type="number" id="poll-interval-input" min="5" max="300" placeholder="30" onchange="updatePollInterval(this.value)" title="Polling interval in seconds">
            <span class="poll-interval-unit">sec</span>
        </div>
    </div>
    <button class="refresh-portfolio-btn" onclick="refreshPortfolio()" title="Refresh portfolio positions">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="23 4 23 10 17 10"></polyline>
            <polyline points="1 20 1 14 7 14"></polyline>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
        </svg>
        Refresh
    </button>
    <div class="daily-pnl" id="daily-pnl" style="display: none;">
        <span class="daily-pnl-label">Day P&L:</span>
        <span class="daily-pnl-value" id="daily-pnl-value">$0.00</span>
    </div>
</div>

{% if games %}
    <div class="games-grid">
        {% for game in games %}
        <div class="game-card" onclick="openGameDetail('{{ game.game_id }}', '{{ game_date }}')" data-game-id="{{ game.game_id }}" data-home-team="{{ game.home_team }}" data-away-team="{{ game.away_team }}" data-game-date="{{ game.date }}" data-home-logo="{{ game.home_team_logo or '' }}" data-away-logo="{{ game.away_team_logo or '' }}" data-home-color="{{ game.home_team_color }}" data-away-color="{{ game.away_team_color }}" data-home-points="{{ game.home_points if game.home_points is not none else '' }}" data-away-points="{{ game.away_points if game.away_points is not none else '' }}" data-pregame-lines="{{ game.pregame_lines|tojson|safe if game.pregame_lines else '{}' }}" data-last-prediction="{{ game.last_prediction|tojson|safe if game.last_prediction else '{}' }}" data-game-status="{{ game.status or 'pre' }}" data-gametime="{{ game.gametime|default('', true) }}" style="border-color: #{{ game.home_team_color }};">
            <div style="position:absolute;top:10px;" class="game-card-magic-icon" onclick="event.stopPropagation(); runMagicAnalysis('{{ game.game_id }}', '{{ game.home_team }}', '{{ game.away_team }}', '{{ game.date }}');" title="AI matchup breakdown">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            </div>
            <div class="game-card-icons">
                <div class="game-card-predict-icon" onclick="event.stopPropagation(); runCardPrediction('{{ game.game_id }}', '{{ game.date }}', '{{ game.home_team }}', '{{ game.away_team }}');" title="Run prediction">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </div>
                <div class="game-card-info-icon" onclick="event.stopPropagation(); showGameFeatures('{{ game.game_id }}', '{{ game.date }}', '{{ game.home_team }}', '{{ game.away_team }}');" title="View feature values">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                </div>
                <div class="game-card-message-icon" onclick="event.stopPropagation(); openMatchupChat('{{ game.game_id }}', '{{ game.home_team }}', '{{ game.away_team }}', '{{ game.date }}');" title="Chat about matchup">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    {% if chat_message_counts.get(game.game_id) %}
                    <span class="message-count-badge">{{ chat_message_counts[game.game_id] }}</span>
                    {% endif %}
                </div>
            </div>
            {% if game.gametime %}
            <div class="game-time"><a href="https://www.espn.com/{{ g.league.espn.league_slug }}/game/_/gameId/{{ game.game_id }}" target="_blank" onclick="event.stopPropagation();">{{ game.gametime|gametime_et }}</a></div>
            {% endif %}
            <div class="game-teams">
                <div class="team-panel away">
                    {% if game.away_team_logo %}
                    <img src="{{ game.away_team_logo }}" alt="{{ game.away_team }} logo" class="team-logo-small">
                    {% endif %}
                    <div class="team-abbreviation" style="color: #{{ game.away_team_color }};">
                        {{ game.away_team }}
                        {% if game.pregame_lines and game.pregame_lines.get('away_ml') is not none %}
                        <span class="moneyline">({{ "+" if game.pregame_lines['away_ml'] >= 0 else "" }}{{ game.pregame_lines['away_ml'] }})</span>
                        {% endif %}
                    </div>
                    {% if game.status in ('in', 'post') and game.away_points is not none %}
                    <div class="team-score" style="color: #{{ game.away_team_color }};">
                        {{ game.away_points }}
                    </div>
                    {% elif game.pregame_lines and game.pregame_lines.get('spread') is not none %}
                    {% set away_spread = -game.pregame_lines['spread'] %}
                    <div class="spread" style="color: #{{ game.away_team_color }};">
                        {{ "+" if away_spread >= 0 else "" }}{{ "%.1f"|format(away_spread) }}
                    </div>
                    {% endif %}
                    {% if game.last_prediction and game.last_prediction.get('away_win_prob') is not none %}
                    <div class="prediction-banner">
                        {{ "%.0f"|format(game.last_prediction['away_win_prob']) }}%
                        {% if game.last_prediction.get('away_odds') is not none %}
                        ({{ "+" if game.last_prediction['away_odds'] >= 0 else "" }}{{ "%.0f"|format(game.last_prediction['away_odds']) }})
                        {% endif %}
                    </div>
                    {% endif %}
                    {% if game.last_prediction and game.last_prediction.get('away_points_pred') is not none %}
                    <div class="points-prediction">
                        {{ "%.0f"|format(game.last_prediction['away_points_pred']) }} pts
                    </div>
                    {% endif %}
                    {% if game.away_injured_players and game.away_injured_players|length > 0 %}
                    <div class="injured-players">
                        {{ game.away_injured_players|join(', ') }}
                    </div>
                    {% endif %}
                </div>
                <div class="vs-container">
                    <div class="portfolio-items" id="portfolio-{{ game.game_id }}"></div>
                    <div class="vs">@</div>
                    <div class="portfolio-items parlay-items" id="parlay-{{ game.game_id }}"></div>
                </div>
                <div class="team-panel home">
                    {% if game.home_team_logo %}
                    <img src="{{ game.home_team_logo }}" alt="{{ game.home_team }} logo" class="team-logo-small">
                    {% endif %}
                    <div class="team-abbreviation" style="color: #{{ game.home_team_color }};">
                        {{ game.home_team }}
                        {% if game.pregame_lines and game.pregame_lines.get('home_ml') is not none %}
                        <span class="moneyline">({{ "+" if game.pregame_lines['home_ml'] >= 0 else "" }}{{ game.pregame_lines['home_ml'] }})</span>
                        {% endif %}
                    </div>
                    {% if game.status in ('in', 'post') and game.home_points is not none %}
                    <div class="team-score" style="color: #{{ game.home_team_color }};">
                        {{ game.home_points }}
                    </div>
                    {% elif game.pregame_lines and game.pregame_lines.get('spread') is not none %}
                    <div class="spread" style="color: #{{ game.home_team_color }};">
                        {{ "%.1f"|format(game.pregame_lines['spread']) }}
                    </div>
                    {% endif %}
                    {% if game.last_prediction and game.last_prediction.get('home_win_prob') is not none %}
                    <div class="prediction-banner">
                        {{ "%.0f"|format(game.last_prediction['home_win_prob']) }}%
                        {% if game.last_prediction.get('home_odds') is not none %}
                        ({{ "+" if game.last_prediction['home_odds'] >= 0 else "" }}{{ "%.0f"|format(game.last_prediction['home_odds']) }})
                        {% endif %}
                    </div>
                    {% endif %}
                    {% if game.last_prediction and game.last_prediction.get('home_points_pred') is not none %}
                    <div class="points-prediction">
                        {{ "%.0f"|format(game.last_prediction['home_points_pred']) }} pts
                    </div>
                    {% endif %}
                    {% if game.home_injured_players and game.home_injured_players|length > 0 %}
                    <div class="injured-players">
                        {{ game.home_injured_players|join(', ') }}
                    </div>
                    {% endif %}
                </div>
            </div>
            <div class="game-date">{{ game.date }}</div>
        </div>
        {% endfor %}
    </div>
{% else %}
    <div class="no-games">
        <p>No games scheduled for {{ game_date }}</p>
    </div>
{% endif %}

<style>
    .games-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }
    
    .game-card {
        border: 2px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.3s;
        background: #f9f9f9;
        position: relative;
    }
    
    .game-card:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
    }
    
    .game-teams {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        margin-bottom: 10px;
    }
    
    .team-panel {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        flex: 1;
    }
    
    .team-logo-small {
        width: 50px;
        height: 50px;
        object-fit: contain;
    }
    
    .team-abbreviation {
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
    }
    
    .moneyline {
        font-size: 0.85em;
        font-weight: normal;
        opacity: 0.8;
    }
    
    .spread {
        font-size: 0.9em;
        font-weight: 600;
        text-align: center;
    }
    
    .team-score {
        font-size: 1.5em;
        font-weight: bold;
        text-align: center;
        margin-top: 4px;
    }
    
    .prediction-banner {
        font-size: 0.85em;
        font-weight: 600;
        color: #667eea;
        background: rgba(102, 126, 234, 0.15);
        padding: 4px 8px;
        border-radius: 4px;
        text-align: center;
        margin-top: 2px;
    }
    
    .points-prediction {
        font-size: 0.9em;
        font-weight: 600;
        color: #28a745;
        background: rgba(40, 167, 69, 0.15);
        padding: 4px 8px;
        border-radius: 4px;
        text-align: center;
        margin-top: 4px;
    }
    
    .injured-players {
        font-size: 0.7em;
        color: #dc3545;
        text-align: center;
        margin-top: 4px;
        opacity: 0.8;
        line-height: 1.3;
    }

    .kalshi-price {
        font-size: 0.8em;
        font-weight: 600;
        text-align: center;
        margin-top: 6px;
        padding: 3px 8px;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.08);
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        letter-spacing: 0.02em;
    }

    .kalshi-price.underdog {
        color: #16a34a;
        background: rgba(22, 163, 74, 0.1);
    }

    .kalshi-price.favorite {
        color: #dc2626;
        background: rgba(220, 38, 38, 0.1);
    }

    .kalshi-price.live-glow {
        animation: kalshiGlow 2s ease-in-out infinite;
    }

    @keyframes kalshiGlow {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: 0.7;
        }
    }

    .final-badge {
        font-size: 0.75em;
        font-weight: 600;
        text-align: center;
        margin-top: 6px;
        padding: 3px 8px;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.08);
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .live-status {
        font-size: 0.7em;
        font-weight: 600;
        text-align: center;
        margin-top: 4px;
        padding: 2px 6px;
        border-radius: 3px;
        background: rgba(220, 38, 38, 0.1);
        color: #dc2626;
        letter-spacing: 0.02em;
    }

    .vs-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .vs {
        font-size: 1.2em;
        color: #999;
        margin: 0 10px;
        font-weight: bold;
    }

    .portfolio-items {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3px;
        min-height: 0;
    }

    .portfolio-items.parlay-items {
        border-top: 1px dashed #ccc;
        padding-top: 3px;
        margin-top: 2px;
    }

    .portfolio-item {
        font-size: 0.65em;
        padding: 2px 6px;
        border-radius: 3px;
        line-height: 1.3;
        font-weight: 500;
        text-align: center;
    }

    .portfolio-item.won {
        background: rgba(76, 175, 80, 0.2);
        color: #2e7d32;
        border: 1px solid rgba(76, 175, 80, 0.4);
    }

    .portfolio-item.lost {
        background: rgba(244, 67, 54, 0.2);
        color: #c62828;
        border: 1px solid rgba(244, 67, 54, 0.4);
    }

    .portfolio-item.live {
        background: rgba(33, 150, 243, 0.15);
        color: #1565c0;
        border: 1px solid rgba(33, 150, 243, 0.3);
        animation: portfolio-pulse 2s ease-in-out infinite;
    }

    .portfolio-item.pending {
        background: rgba(255, 152, 0, 0.15);
        color: #e65100;
        border: 1px solid rgba(255, 152, 0, 0.3);
        animation: portfolio-pulse-orange 2s ease-in-out infinite;
    }

    .portfolio-item.parlay {
        font-style: italic;
    }

    .portfolio-item.parlay.combo {
        background: rgba(156, 39, 176, 0.15);
        color: #7b1fa2;
        border: 1px solid rgba(156, 39, 176, 0.3);
    }

    .portfolio-item.parlay.combo.live {
        animation: portfolio-pulse-purple 2s ease-in-out infinite;
    }

    @keyframes portfolio-pulse-purple {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(156, 39, 176, 0.4); }
        50% { opacity: 0.85; box-shadow: 0 0 4px 1px rgba(156, 39, 176, 0.3); }
    }

    @keyframes portfolio-pulse {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
        50% { opacity: 0.85; box-shadow: 0 0 4px 1px rgba(33, 150, 243, 0.3); }
    }

    @keyframes portfolio-pulse-orange {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.4); }
        50% { opacity: 0.85; box-shadow: 0 0 4px 1px rgba(255, 152, 0, 0.3); }
    }

    /* Live fill display with value below main line */
    .fill-main-line {
        white-space: nowrap;
    }

    .fill-live-value {
        font-size: 0.9em;
        opacity: 0.9;
        margin-top: 1px;
    }

    .portfolio-item.live-profit {
        background: rgba(76, 175, 80, 0.15);
        color: #2e7d32;
        border: 1px solid rgba(76, 175, 80, 0.4);
        animation: portfolio-pulse-green 2s ease-in-out infinite;
    }

    .portfolio-item.live-loss {
        background: rgba(244, 67, 54, 0.15);
        color: #c62828;
        border: 1px solid rgba(244, 67, 54, 0.4);
        animation: portfolio-pulse-red 2s ease-in-out infinite;
    }

    @keyframes portfolio-pulse-green {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); }
        50% { opacity: 0.85; box-shadow: 0 0 4px 1px rgba(76, 175, 80, 0.3); }
    }

    @keyframes portfolio-pulse-red {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
        50% { opacity: 0.85; box-shadow: 0 0 4px 1px rgba(244, 67, 54, 0.3); }
    }

    .portfolio-item.has-live-value {
        text-align: center;
        white-space: normal;
    }

    .portfolio-item .live-value {
        font-size: 0.9em;
        opacity: 0.85;
    }

    /* Live Mode Toggle */
    .live-mode-container {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-left: 15px;
        padding-left: 15px;
        border-left: 1px solid #ddd;
    }

    .live-mode-toggle {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
    }

    .live-mode-toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.3s;
        border-radius: 24px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
    }

    .live-mode-toggle input:checked + .toggle-slider {
        background-color: #4CAF50;
    }

    .live-mode-toggle input:checked + .toggle-slider:before {
        transform: translateX(20px);
    }

    .live-mode-label {
        font-size: 0.85em;
        font-weight: 600;
        color: #666;
        text-transform: uppercase;
    }

    .poll-interval-container {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        margin-left: 8px;
    }

    .poll-interval-container input {
        width: 50px;
        padding: 4px 6px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.85em;
        text-align: center;
    }

    .poll-interval-unit {
        font-size: 0.8em;
        color: #666;
    }

    .daily-pnl {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        margin-left: 15px;
        padding-left: 15px;
        border-left: 1px solid #ddd;
    }

    .daily-pnl-label {
        font-size: 0.85em;
        font-weight: 500;
        color: #666;
    }

    .daily-pnl-value {
        font-size: 0.95em;
        font-weight: 700;
    }

    .daily-pnl-value.positive {
        color: #2e7d32;
    }

    .daily-pnl-value.negative {
        color: #c62828;
    }

    .game-time {
        text-align: center;
        color: #333;
        font-size: 1em;
        font-weight: 600;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid #e0e0e0;
    }

    .game-time a {
        color: inherit;
        text-decoration: none;
    }

    .game-time a:hover {
        text-decoration: underline;
    }
    
    .game-date {
        text-align: center;
        color: #666;
        font-size: 0.9em;
        margin-top: 10px;
    }
    
    .no-games {
        text-align: center;
        padding: 60px 20px;
        color: #666;
        font-size: 1.2em;
    }
    
    .gear-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        color: #667eea;
        text-decoration: none;
        border-radius: 50%;
        transition: all 0.2s;
        background: rgba(102, 126, 234, 0.1);
    }
    
    .gear-icon:hover {
        background: rgba(102, 126, 234, 0.2);
        transform: rotate(90deg);
    }
    
    .run-predictions-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 10px;
        transition: background 0.2s;
    }
    
    .run-predictions-btn:hover {
        background: #5568d3;
    }
    
    .run-predictions-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .generate-report-btn {
        background: #ff9800;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }

    .generate-report-btn:hover {
        background: #f57c00;
    }

    .generate-report-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .refresh-report-btn {
        background: #2196F3;
        color: white;
        border: none;
        padding: 6px;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
    }

    .refresh-report-btn:hover {
        background: #1976D2;
    }

    .refresh-report-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .refresh-report-btn.refreshing svg {
        animation: spin 1s linear infinite;
    }

    /* Betting report table */
    .betting-report-table {
        width: 100%;
        border-collapse: collapse;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        font-size: 15px;
    }
    .betting-report-table th {
        text-align: left;
        padding: 6px 8px;
        border-bottom: 2px solid #dee2e6;
        font-weight: 600;
        color: #495057;
        white-space: nowrap;
    }
    .betting-report-table td {
        padding: 5px 8px;
        border-bottom: 1px solid #f0f0f0;
        white-space: nowrap;
        transition: background-color 0.3s;
    }
    .betting-report-table tr:last-child td {
        border-bottom: none;
    }
    .betting-report-table .num {
        text-align: right;
    }
    .betting-report-header-inputs {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 6px;
    }
    .betting-report-header-inputs label {
        font-size: 12px;
        color: #888;
        font-weight: 500;
    }
    .betting-report-header-inputs input {
        width: 60px;
        padding: 4px 6px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
        background: #f8f9fa;
    }
    .betting-report-meta {
        font-size: 12px;
        color: #888;
        margin-top: 4px;
    }
    @keyframes blink-green {
        0%   { background-color: rgba(76, 175, 80, 0.45); }
        100% { background-color: transparent; }
    }
    @keyframes blink-red {
        0%   { background-color: rgba(244, 67, 54, 0.45); }
        100% { background-color: transparent; }
    }
    .blink-up {
        animation: blink-green 1.2s ease-out;
    }
    .blink-down {
        animation: blink-red 1.2s ease-out;
    }

    /* Resizable betting report modal */
    .features-modal-content.betting-report-modal-content {
        max-width: 95vw;
        width: 95%;
        max-height: 90vh;
        min-width: 500px;
        min-height: 250px;
        resize: both;
        overflow: auto;
    }

    .pull-data-btn {
        background: #28a745;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 10px;
        transition: background 0.2s;
        display: inline-flex;
        align-items: center;
    }
    
    .pull-data-btn:hover {
        background: #218838;
    }
    
    .pull-data-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }
    
    .pull-status {
        display: inline-block;
        margin-left: 10px;
        font-size: 14px;
        color: #666;
        font-weight: 600;
    }

    .job-progress-container {
        display: inline-flex;
        align-items: center;
        margin-left: 15px;
        gap: 10px;
    }

    .job-progress-bar {
        width: 200px;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
    }

    .job-progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    .job-progress-text {
        font-size: 12px;
        color: #666;
        min-width: 150px;
    }

    .refresh-portfolio-btn {
        background: #2196F3;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 10px;
        transition: background 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }

    .refresh-portfolio-btn:hover {
        background: #1976D2;
    }

    .refresh-portfolio-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .refresh-portfolio-btn.refreshing svg {
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* Live Controls Row */
    .live-controls-row {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-top: 15px;
        padding: 10px 0;
        border-top: 1px solid #e0e0e0;
        flex-wrap: wrap;
    }

    .live-controls-row .live-mode-container {
        margin-left: 0;
        padding-left: 0;
        border-left: none;
    }

    .game-time-status {
        position: absolute;
        bottom: 8px;
        right: 8px;
        font-size: 0.75em;
        font-weight: 600;
        color: #666;
        background: rgba(255, 255, 255, 0.9);
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #ddd;
        text-align: right;
        z-index: 1;
    }
</style>

<script>
    // ========== Global Variables for Live Mode ==========
    let liveModeEnabled = false;
    let pollIntervalSeconds = 30;
    let portfolioPollInterval = null;
    const pageGameDate = document.getElementById('game-date')?.value || '{{ game_date }}';
    window.marketDataCache = {};  // Cache for market data used by portfolio display

    // Kalshi team abbreviation mappings from league config (for matching fills to market data)
    window.KALSHI_ABBREV_MAP = {{ kalshi_abbrev_map | tojson | safe }};  // Kalshi -> Internal (e.g., GSW -> GS)
    window.KALSHI_REVERSE_MAP = {{ kalshi_reverse_map | tojson | safe }};  // Internal -> Kalshi (e.g., GS -> GSW)

    // ESPN league slug for building game URLs
    window.ESPN_LEAGUE_SLUG = "{{ g.league.espn.league_slug }}";

    // Helper function to build API URLs with league prefix
    function apiUrl(path) {
        // If we're on a league-prefixed route, add the prefix to API calls
        const pathMatch = window.location.pathname.match(/^\/([a-z]+)\//);
        if (pathMatch && pathMatch[1] !== 'api') {
            return '/' + pathMatch[1] + path;
        }
        return path;
    }

    // ========== Portfolio Functions ==========
    async function fetchPortfolioPositions() {
        if (!pageGameDate) return;

        try {
            const response = await fetch(apiUrl(`/api/portfolio/game-positions?date=${pageGameDate}`));
            const data = await response.json();

            if (data.success && data.available && data.positions) {
                updatePortfolioOnCards(data.positions);
            }
        } catch (error) {
            console.error('Error fetching portfolio positions:', error);
        }
    }

    function updatePortfolioOnCards(positions) {
        // Track total P&L across all fills
        let totalPnL = 0;
        let hasFills = false;

        // Track parlay tickers we've already counted to avoid double-counting
        const countedParlayTickers = new Set();

        for (const [gameId, gameData] of Object.entries(positions)) {
            const container = document.getElementById(`portfolio-${gameId}`);
            if (!container) continue;

            const items = [];

            // Format dollar amount
            const formatDollars = (amount) => {
                return '$' + Math.abs(amount).toFixed(2);
            };

            // Add positions (current holdings)
            for (const pos of (gameData.positions || [])) {
                if (pos.count > 0) {
                    const cost = pos.cost || (pos.count * pos.avg_price);
                    const status = pos.status || 'live';
                    const displayLabel = pos.market_label || pos.team;
                    let label, title;

                    if (status === 'won' || status === 'lost') {
                        const pnl = pos.pnl || 0;
                        const resultWord = status === 'won' ? 'Won' : 'Lost';
                        label = `${resultWord} ${formatDollars(Math.abs(pnl))} ${displayLabel}`;
                        title = `${resultWord}: ${pos.count} contracts | Cost: ${formatDollars(cost)} | P&L: ${pnl >= 0 ? '+' : '-'}${formatDollars(Math.abs(pnl))}`;
                    } else {
                        const action = pos.action === 'sell' ? 'Sell' : 'Buy';
                        const potentialPayout = pos.count * 1.00;
                        const netProfit = potentialPayout - cost;
                        label = `${action} ${displayLabel} ${formatDollars(cost)} → ${formatDollars(netProfit)}`;
                        title = `Position: ${pos.count} contracts @ ${(pos.avg_price * 100).toFixed(1)}c | Cost: ${formatDollars(cost)} | Profit if wins: ${formatDollars(netProfit)}`;
                    }
                    items.push(`<div class="portfolio-item ${status}" title="${title}">${label}</div>`);
                }
            }

            // Add open orders (pending)
            for (const order of (gameData.orders || [])) {
                if (order.count > 0) {
                    const action = order.action === 'sell' ? 'Sell' : 'Buy';
                    const cost = order.cost || (order.count * order.price);
                    const potentialPayout = order.count * 1.00;
                    const netProfit = potentialPayout - cost;
                    const displayLabel = order.market_label || order.team;
                    const label = `${action} ${displayLabel} ${formatDollars(cost)} → ${formatDollars(netProfit)}`;
                    const title = `Pending: ${order.action} ${order.count} @ ${(order.price * 100).toFixed(1)}c | Cost: ${formatDollars(cost)} | Profit if wins: ${formatDollars(netProfit)}`;
                    items.push(`<div class="portfolio-item pending" title="${title}">${label}</div>`);
                }
            }

            // Build ticker -> position lookup for live pricing
            const positionsByTicker = {};
            for (const pos of (gameData.positions || [])) {
                if (pos.ticker) positionsByTicker[pos.ticker] = pos;
            }

            // Aggregate fills by ticker (keeps ML and spread separate)
            // Properly handle buys vs sells to calculate realized P&L
            const fillsByTicker = {};
            for (const fill of (gameData.fills || [])) {
                const key = fill.ticker || fill.team;
                if (!fillsByTicker[key]) {
                    fillsByTicker[key] = {
                        ticker: fill.ticker,
                        team: fill.team,
                        side: fill.side,
                        market_label: fill.market_label || fill.team,
                        action: fill.action,
                        status: fill.status || 'live',
                        is_spread: fill.is_spread || false,
                        // Track buys and sells separately for P&L
                        buyCount: 0,
                        buyCost: 0,
                        sellCount: 0,
                        sellProceeds: 0,
                        // Legacy fields for compatibility
                        totalCount: 0,
                        totalCost: 0
                    };
                }

                const cost = fill.cost || (fill.count * fill.price);

                if (fill.action === 'buy') {
                    // Buying: adds to position, cost is what we spent
                    fillsByTicker[key].buyCount += fill.count;
                    fillsByTicker[key].buyCost += cost;
                    // Track the buy side (this is our actual betting direction)
                    fillsByTicker[key].buySide = fill.side;
                } else if (fill.action === 'sell') {
                    // Selling: closes position
                    // For "sell no", proceeds = count × (1 - no_price) since we exit at YES price
                    // For "sell yes", proceeds = count × yes_price
                    let proceeds;
                    if (fill.side === 'no') {
                        // Selling NO at $0.02 means exiting YES at $0.98
                        proceeds = fill.count * (1 - fill.price);
                    } else {
                        proceeds = fill.count * fill.price;
                    }
                    fillsByTicker[key].sellCount += fill.count;
                    fillsByTicker[key].sellProceeds += proceeds;
                }

                // Calculate net position (for display purposes)
                fillsByTicker[key].totalCount = fillsByTicker[key].buyCount - fillsByTicker[key].sellCount;
                // Total cost basis is what we spent on buys minus what we received from sells
                fillsByTicker[key].totalCost = fillsByTicker[key].buyCost;
            }

            // Display aggregated fills
            for (const fill of Object.values(fillsByTicker)) {
                // Skip if no activity at all
                if (fill.buyCount === 0 && fill.sellCount === 0) continue;
                hasFills = true;
                const status = fill.status;
                const displayLabel = fill.market_label;
                let label, title;

                // Check if position is fully closed (sold everything we bought)
                const isFullyClosed = fill.sellCount > 0 && fill.totalCount === 0;
                const isPartiallyClosed = fill.sellCount > 0 && fill.totalCount > 0;

                // Calculate realized P&L from closed portion
                // Use FIFO: sells close out the oldest buys first
                const closedCount = Math.min(fill.buyCount, fill.sellCount);
                const avgBuyPrice = fill.buyCount > 0 ? fill.buyCost / fill.buyCount : 0;
                const closedCostBasis = closedCount * avgBuyPrice;
                // Proceeds from sells (already calculated correctly for yes/no)
                const realizedPnL = fill.sellProceeds - closedCostBasis;

                if (isFullyClosed) {
                    // Position fully closed - show realized P&L
                    // This takes precedence regardless of game status
                    totalPnL += realizedPnL;
                    const resultWord = realizedPnL >= 0 ? 'Won' : 'Lost';
                    const pnlSign = realizedPnL >= 0 ? '+' : '';

                    // For closed positions, show the team we were betting ON
                    // Use buySide to determine if we need to show opposite team
                    let closedLabel = displayLabel;
                    const buySide = fill.buySide || 'yes';
                    if (buySide === 'no') {
                        // We bought NO, meaning we bet AGAINST the labeled team
                        // Show the opposite team
                        const market = window.marketDataCache?.[gameId];
                        if (market && fill.team) {
                            const fillTeam = fill.team.toUpperCase();
                            const homeTeam = market.home_team?.toUpperCase();
                            const awayTeam = market.away_team?.toUpperCase();
                            const kalshiToInternal = window.KALSHI_ABBREV_MAP || {};
                            const internalToKalshi = window.KALSHI_REVERSE_MAP || {};
                            const fillTeamAsInternal = kalshiToInternal[fillTeam] || fillTeam;
                            const homeAsKalshi = internalToKalshi[homeTeam] || homeTeam;
                            const awayAsKalshi = internalToKalshi[awayTeam] || awayTeam;

                            if (homeTeam === fillTeam || homeTeam === fillTeamAsInternal || homeAsKalshi === fillTeam) {
                                closedLabel = awayTeam;
                            } else if (awayTeam === fillTeam || awayTeam === fillTeamAsInternal || awayAsKalshi === fillTeam) {
                                closedLabel = homeTeam;
                            }
                        }
                    }

                    label = `${resultWord} ${pnlSign}${formatDollars(Math.abs(realizedPnL))} ${closedLabel}`;
                    title = `Closed position | Bought: ${fill.buyCount} @ avg ${formatDollars(avgBuyPrice)} | Sold: ${fill.sellCount} | Realized P&L: ${pnlSign}${formatDollars(Math.abs(realizedPnL))}`;
                    const itemClass = realizedPnL >= 0 ? 'won' : 'lost';
                    items.push(`<div class="portfolio-item ${itemClass}" title="${title}">${label}</div>`);
                    continue;
                }

                if (status === 'won' || status === 'lost') {
                    // Game finished - calculate final P&L including any open position
                    const remainingCount = fill.totalCount;
                    const remainingCostBasis = fill.buyCost - closedCostBasis;
                    const payout = status === 'won' ? remainingCount * 1.00 : 0;
                    const openPnL = payout - remainingCostBasis;
                    const pnl = realizedPnL + openPnL;
                    totalPnL += pnl;
                    const resultWord = status === 'won' ? 'Won' : 'Lost';
                    
                    // Transform display label based on side for "no" bets
                    let transformedLabel = displayLabel;
                    if (fill.side === 'no') {
                        const market = window.marketDataCache?.[gameId];
                        if (market && fill.team) {
                            const fillTeam = fill.team.toUpperCase();
                            const homeTeam = market.home_team?.toUpperCase();
                            const awayTeam = market.away_team?.toUpperCase();
                            // Use YAML config abbreviation mappings
                            const kalshiToInternal = window.KALSHI_ABBREV_MAP || {};
                            const internalToKalshi = window.KALSHI_REVERSE_MAP || {};

                            // fillTeam could be Kalshi abbrev (from ticker) - convert to internal for comparison
                            const fillTeamAsInternal = kalshiToInternal[fillTeam] || fillTeam;
                            // Or market teams could need Kalshi conversion
                            const homeAsKalshi = internalToKalshi[homeTeam] || homeTeam;
                            const awayAsKalshi = internalToKalshi[awayTeam] || awayTeam;

                            let oppositeTeam;
                            if (homeTeam === fillTeam || homeTeam === fillTeamAsInternal || homeAsKalshi === fillTeam) {
                                oppositeTeam = awayTeam;
                            } else if (awayTeam === fillTeam || awayTeam === fillTeamAsInternal || awayAsKalshi === fillTeam) {
                                oppositeTeam = homeTeam;
                            }

                            if (oppositeTeam) {
                                // For spread markets, transform "Team -X.5" to "OtherTeam +X.5"
                                if (displayLabel && displayLabel.includes(' -')) {
                                    const parts = displayLabel.split(' -');
                                    if (parts.length === 2) {
                                        const spread = parts[1].trim();
                                        transformedLabel = `${oppositeTeam} +${spread}`;
                                    }
                                } else {
                                    // For moneyline, just use opposite team
                                    transformedLabel = oppositeTeam;
                                }
                            }
                        }
                    }

                    label = `${resultWord} ${formatDollars(Math.abs(pnl))} ${transformedLabel}`;
                    title = `${resultWord}: ${fill.totalCount} contracts | Cost: ${formatDollars(fill.totalCost)} | P&L: ${pnl >= 0 ? '+' : '-'}${formatDollars(Math.abs(pnl))}`;
                    items.push(`<div class="portfolio-item ${status}" title="${title}">${label}</div>`);
                } else {
                    // Live fill with open position - calculate P&L using live value vs remaining cost
                    // First, add any realized P&L from partial closes
                    if (isPartiallyClosed) {
                        totalPnL += realizedPnL;
                    }

                    const action = fill.action === 'sell' ? 'Sell' : 'Buy';
                    const remainingCostBasis = fill.buyCost - closedCostBasis;
                    const avgFillPrice = fill.totalCount > 0 ? remainingCostBasis / fill.totalCount : 0;

                    // Transform display label based on side for "no" bets
                    let transformedLabel = displayLabel;
                    if (fill.side === 'no') {
                        const market = window.marketDataCache?.[gameId];
                        if (market && fill.team) {
                            const fillTeam = fill.team.toUpperCase();
                            const homeTeam = market.home_team?.toUpperCase();
                            const awayTeam = market.away_team?.toUpperCase();
                            // Use YAML config abbreviation mappings
                            const kalshiToInternal = window.KALSHI_ABBREV_MAP || {};
                            const internalToKalshi = window.KALSHI_REVERSE_MAP || {};

                            // fillTeam could be Kalshi abbrev (from ticker) - convert to internal for comparison
                            const fillTeamAsInternal = kalshiToInternal[fillTeam] || fillTeam;
                            // Or market teams could need Kalshi conversion
                            const homeAsKalshi = internalToKalshi[homeTeam] || homeTeam;
                            const awayAsKalshi = internalToKalshi[awayTeam] || awayTeam;

                            let oppositeTeam;
                            if (homeTeam === fillTeam || homeTeam === fillTeamAsInternal || homeAsKalshi === fillTeam) {
                                oppositeTeam = awayTeam;
                            } else if (awayTeam === fillTeam || awayTeam === fillTeamAsInternal || awayAsKalshi === fillTeam) {
                                oppositeTeam = homeTeam;
                            }

                            if (oppositeTeam) {
                                // For spread markets, transform "Team -X.5" to "OtherTeam +X.5"
                                if (displayLabel && displayLabel.includes(' -')) {
                                    const parts = displayLabel.split(' -');
                                    if (parts.length === 2) {
                                        const spread = parts[1].trim();
                                        transformedLabel = `${oppositeTeam} +${spread}`;
                                    }
                                } else {
                                    // For moneyline, just use opposite team
                                    transformedLabel = oppositeTeam;
                                }
                            }
                        }
                    }

                    // Get current live price per contract
                    let livePrice = null;
                    let itemClass = 'live';  // default blue

                    // For spread fills, use position data (has real spread market value from Kalshi API)
                    const matchingPos = fill.ticker ? positionsByTicker[fill.ticker] : null;
                    if (fill.is_spread && matchingPos && matchingPos.current_value != null && matchingPos.count > 0) {
                        livePrice = matchingPos.current_value / matchingPos.count;
                    } else {
                        // For moneyline fills, use marketDataCache prices
                        const market = window.marketDataCache?.[gameId];
                        if (market && fill.team) {
                            const fillTeam = fill.team.toUpperCase();
                            const homeTeam = market.home_team?.toUpperCase();
                            const awayTeam = market.away_team?.toUpperCase();
                            const kalshiToInternal = window.KALSHI_ABBREV_MAP || {};
                            const internalToKalshi = window.KALSHI_REVERSE_MAP || {};

                            const fillTeamAsInternal = kalshiToInternal[fillTeam] || fillTeam;
                            const homeAsKalshi = internalToKalshi[homeTeam] || homeTeam;
                            const awayAsKalshi = internalToKalshi[awayTeam] || awayTeam;

                            let yesPrice;
                            if (homeTeam === fillTeam || homeTeam === fillTeamAsInternal || homeAsKalshi === fillTeam) {
                                yesPrice = market.home_yes_price;
                            } else if (awayTeam === fillTeam || awayTeam === fillTeamAsInternal || awayAsKalshi === fillTeam) {
                                yesPrice = market.away_yes_price;
                            }

                            if (yesPrice != null) {
                                if (fill.side === 'no') {
                                    livePrice = 1 - yesPrice;
                                } else {
                                    livePrice = yesPrice;
                                }
                            }
                        }
                    }

                    const potentialPayout = fill.totalCount * 1.00;
                    const netProfit = potentialPayout - remainingCostBasis;

                    // Calculate live value and determine item color class
                    let liveValueLine = '';
                    let livePnL = 0;
                    if (livePrice !== null) {
                        const liveValue = fill.totalCount * livePrice;
                        livePnL = liveValue - remainingCostBasis;  // Live P&L = current value - remaining cost

                        // Add live P&L to total Day P&L (realized P&L already added above for partial closes)
                        totalPnL += livePnL;

                        if (livePrice > avgFillPrice) {
                            itemClass = 'live-profit';
                        } else if (livePrice < avgFillPrice) {
                            itemClass = 'live-loss';
                        }
                        // else stays 'live' (blue) for same price
                        liveValueLine = `<div class="fill-live-value">Live: ${formatDollars(liveValue)} (${livePnL >= 0 ? '+' : '-'}${formatDollars(Math.abs(livePnL))})</div>`;
                    }

                    // Show realized P&L in display if there were partial closes
                    let realizedNote = '';
                    if (isPartiallyClosed) {
                        realizedNote = ` [+${formatDollars(realizedPnL)} realized]`;
                    }

                    const mainLine = `${action} ${transformedLabel} ${formatDollars(remainingCostBasis)} → ${formatDollars(netProfit)}${realizedNote}`;
                    label = `<div class="fill-main-line">${mainLine}</div>${liveValueLine}`;
                    title = `Open: ${fill.totalCount} contracts @ ${(avgFillPrice * 100).toFixed(1)}¢ | Cost: ${formatDollars(remainingCostBasis)} | Profit if wins: ${formatDollars(netProfit)}`;
                    if (isPartiallyClosed) {
                        title += ` | Realized P&L: +${formatDollars(realizedPnL)}`;
                    }
                    if (livePrice !== null) {
                        const liveValue = fill.totalCount * livePrice;
                        title += ` | Live Value: ${formatDollars(liveValue)} | Live P&L: ${livePnL >= 0 ? '+' : '-'}${formatDollars(Math.abs(livePnL))}`;
                    }
                    items.push(`<div class="portfolio-item ${itemClass}" title="${title}">${label}</div>`);
                }
            }

            container.innerHTML = items.join('');

            // Process parlay/combo fills (displayed below the "@")
            const parlayContainer = document.getElementById(`parlay-${gameId}`);
            if (parlayContainer) {
                const parlayItems = [];

                for (const parlay of (gameData.parlay_fills || [])) {
                    const status = parlay.status || 'live';
                    const numLegs = parlay.num_legs || 2;
                    const isCombo = parlay.is_combo || false;
                    const thisGameTeam = parlay.this_game_team || '';
                    const thisGameSide = parlay.this_game_side || parlay.side || 'yes';
                    let label, title;

                    // Only count P&L once per ticker (across all games)
                    const shouldCountPnL = !countedParlayTickers.has(parlay.ticker);
                    if (shouldCountPnL) {
                        countedParlayTickers.add(parlay.ticker);
                    }

                    if (status === 'won' || status === 'lost') {
                        const pnl = parlay.total_pnl || 0;
                        if (shouldCountPnL) {
                            totalPnL += pnl;
                        }
                        const resultWord = status === 'won' ? 'Won' : 'Lost';

                        if (isCombo && thisGameTeam) {
                            // Show which team for this game in the combo
                            label = `${resultWord} ${formatDollars(Math.abs(pnl))} ${thisGameTeam} (${numLegs}-leg)`;
                            title = `${numLegs}-leg combo ${resultWord} | This leg: ${thisGameTeam} ${thisGameSide} | Total P&L: ${pnl >= 0 ? '+' : '-'}${formatDollars(Math.abs(pnl))}`;
                        } else {
                            label = `${resultWord} ${formatDollars(Math.abs(pnl))} ${numLegs}-leg`;
                            title = `${numLegs}-leg parlay ${resultWord} | Total P&L: ${pnl >= 0 ? '+' : '-'}${formatDollars(Math.abs(pnl))}`;
                        }
                    } else {
                        const totalCost = parlay.total_cost || 0;

                        if (isCombo && thisGameTeam) {
                            // Show which team for this game in the combo
                            const potentialPayout = parlay.count * 1.00;
                            const netProfit = potentialPayout - totalCost;
                            label = `${thisGameTeam} (${numLegs}-leg) ${formatDollars(totalCost)} → ${formatDollars(netProfit)}`;
                            title = `${numLegs}-leg combo | This leg: ${thisGameTeam} ${thisGameSide} | Cost: ${formatDollars(totalCost)} | Profit if all win: ${formatDollars(netProfit)}`;
                        } else {
                            label = `${numLegs}-leg parlay ${formatDollars(totalCost)}`;
                            title = `${numLegs}-leg parlay | Cost: ${formatDollars(totalCost)}`;
                        }
                    }

                    const comboClass = isCombo ? 'combo' : '';
                    parlayItems.push(`<div class="portfolio-item parlay ${comboClass} ${status}" title="${title}">${label}</div>`);
                }

                parlayContainer.innerHTML = parlayItems.join('');
            }
        }

        // Update daily P&L display
        const pnlDisplay = document.getElementById('daily-pnl');
        const pnlValue = document.getElementById('daily-pnl-value');
        if (pnlDisplay && pnlValue && hasFills) {
            pnlDisplay.style.display = 'inline-flex';
            pnlValue.textContent = `${totalPnL >= 0 ? '+' : '-'}$${Math.abs(totalPnL).toFixed(2)}`;
            pnlValue.className = `daily-pnl-value ${totalPnL >= 0 ? 'positive' : 'negative'}`;
        }
    }

    // ========== Market Prices Functions ==========

    // Convert probability (0-1) to American odds string
    function probToAmericanOdds(prob) {
        if (prob >= 1) return '-∞';
        if (prob <= 0) return '+∞';
        if (prob === 0.5) return '-100';

        if (prob > 0.5) {
            const odds = Math.round(-100 * prob / (1 - prob));
            return odds.toString();
        } else {
            const odds = Math.round(100 * (1 - prob) / prob);
            return '+' + odds;
        }
    }

    // Format Kalshi price as "XX% (odds)"
    function formatKalshiPrice(prob) {
        const pct = Math.round(prob * 100);
        const odds = probToAmericanOdds(prob);
        return `${pct}% (${odds})`;
    }

    async function fetchMarketPrices() {
        if (!pageGameDate) return;

        try {
            const response = await fetch(apiUrl(`/api/market-prices?date=${pageGameDate}`));
            const data = await response.json();

            if (data.success && data.markets) {
                window.marketDataCache = data.markets;
                updateMarketPricesOnCards(data.markets);
            }
        } catch (error) {
            console.error('Error fetching market prices:', error);
        }
    }

    function updateMarketPricesOnCards(markets) {
        for (const [gameId, market] of Object.entries(markets)) {
            const gameCard = document.querySelector(`[data-game-id="${gameId}"]`);
            if (!gameCard) continue;

            const awayPanel = gameCard.querySelector('.team-panel.away');
            const homePanel = gameCard.querySelector('.team-panel.home');
            if (!awayPanel || !homePanel) continue;

            // Use Kalshi market status to determine if market is still active
            // status: "active" = show ticker, "closed"/"settled"/"finalized" = show Final
            const marketStatus = market.status || 'active';
            const isMarketClosed = marketStatus === 'closed' || marketStatus === 'settled' || marketStatus === 'finalized';

            // Remove any existing market/final elements first
            const existingAwayEl = awayPanel.querySelector('.kalshi-price, .final-badge');
            const existingHomeEl = homePanel.querySelector('.kalshi-price, .final-badge');
            if (existingAwayEl) existingAwayEl.remove();
            if (existingHomeEl) existingHomeEl.remove();

            const vsContainer = gameCard.querySelector('.vs-container');
            const existingFinalBadge = vsContainer?.querySelector('.final-badge');
            if (existingFinalBadge) existingFinalBadge.remove();

            if (isMarketClosed) {
                // Market is closed/settled - show Final badge in the center
                if (vsContainer) {
                    const finalBadge = document.createElement('div');
                    finalBadge.className = 'final-badge';
                    finalBadge.textContent = 'Final';
                    vsContainer.appendChild(finalBadge);
                }
            } else {
                // Market still active - show Kalshi prices
                const awayProb = market.away_yes_price;
                const homeProb = market.home_yes_price;

                const awayClass = awayProb < 0.5 ? 'underdog' : 'favorite';
                const homeClass = homeProb < 0.5 ? 'underdog' : 'favorite';

                const awayMarketEl = document.createElement('div');
                awayMarketEl.className = `kalshi-price live-glow ${awayClass}`;
                awayMarketEl.textContent = formatKalshiPrice(awayProb);
                const awaySpreadEl = awayPanel.querySelector('.spread, .team-score');
                if (awaySpreadEl) {
                    awaySpreadEl.after(awayMarketEl);
                } else {
                    awayPanel.appendChild(awayMarketEl);
                }

                const homeMarketEl = document.createElement('div');
                homeMarketEl.className = `kalshi-price live-glow ${homeClass}`;
                homeMarketEl.textContent = formatKalshiPrice(homeProb);
                const homeSpreadEl = homePanel.querySelector('.spread, .team-score');
                if (homeSpreadEl) {
                    homeSpreadEl.after(homeMarketEl);
                } else {
                    homePanel.appendChild(homeMarketEl);
                }
            }
        }

        // Also update the modal if it's open
        if (currentGameData && currentGameData.game_id && markets[currentGameData.game_id]) {
            const modalMarket = markets[currentGameData.game_id];
            const awayKalshiEl = document.getElementById('gd-away-kalshi');
            const homeKalshiEl = document.getElementById('gd-home-kalshi');

            // Use Kalshi market status
            const marketStatus = modalMarket.status || 'active';
            const isMarketClosed = marketStatus === 'closed' || marketStatus === 'settled' || marketStatus === 'finalized';

            if (awayKalshiEl && homeKalshiEl) {
                if (isMarketClosed) {
                    // Market closed - show Final badge
                    awayKalshiEl.className = 'gd-final-badge';
                    awayKalshiEl.textContent = 'Final';
                    awayKalshiEl.style.display = '';
                    homeKalshiEl.style.display = 'none';
                } else {
                    // Market active - show prices
                    const awayProb = modalMarket.away_yes_price;
                    const homeProb = modalMarket.home_yes_price;

                    const awayClass = awayProb < 0.5 ? 'underdog' : 'favorite';
                    const homeClass = homeProb < 0.5 ? 'underdog' : 'favorite';

                    awayKalshiEl.className = `gd-kalshi-price live-glow ${awayClass}`;
                    awayKalshiEl.textContent = formatKalshiPrice(awayProb);
                    awayKalshiEl.style.display = '';

                    homeKalshiEl.className = `gd-kalshi-price live-glow ${homeClass}`;
                    homeKalshiEl.textContent = formatKalshiPrice(homeProb);
                    homeKalshiEl.style.display = '';
                }
            }
        }
    }

    // ========== Live Games Functions ==========
    async function fetchLiveGames() {
        if (!pageGameDate) return;

        try {
            const response = await fetch(apiUrl(`/api/live-games?date=${pageGameDate}`));
            const data = await response.json();

            if (data.success && data.games) {
                window.liveGamesCache = data.games;
                updateLiveGamesOnCards(data.games);
            }
        } catch (error) {
            console.error('Error fetching live games:', error);
        }
    }

    function updateLiveGamesOnCards(liveGames) {
        for (const [gameId, gameData] of Object.entries(liveGames)) {
            const gameCard = document.querySelector(`[data-game-id="${gameId}"]`);
            if (!gameCard) continue;

            // Update game status on the card data attribute
            gameCard.dataset.gameStatus = gameData.status;
            gameCard.dataset.gameCompleted = gameData.completed ? 'true' : 'false';

            const awayPanel = gameCard.querySelector('.team-panel.away');
            const homePanel = gameCard.querySelector('.team-panel.home');
            if (!awayPanel || !homePanel) continue;

            // Update scores if game is in progress or completed
            if (gameData.status === 'in' || gameData.status === 'post') {
                // Update or create score elements
                let awayScoreEl = awayPanel.querySelector('.team-score');
                let homeScoreEl = homePanel.querySelector('.team-score');

                if (gameData.away_score !== null) {
                    if (!awayScoreEl) {
                        awayScoreEl = document.createElement('div');
                        awayScoreEl.className = 'team-score';
                        const spreadEl = awayPanel.querySelector('.spread');
                        if (spreadEl) {
                            spreadEl.replaceWith(awayScoreEl);
                        } else {
                            awayPanel.appendChild(awayScoreEl);
                        }
                    }
                    awayScoreEl.textContent = gameData.away_score;
                }

                if (gameData.home_score !== null) {
                    if (!homeScoreEl) {
                        homeScoreEl = document.createElement('div');
                        homeScoreEl.className = 'team-score';
                        const spreadEl = homePanel.querySelector('.spread');
                        if (spreadEl) {
                            spreadEl.replaceWith(homeScoreEl);
                        } else {
                            homePanel.appendChild(homeScoreEl);
                        }
                    }
                    homeScoreEl.textContent = gameData.home_score;
                }
            }

            // Update quarter/clock display for live games - move to bottom right of game card
            let liveStatusEl = gameCard.querySelector('.game-time-status');
            
            if (gameData.status !== 'STATUS_FINAL' && (gameData.period || gameData.clock || gameData.status_detail)) {
                if (!liveStatusEl) {
                    liveStatusEl = document.createElement('div');
                    liveStatusEl.className = 'game-time-status';
                    const gameDateEl = gameCard.querySelector('.game-date');
                    if (gameDateEl) {
                        gameDateEl.after(liveStatusEl);
                    } else {
                        gameCard.appendChild(liveStatusEl);
                    }
                }
                
                // Determine what to display based on status
                let statusText = '';
                
                // Check for special statuses first
                if (gameData.status_detail) {
                    statusText = gameData.status_detail;
                } else if (gameData.period && gameData.clock) {
                    const periodLabel = gameData.period <= 4 ? `Q${gameData.period}` : `OT${gameData.period - 4}`;
                    statusText = `${periodLabel} ${gameData.clock}`;
                } else if (gameData.period) {
                    const periodLabel = gameData.period <= 4 ? `Q${gameData.period}` : `OT${gameData.period - 4}`;
                    statusText = periodLabel;
                } else if (gameData.clock) {
                    statusText = gameData.clock;
                } else if (gameData.status === 'pre') {
                    statusText = 'Pre-game';
                } else if (gameData.status === 'in') {
                    statusText = 'Live';
                } else if (gameData.status === 'post') {
                    statusText = 'Final';
                }
                
                liveStatusEl.textContent = statusText;
                liveStatusEl.style.display = '';
            } else if (liveStatusEl) {
                liveStatusEl.style.display = 'none';
            }
        }

        // Also update modal if open
        if (currentGameData && currentGameData.game_id && liveGames[currentGameData.game_id]) {
            const liveData = liveGames[currentGameData.game_id];
            currentGameData.status = liveData.status;
            currentGameData.completed = liveData.completed;
            currentGameData.period = liveData.period;
            currentGameData.clock = liveData.clock;

            if (liveData.home_score !== null) currentGameData.home_score = liveData.home_score;
            if (liveData.away_score !== null) currentGameData.away_score = liveData.away_score;

            // Update modal display (only show scores for live/completed games)
            if (liveData.status === 'in' || liveData.status === 'post') {
                const awaySpreadScoreEl = document.getElementById('gd-away-spread-score');
                const homeSpreadScoreEl = document.getElementById('gd-home-spread-score');
                if (awaySpreadScoreEl && liveData.away_score !== null) {
                    awaySpreadScoreEl.textContent = liveData.away_score;
                }
                if (homeSpreadScoreEl && liveData.home_score !== null) {
                    homeSpreadScoreEl.textContent = liveData.home_score;
                }
            }
        }
    }

    // ========== Combined Live Mode Polling ==========
    async function liveModePolling() {
        // Fetch live games, market prices, and portfolio in parallel
        await Promise.all([
            fetchLiveGames(),
            fetchMarketPrices(),
            fetchPortfolioPositions()
        ]);
    }

    function startLiveModePolling() {
        // Fetch immediately
        liveModePolling();

        // Then poll at configured interval
        portfolioPollInterval = setInterval(() => {
            liveModePolling();
        }, pollIntervalSeconds * 1000);
    }

    function stopLiveModePolling() {
        if (portfolioPollInterval) {
            clearInterval(portfolioPollInterval);
            portfolioPollInterval = null;
        }
    }

    // Legacy function names for backwards compatibility
    function startPortfolioPolling() { startLiveModePolling(); }
    function stopPortfolioPolling() { stopLiveModePolling(); }

    // ========== Live Mode Control ==========
    async function toggleLiveMode(enabled) {
        liveModeEnabled = enabled;

        // Update URL param
        const url = new URL(window.location);
        if (enabled) {
            url.searchParams.set('live', '1');
        } else {
            url.searchParams.delete('live');
        }
        window.history.replaceState({}, '', url);

        // Update UI
        updateLiveModeUI();

        if (enabled) {
            startPortfolioPolling();
        } else {
            stopPortfolioPolling();
        }
    }

    function updatePollInterval(value) {
        const newInterval = value ? Math.max(5, Math.min(300, parseInt(value))) : 30;
        pollIntervalSeconds = newInterval;

        // Update URL param
        const url = new URL(window.location);
        if (value && newInterval !== 30) {
            url.searchParams.set('interval', newInterval);
        } else {
            url.searchParams.delete('interval');
        }
        window.history.replaceState({}, '', url);

        // Restart polling with new interval if live mode is on
        if (liveModeEnabled) {
            stopPortfolioPolling();
            startPortfolioPolling();
        }
    }

    function updateLiveModeUI() {
        const label = document.querySelector('.live-mode-label');
        const intervalContainer = document.getElementById('poll-interval-container');

        if (label) {
            label.style.color = liveModeEnabled ? '#4CAF50' : '#666';
        }

        if (intervalContainer) {
            intervalContainer.style.display = liveModeEnabled ? 'inline-flex' : 'none';
        }
    }

    function initLiveMode() {
        // Read from URL params
        const urlParams = new URLSearchParams(window.location.search);
        const liveParam = urlParams.get('live');
        const intervalParam = urlParams.get('interval');

        liveModeEnabled = liveParam === '1' || liveParam === 'true';

        // Set poll interval from URL or default to 30
        if (intervalParam && !isNaN(parseInt(intervalParam))) {
            pollIntervalSeconds = Math.max(5, Math.min(300, parseInt(intervalParam)));
        }

        // Set checkbox state
        const checkbox = document.getElementById('live-mode-checkbox');
        if (checkbox) {
            checkbox.checked = liveModeEnabled;
        }

        // Set interval input value
        const intervalInput = document.getElementById('poll-interval-input');
        if (intervalInput) {
            intervalInput.value = pollIntervalSeconds;
        }

        // Update UI
        updateLiveModeUI();

        // Make initial polling call once on page load (regardless of live mode state)
        liveModePolling();

        // Start continuous polling only if live mode is enabled
        if (liveModeEnabled) {
            startPortfolioPolling();
        }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initLiveMode);

    // Initialize report button visibility on page load
    document.addEventListener('DOMContentLoaded', updateReportButtonVisibility);

    // ========== Refresh Portfolio Button ==========
    async function refreshPortfolio() {
        const btn = document.querySelector('.refresh-portfolio-btn');
        if (!btn) return;

        // Add spinning animation
        btn.classList.add('refreshing');
        btn.disabled = true;

        try {
            await fetchPortfolioPositions();
        } catch (error) {
            console.error('Error refreshing portfolio:', error);
        } finally {
            // Remove spinning animation after a short delay
            setTimeout(() => {
                btn.classList.remove('refreshing');
                btn.disabled = false;
            }, 500);
        }
    }

    function goToDate(dateStr) {
        if (!dateStr) {
            dateStr = document.getElementById('game-date').value;
        }
        
        // Preserve league prefix if we're on a league-prefixed route
        const pathMatch = window.location.pathname.match(/^\/([a-z]+)\//);
        const leaguePrefix = (pathMatch && pathMatch[1] !== 'api') ? '/' + pathMatch[1] : '';
        
        window.location.href = `${leaguePrefix}/?date=${dateStr}`;
    }
    
    document.getElementById('game-date').addEventListener('change', function() {
        goToDate();
    });
    
    // Job polling helper
    async function pollJobProgress(jobId, onProgress, onComplete, onError) {
        const pollInterval = 500; // Poll every 500ms
        // No max attempts - jobs can run as long as needed (CBB can have 100+ games)
        let lastProgress = -1;
        let stuckCounter = 0;

        const poll = async () => {
            try {
                const response = await fetch(apiUrl(`/api/jobs/${jobId}`));
                const data = await response.json();

                if (!response.ok || !data.success) {
                    throw new Error(data.error || 'Failed to get job status');
                }

                const job = data.job;
                
                // Debug logging
                console.log(`Job ${jobId}: status=${job.status}, progress=${job.progress}%, message="${job.message}"`);
                
                // Check if progress is stuck
                if (job.progress === lastProgress) {
                    stuckCounter++;
                    if (stuckCounter >= 12) { // 6 seconds of no progress (12 * 500ms)
                        console.warn(`Job ${jobId} appears stuck at ${job.progress}% for ${stuckCounter * pollInterval / 1000}s`);
                    }
                } else {
                    stuckCounter = 0;
                    lastProgress = job.progress;
                }
                
                onProgress(job.progress, job.message);

                if (job.status === 'completed') {
                    console.log(`Job ${jobId} completed successfully`);
                    onComplete(job);
                    return;
                } else if (job.status === 'failed') {
                    console.error(`Job ${jobId} failed: ${job.error || job.message || 'Job failed'}`);
                    throw new Error(job.error || job.message || 'Job failed');
                }

                setTimeout(poll, pollInterval);
            } catch (error) {
                console.error(`Job ${jobId} polling error:`, error);
                onError(error);
            }
        };

        console.log(`Starting to poll job ${jobId}`);
        poll();
    }

    function showJobProgress(show) {
        const container = document.getElementById('job-progress-container');
        container.style.display = show ? 'inline-flex' : 'none';
    }

    function updateJobProgress(progress, message) {
        const fill = document.getElementById('job-progress-fill');
        const text = document.getElementById('job-progress-text');
        fill.style.width = `${progress}%`;
        text.textContent = message || `${progress}%`;
    }

    // Debug function to manually check job status
    async function debugJobStatus(jobId) {
        try {
            const response = await fetch(apiUrl(`/api/jobs/${jobId}`));
            const data = await response.json();
            console.log('Job debug info:', data);
            return data;
        } catch (error) {
            console.error('Error fetching job status:', error);
            return null;
        }
    }

    // Make debug function available globally for manual testing
    window.debugJobStatus = debugJobStatus;

    // Check for active prediction/sync jobs on page load and resume polling
    async function checkForActiveJobs() {
        const jobTypes = ['predict_all', 'sync'];

        for (const jobType of jobTypes) {
            try {
                const response = await fetch(apiUrl(`/api/jobs/running/${jobType}`));
                const data = await response.json();

                if (data.success && data.job) {
                    const job = data.job;
                    console.log(`Found active ${jobType} job: ${job._id}, progress=${job.progress}%`);

                    // Disable buttons and show progress bar
                    const predBtn = document.querySelector('.run-predictions-btn');
                    const pullBtn = document.querySelector('.pull-data-btn');
                    if (predBtn) predBtn.disabled = true;
                    if (pullBtn) pullBtn.disabled = true;

                    if (jobType === 'predict_all' && predBtn) {
                        predBtn.textContent = 'Running...';
                    } else if (jobType === 'sync' && pullBtn) {
                        pullBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; margin-right: 4px;"><path d="M8 2V14M8 14L3 9M8 14L13 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg> Syncing...';
                    }

                    showJobProgress(true);
                    updateJobProgress(job.progress, job.message);

                    // Get date from job metadata or page
                    const jobDate = (job.metadata && job.metadata.date) || document.getElementById('game-date').value;

                    // Resume polling
                    pollJobProgress(
                        job._id,
                        (progress, message) => {
                            updateJobProgress(progress, message);
                            // For prediction jobs, fetch and update predictions in real-time
                            if (jobType === 'predict_all' && jobDate) {
                                fetchAndUpdatePredictions(jobDate);
                            }
                        },
                        (completedJob) => {
                            // Final fetch for prediction jobs
                            if (jobType === 'predict_all' && jobDate) {
                                fetchAndUpdatePredictions(jobDate);
                            }
                            showJobProgress(false);
                            if (predBtn) {
                                predBtn.disabled = false;
                                predBtn.textContent = 'Run Predictions';
                            }
                            if (pullBtn) {
                                pullBtn.disabled = false;
                                pullBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; margin-right: 4px;"><path d="M8 2V14M8 14L3 9M8 14L13 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg> Pull Data';
                            }
                        },
                        (error) => {
                            showJobProgress(false);
                            if (predBtn) {
                                predBtn.disabled = false;
                                predBtn.textContent = 'Run Predictions';
                            }
                            if (pullBtn) {
                                pullBtn.disabled = false;
                                pullBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; margin-right: 4px;"><path d="M8 2V14M8 14L3 9M8 14L13 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg> Pull Data';
                            }
                            console.error(`Job ${jobType} failed:`, error);
                        }
                    );

                    // Only handle one active job at a time
                    return;
                }
            } catch (error) {
                console.error(`Error checking for active ${jobType} jobs:`, error);
            }
        }
    }

    // Check for active jobs on page load
    document.addEventListener('DOMContentLoaded', checkForActiveJobs);

    async function runAllPredictions() {
        const btn = document.querySelector('.run-predictions-btn');
        const pullBtn = document.querySelector('.pull-data-btn');
        const dateStr = document.getElementById('game-date').value;

        if (!dateStr) {
            alert('Please select a date first');
            return;
        }

        // Clear cached betting report since predictions are changing
        lastBettingReport = null;

        // Disable buttons and show progress
        btn.disabled = true;
        pullBtn.disabled = true;
        btn.textContent = 'Running...';
        showJobProgress(true);
        updateJobProgress(0, 'Starting predictions...');

        try {
            const response = await fetch(apiUrl('/api/predict-all'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ date: dateStr })
            });

            const data = await response.json();

            if (!response.ok || !data.success) {
                throw new Error(data.error || 'Failed to start prediction job');
            }

            // Poll for job progress and update predictions in real-time
            pollJobProgress(
                data.job_id,
                (progress, message) => {
                    updateJobProgress(progress, message);
                    // Fetch and display predictions as they complete
                    fetchAndUpdatePredictions(dateStr);
                },
                (job) => {
                    // Job completed - final fetch to ensure all predictions are shown
                    fetchAndUpdatePredictions(dateStr);
                    showJobProgress(false);
                    btn.disabled = false;
                    pullBtn.disabled = false;
                    btn.textContent = 'Run Predictions';
                },
                (error) => {
                    // Job failed
                    showJobProgress(false);
                    btn.disabled = false;
                    pullBtn.disabled = false;
                    btn.textContent = 'Run Predictions';
                    alert('Error running predictions: ' + error.message);
                }
            );

        } catch (error) {
            console.error('Error starting predictions:', error);
            showJobProgress(false);
            btn.disabled = false;
            pullBtn.disabled = false;
            btn.textContent = 'Run Predictions';
            alert('Error running predictions: ' + error.message);
        }
    }

    async function autoSetLineups() {
        const btn = document.getElementById('auto-lineup-btn');
        const dateStr = document.getElementById('game-date').value;
        if (!dateStr) { alert('Please select a date first'); return; }

        btn.disabled = true;
        btn.textContent = 'Setting lineups...';

        try {
            const response = await fetch(apiUrl('/api/auto-set-lineups'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ game_date: dateStr })
            });
            const data = await response.json();
            if (!response.ok || !data.success) {
                throw new Error(data.error || 'Failed to auto-set lineups');
            }
            const summary = `Updated ${data.teams_updated} team(s), skipped ${data.teams_skipped}.\n` +
                (data.details || []).map(d => `${d.team}: ${d.starters}S / ${d.bench}B / ${d.injured}I`).join('\n');
            alert(summary);
            location.reload();
        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            btn.disabled = false;
            btn.textContent = 'Auto-set Lineups';
        }
    }

    async function pullGameData() {
        const btn = document.querySelector('.pull-data-btn');
        const predBtn = document.querySelector('.run-predictions-btn');
        const dateStr = document.getElementById('game-date').value;

        if (!dateStr) {
            alert('Please select a date first');
            return;
        }

        // Disable buttons and show progress
        btn.disabled = true;
        predBtn.disabled = true;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; margin-right: 4px;"><path d="M8 2V14M8 14L3 9M8 14L13 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg> Syncing...';
        showJobProgress(true);
        updateJobProgress(0, 'Starting sync...');

        try {
            const response = await fetch(apiUrl('/api/pull-game-data'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ date: dateStr })
            });

            const data = await response.json();

            if (!response.ok || !data.success) {
                throw new Error(data.error || 'Failed to start sync job');
            }

            // Poll for job progress
            pollJobProgress(
                data.job_id,
                (progress, message) => updateJobProgress(progress, message),
                (job) => {
                    // Job completed
                    showJobProgress(false);
                    btn.disabled = false;
                    predBtn.disabled = false;
                    btn.innerHTML = originalText;
                    // Reload to show updated data
                    window.location.reload();
                },
                (error) => {
                    // Job failed
                    showJobProgress(false);
                    btn.disabled = false;
                    predBtn.disabled = false;
                    btn.innerHTML = originalText;
                    alert('Error pulling game data: ' + error.message);
                }
            );

        } catch (error) {
            console.error('Error starting sync:', error);
            showJobProgress(false);
            btn.disabled = false;
            predBtn.disabled = false;
            btn.innerHTML = originalText;
            alert('Error pulling game data: ' + error.message);
        }
    }
    
    function updateGameCardsWithPredictions(predictions) {
        predictions.forEach(result => {
            const gameCard = document.querySelector(`[data-game-id="${result.game_id}"]`);
            if (!gameCard) return;
            
            const pred = result.prediction;
            const awayTeam = gameCard.querySelector('.team-panel.away');
            const homeTeam = gameCard.querySelector('.team-panel.home');
            
            if (!awayTeam || !homeTeam) return;
            
            // Remove existing badges
            awayTeam.querySelectorAll('.prediction-banner, .points-prediction').forEach(badge => badge.remove());
            homeTeam.querySelectorAll('.prediction-banner, .points-prediction').forEach(badge => badge.remove());
            
            // Find insertion point: after Kalshi price if it exists, otherwise after score/spread
            const awayKalshiEl = awayTeam.querySelector('.kalshi-price');
            const homeKalshiEl = homeTeam.querySelector('.kalshi-price');
            const awayInsertAfter = awayKalshiEl || awayTeam.querySelector('.spread, .team-score');
            const homeInsertAfter = homeKalshiEl || homeTeam.querySelector('.spread, .team-score');
            
            // Add new win probability badges
            if (pred && pred.away_win_prob !== undefined && pred.away_win_prob !== null) {
                const awayBadge = document.createElement('div');
                awayBadge.className = 'prediction-banner';
                awayBadge.textContent = `${Math.round(pred.away_win_prob)}%${pred.away_odds !== undefined && pred.away_odds !== null ? ` (${pred.away_odds >= 0 ? '+' : ''}${Math.round(pred.away_odds)})` : ''}`;
                if (awayInsertAfter) {
                    awayInsertAfter.after(awayBadge);
                } else {
                    awayTeam.appendChild(awayBadge);
                }
            }
            
            if (pred && pred.home_win_prob !== undefined && pred.home_win_prob !== null) {
                const homeBadge = document.createElement('div');
                homeBadge.className = 'prediction-banner';
                homeBadge.textContent = `${Math.round(pred.home_win_prob)}%${pred.home_odds !== undefined && pred.home_odds !== null ? ` (${pred.home_odds >= 0 ? '+' : ''}${Math.round(pred.home_odds)})` : ''}`;
                if (homeInsertAfter) {
                    homeInsertAfter.after(homeBadge);
                } else {
                    homeTeam.appendChild(homeBadge);
                }
            }
            
            // Add points prediction badges (after win probability badges)
            const awayPredBanner = awayTeam.querySelector('.prediction-banner');
            const homePredBanner = homeTeam.querySelector('.prediction-banner');
            
            if (pred && pred.away_points_pred !== undefined && pred.away_points_pred !== null) {
                const awayPointsBadge = document.createElement('div');
                awayPointsBadge.className = 'points-prediction';
                awayPointsBadge.textContent = `${Math.round(pred.away_points_pred)} pts`;
                if (awayPredBanner) {
                    awayPredBanner.after(awayPointsBadge);
                } else if (awayInsertAfter) {
                    awayInsertAfter.after(awayPointsBadge);
                } else {
                    awayTeam.appendChild(awayPointsBadge);
                }
            }
            
            if (pred && pred.home_points_pred !== undefined && pred.home_points_pred !== null) {
                const homePointsBadge = document.createElement('div');
                homePointsBadge.className = 'points-prediction';
                homePointsBadge.textContent = `${Math.round(pred.home_points_pred)} pts`;
                if (homePredBanner) {
                    homePredBanner.after(homePointsBadge);
                } else if (homeInsertAfter) {
                    homeInsertAfter.after(homePointsBadge);
                } else {
                    homeTeam.appendChild(homePointsBadge);
                }
            }
        });

        // Update report button visibility after predictions are added
        updateReportButtonVisibility();
    }

    // Fetch predictions for a date and update game cards in real-time
    async function fetchAndUpdatePredictions(dateStr) {
        try {
            const response = await fetch(apiUrl(`/api/predictions/${dateStr}`));
            const data = await response.json();

            if (!data.success || !data.predictions) return;

            // Transform DB format to the format updateGameCardsWithPredictions expects
            const transformed = data.predictions.map(pred => ({
                game_id: pred.game_id,
                prediction: {
                    home_win_prob: pred.home_win_prob,
                    away_win_prob: pred.away_win_prob,
                    home_odds: pred.home_odds,
                    away_odds: pred.away_odds,
                    home_points_pred: pred.home_points_pred,
                    away_points_pred: pred.away_points_pred
                }
            }));

            updateGameCardsWithPredictions(transformed);
        } catch (error) {
            console.error('Error fetching predictions:', error);
        }
    }

    // Feature values modal
    function showGameFeatures(gameId, gameDate, homeTeam, awayTeam) {
        // Show loading state
        const modal = document.getElementById('features-modal');
        const modalContent = document.getElementById('features-modal-content');
        modal.style.display = 'flex';
        modalContent.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner"></div><p>Loading feature values...</p></div>';
        
        // Fetch feature values
        fetch(apiUrl('/api/game-features'), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_id: gameId,
                game_date: gameDate,
                home_team: homeTeam,
                away_team: awayTeam
            })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                modalContent.innerHTML = `<div style="padding: 20px; color: #d32f2f;"><p>Error: ${data.error || 'Failed to load features'}</p></div>`;
                return;
            }
            
            // Build modal content
            let html = `
                <div class="features-modal-header">
                    <h2>Feature Values</h2>
                    <button class="close-modal" onclick="closeFeaturesModal()">&times;</button>
                </div>
                <div class="features-modal-body">
                    <div class="game-info">
                        <strong>${data.away_team} @ ${data.home_team}</strong><br>
                        <small>${data.game_date} | ${data.total_features} features</small>
                    </div>
            `;

            // Base Model Feature Breakdowns (for ensemble models) - displayed at top
            if (data.ensemble_breakdown && data.ensemble_breakdown.base_models && data.ensemble_breakdown.base_models.length > 0) {
                html += `
                    <div class="feature-category base-model-breakdown">
                        <h3>Base Model Predictions</h3>
                        <p style="margin: 10px 0; font-size: 12px; color: #666;">
                            Each base model uses a specific subset of features. Expand to see the feature values used by each model.
                        </p>
                `;

                data.ensemble_breakdown.base_models.forEach((baseModel, index) => {
                    const probPct = baseModel.home_win_prob_pct || 0;
                    const probColor = probPct >= 50 ? '#2e7d32' : '#d32f2f';
                    const features = baseModel.features_dict || {};
                    const featureEntries = Object.entries(features);

                    html += `
                        <div class="base-model-section" style="margin-bottom: 12px; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden;">
                            <div class="base-model-header" style="background: #f5f5f5; padding: 12px; display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleBaseModel(${index})">
                                <div>
                                    <strong style="font-size: 14px;">${baseModel.name || 'Base Model ' + (index + 1)}</strong>
                                    <span style="font-size: 11px; color: #666; margin-left: 8px;">${baseModel.model_type || ''}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <span style="font-size: 14px; font-weight: 600; color: ${probColor};">
                                        ${probPct.toFixed(1)}% home
                                    </span>
                                    <span style="font-size: 11px; color: #888;">${featureEntries.length} features</span>
                                    <span class="base-model-toggle" id="base-model-toggle-${index}" style="font-size: 16px; transition: transform 0.2s;">▼</span>
                                </div>
                            </div>
                            <div class="base-model-features" id="base-model-features-${index}" style="display: none; padding: 10px;">
                                <table class="features-table" style="font-size: 12px;">
                                    <thead>
                                        <tr>
                                            <th style="text-align: left; padding: 4px 8px;">Feature</th>
                                            <th style="text-align: right; padding: 4px 8px;">Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;

                    // Sort features alphabetically and display
                    featureEntries.sort((a, b) => a[0].localeCompare(b[0])).forEach(([fname, fvalue]) => {
                        let displayValue;
                        if (typeof fvalue === 'number') {
                            // Check if it looks like a probability (0-1 range)
                            if (fvalue >= 0 && fvalue <= 1 && fname.startsWith('p_')) {
                                displayValue = `${(fvalue * 100).toFixed(1)}%`;
                            } else {
                                displayValue = fvalue.toFixed(4);
                            }
                        } else {
                            displayValue = fvalue;
                        }
                        html += `
                                        <tr>
                                            <td style="padding: 4px 8px; border-bottom: 1px solid #f0f0f0;">${fname}</td>
                                            <td style="text-align: right; padding: 4px 8px; border-bottom: 1px solid #f0f0f0;">${displayValue}</td>
                                        </tr>
                        `;
                    });

                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                });

                html += `
                    </div>
                `;
            }

            // Category descriptions (ensemble_outputs removed - replaced by Base Model Predictions section above)
            const categoryDescriptions = {
                'outcome_strength': 'Outcome Strength',
                'shooting_efficiency': 'Shooting Efficiency',
                'offensive_engine': 'Offensive Engine',
                'defensive_engine': 'Defensive Engine',
                'pace_volatility': 'Pace & Volatility',
                'schedule_fatigue': 'Schedule & Fatigue',
                'sample_size': 'Sample Size',
                'elo_strength': 'Elo Strength',
                'era_normalization': 'Era Normalization',
                'player_talent': 'Player Talent',
                'absolute_magnitude': 'Absolute Magnitude',
                'injuries': 'Injuries',
                'point_predictions': 'Point Predictions'
            };

            // Define display order for categories (ensemble_outputs removed)
            const categoryOrder = [
                'point_predictions',
                'outcome_strength',
                'elo_strength',
                'player_talent',
                'injuries',
                'shooting_efficiency',
                'offensive_engine',
                'defensive_engine',
                'pace_volatility',
                'schedule_fatigue',
                'era_normalization',
                'sample_size',
                'absolute_magnitude'
            ];
            
            // Display features by category in defined order
            for (const category of categoryOrder) {
                const features = data.feature_categories[category];
                if (!features || features.length === 0) continue;

                html += `
                    <div class="feature-category">
                        <h3>${categoryDescriptions[category] || category}</h3>
                        <table class="features-table">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                const normValues = data.meta_normalized_values || {};
                features.forEach(f => {
                    let displayValue;
                    if (typeof f.value === 'number') {
                        // Format as percentage for probabilities (0-1 range)
                        if (f.value >= 0 && f.value <= 1 && category === 'ensemble_outputs') {
                            displayValue = `${(f.value * 100).toFixed(1)}%`;
                        } else {
                            displayValue = f.value.toFixed(4);
                        }
                    } else {
                        displayValue = f.value;
                    }
                    // Show normalized value if it differs from raw
                    if (normValues[f.name] !== undefined) {
                        displayValue += ` <span style="color: #888; font-size: 11px;">(${normValues[f.name].toFixed(4)})</span>`;
                    }
                    html += `
                        <tr>
                            <td class="feature-name">${f.name}</td>
                            <td class="feature-value">${displayValue}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // Add injured players section
            if (data.home_injured_players && data.home_injured_players.length > 0 || 
                data.away_injured_players && data.away_injured_players.length > 0) {
                html += `
                    <div class="feature-category">
                        <h3>Injured Players</h3>
                        <div style="padding: 10px;">
                `;
                if (data.home_injured_players && data.home_injured_players.length > 0) {
                    html += `
                        <div style="margin-bottom: 10px;">
                            <strong>${data.home_team}:</strong> ${data.home_injured_players.join(', ')}
                        </div>
                    `;
                }
                if (data.away_injured_players && data.away_injured_players.length > 0) {
                    html += `
                        <div>
                            <strong>${data.away_team}:</strong> ${data.away_injured_players.join(', ')}
                        </div>
                    `;
                }
                html += `
                        </div>
                    </div>
                `;
            }
            
            // Add player lists section for player-level features
            if (data.feature_players && Object.keys(data.feature_players).length > 0) {
                html += `
                    <div class="feature-category">
                        <h3>Players Involved in Feature Calculations</h3>
                        <div style="padding: 10px;">
                `;
                
                // Group PER features by type
                const perFeatureGroups = {
                    'player_team_per|season|avg': 'Team PER Average',
                    'player_team_per|season|weighted_MPG': 'Team PER Weighted (MPG)',
                    'player_starters_per|season|avg': 'Starters PER Average',
                    'player_per_1|season|top1_avg': 'Top Player PER (1st)',
                    'player_per_2|season|top1_avg': 'Top Player PER (2nd)',
                    'player_per_3|season|top1_avg': 'Top Player PER (3rd)'
                };
                
                for (const [featureBase, featureLabel] of Object.entries(perFeatureGroups)) {
                    const homeFeature = `${featureBase}|home`;
                    const awayFeature = `${featureBase}|away`;
                    
                    const homePlayers = data.feature_players[homeFeature] || [];
                    const awayPlayers = data.feature_players[awayFeature] || [];
                    
                    if (homePlayers.length > 0 || awayPlayers.length > 0) {
                        html += `
                            <div style="margin-bottom: 20px; border-bottom: 1px solid #e0e0e0; padding-bottom: 15px;">
                                <h4 style="margin-bottom: 10px; color: #1976d2;">${featureLabel}</h4>
                        `;
                        
                        if (homePlayers.length > 0) {
                            html += `
                                <div style="margin-bottom: 10px;">
                                    <strong>${data.home_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            homePlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        if (awayPlayers.length > 0) {
                            html += `
                                <div>
                                    <strong>${data.away_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            awayPlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                    }
                }
                
                // Group injury features by type
                const injuryFeatureGroups = {
                    'inj_per|none|weighted_MIN': 'Injury PER Value (Weighted)',
                    'inj_per|none|top1_avg': 'Injury Top 1 PER',
                    'inj_per|none|top3_sum': 'Injury Top 3 PER Sum',
                    'inj_min_lost|none|raw': 'Injury Minutes Lost',
                    'inj_rotation_per|none|raw': 'Injury Rotation Count'
                };
                
                // Also support old format feature names
                for (const [featureBase, featureLabel] of Object.entries(injuryFeatureGroups)) {
                    const homeFeature = `${featureBase}|home`;
                    const awayFeature = `${featureBase}|away`;
                    
                    // Use new format only
                    const homePlayers = data.feature_players[homeFeature] || [];
                    const awayPlayers = data.feature_players[awayFeature] || [];
                    
                    if (homePlayers.length > 0 || awayPlayers.length > 0) {
                        html += `
                            <div style="margin-bottom: 20px; border-bottom: 1px solid #e0e0e0; padding-bottom: 15px;">
                                <h4 style="margin-bottom: 10px; color: #d32f2f;">${featureLabel}</h4>
                        `;
                        
                        if (homePlayers.length > 0) {
                            html += `
                                <div style="margin-bottom: 10px;">
                                    <strong>${data.home_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            homePlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                const weightedPerStr = player.weighted_per !== undefined ? ` (Weighted PER: ${player.weighted_per.toFixed(2)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}${weightedPerStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        if (awayPlayers.length > 0) {
                            html += `
                                <div>
                                    <strong>${data.away_team}:</strong>
                                    <ul style="margin: 5px 0; padding-left: 20px;">
                            `;
                            awayPlayers.forEach(player => {
                                const perStr = player.per !== undefined ? ` (PER: ${player.per.toFixed(2)})` : '';
                                const mpgStr = player.mpg !== undefined ? ` (MPG: ${player.mpg.toFixed(1)})` : '';
                                const weightedPerStr = player.weighted_per !== undefined ? ` (Weighted PER: ${player.weighted_per.toFixed(2)})` : '';
                                html += `<li>${player.player_name || player.player_id}${perStr}${mpgStr}${weightedPerStr}</li>`;
                            });
                            html += `
                                    </ul>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                    }
                }
                
                html += `
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            modalContent.innerHTML = html;
        })
        .catch(error => {
            console.error('Error loading features:', error);
            modalContent.innerHTML = `<div style="padding: 20px; color: #d32f2f;"><p>Error loading features: ${error.message}</p></div>`;
        });
    }
    
    function closeFeaturesModal() {
        document.getElementById('features-modal').style.display = 'none';
    }

    // ========== Betting Report Functions ==========
    let lastBettingReport = null;  // Cache for last generated report
    let previousRecommendations = null;  // Previous poll data for blink comparison
    let bettingReportPollTimer = null;  // Polling interval handle
    let bettingReportTickTimer = null;  // 1-second tick for "Changed" column
    let persistedDeltas = {};  // team -> { mkt, mod, edge, stake, changedAt (epoch ms) }
    let lastPortfolioPositions = null;  // Cached portfolio positions keyed by game_id

    // Restore bankroll/edge inputs from sessionStorage (per league)
    (function restoreBettingInputs() {
        const key = 'bettingInputs_' + window.ESPN_LEAGUE_SLUG;
        try {
            const saved = JSON.parse(sessionStorage.getItem(key));
            if (saved) {
                if (saved.bankroll) document.getElementById('bankroll-input').value = saved.bankroll;
                if (saved.edge) document.getElementById('edge-threshold-input').value = saved.edge;
            }
        } catch (e) {}
    })();

    // Sync header inputs → modal inputs when opening
    function syncInputsToModal() {
        const bankrollHeader = document.getElementById('bankroll-input');
        const edgeHeader = document.getElementById('edge-threshold-input');
        const bankrollModal = document.getElementById('modal-bankroll-input');
        const edgeModal = document.getElementById('modal-edge-input');
        if (bankrollHeader && bankrollModal) bankrollModal.value = bankrollHeader.value;
        if (edgeHeader && edgeModal) edgeModal.value = edgeHeader.value;
    }

    // Sync modal inputs → header inputs when closing
    function syncInputsFromModal() {
        const bankrollHeader = document.getElementById('bankroll-input');
        const edgeHeader = document.getElementById('edge-threshold-input');
        const bankrollModal = document.getElementById('modal-bankroll-input');
        const edgeModal = document.getElementById('modal-edge-input');
        if (bankrollModal && bankrollHeader) bankrollHeader.value = bankrollModal.value;
        if (edgeModal && edgeHeader) edgeHeader.value = edgeModal.value;
    }

    function startBettingReportPoll() {
        stopBettingReportPoll();
        const rateSec = Math.max(1, parseInt(document.getElementById('modal-refresh-rate').value) || 5);
        bettingReportPollTimer = setInterval(() => {
            refreshBettingReport(true);
        }, rateSec * 1000);
        // 1-second tick to update the "Changed" elapsed counters
        bettingReportTickTimer = setInterval(tickChangedCells, 1000);
    }

    // Restart poll when refresh rate changes
    document.getElementById('modal-refresh-rate').addEventListener('change', function() {
        if (bettingReportPollTimer) startBettingReportPoll();
    });

    function stopBettingReportPoll() {
        if (bettingReportPollTimer) {
            clearInterval(bettingReportPollTimer);
            bettingReportPollTimer = null;
        }
        if (bettingReportTickTimer) {
            clearInterval(bettingReportTickTimer);
            bettingReportTickTimer = null;
        }
    }

    // Update all "Changed" cells with live elapsed time
    function tickChangedCells() {
        const cells = document.querySelectorAll('[data-changed-team]');
        const now = Date.now();
        cells.forEach(cell => {
            const team = cell.getAttribute('data-changed-team');
            const pd = persistedDeltas[team];
            if (pd && pd.changedAt) {
                cell.textContent = fmtElapsed(now - pd.changedAt);
            }
        });
    }

    // Format milliseconds elapsed as compact string: "0s", "45s", "2m 10s", "1h 5m"
    function fmtElapsed(ms) {
        const totalSec = Math.max(0, Math.floor(ms / 1000));
        if (totalSec < 60) return `${totalSec}s`;
        const m = Math.floor(totalSec / 60);
        const s = totalSec % 60;
        if (m < 60) return `${m}m ${s}s`;
        const h = Math.floor(m / 60);
        return `${h}h ${m % 60}m`;
    }

    function generateBettingReport() {
        const modal = document.getElementById('betting-report-modal');
        syncInputsToModal();

        // If we already have a report, just open the modal and start polling
        if (lastBettingReport) {
            modal.style.display = 'flex';
            startBettingReportPoll();
            return;
        }

        // Otherwise, fetch a new report
        refreshBettingReport();
    }

    async function refreshBettingReport(isPoll = false) {
        const dateStr = document.getElementById('game-date').value;
        // Read from modal inputs (the live source of truth while modal is open)
        const bankroll = parseFloat(document.getElementById('modal-bankroll-input').value) || 1000;
        const edgeThreshold = (parseFloat(document.getElementById('modal-edge-input').value) || 7) / 100;

        const modal = document.getElementById('betting-report-modal');
        const content = document.getElementById('betting-report-content');
        const refreshBtn = document.getElementById('betting-report-refresh-btn');
        modal.style.display = 'flex';

        // Only show loading text on first load (not on polls)
        if (!isPoll) {
            content.innerHTML = '<span style="font-family: monospace; font-size: 13px; color: #666;">Loading betting report...</span>';
        }

        if (refreshBtn && !isPoll) {
            refreshBtn.classList.add('refreshing');
            refreshBtn.disabled = true;
        }

        try {
            // Fetch portfolio positions first to know which games have fills
            const posRes = await fetch(apiUrl('/api/portfolio/game-positions?date=' + encodeURIComponent(dateStr)));
            const posData = await posRes.json();

            let forceGameIds = [];
            if (posData.success && posData.positions) {
                lastPortfolioPositions = posData.positions;
                // Collect game_ids that have fills or positions
                for (const [gid, gdata] of Object.entries(posData.positions)) {
                    if ((gdata.fills && gdata.fills.length > 0) || (gdata.positions && gdata.positions.length > 0)) {
                        forceGameIds.push(gid);
                    }
                }
            }

            // Fetch report with force-included game_ids
            const reportRes = await fetch(apiUrl('/api/betting-report'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ date: dateStr, bankroll: bankroll, edge_threshold: edgeThreshold, force_include_game_ids: forceGameIds })
            });

            const data = await reportRes.json();

            if (data.success) {
                // Save previous for blink comparison
                if (lastBettingReport && lastBettingReport.recommendations) {
                    previousRecommendations = lastBettingReport.recommendations;
                }
                lastBettingReport = data;
                // Persist inputs to sessionStorage (per league)
                try {
                    const key = 'bettingInputs_' + window.ESPN_LEAGUE_SLUG;
                    sessionStorage.setItem(key, JSON.stringify({ bankroll: bankroll, edge: Math.round(edgeThreshold * 100) }));
                } catch (e) {}
                displayBettingReport(data.recommendations, data.brier_score, bankroll, edgeThreshold);
                // Start polling after first successful load
                startBettingReportPoll();
            } else {
                content.innerHTML = '<span style="font-family: monospace; font-size: 13px; color: #c00;">Error: ' + (data.error || 'Failed to generate report') + '</span>';
            }
        } catch (error) {
            console.error('Error generating betting report:', error);
            if (!isPoll) {
                content.innerHTML = '<span style="font-family: monospace; font-size: 13px; color: #c00;">Error: ' + error.message + '</span>';
            }
        } finally {
            if (refreshBtn && !isPoll) {
                refreshBtn.classList.remove('refreshing');
                refreshBtn.disabled = false;
            }
        }
    }

    // Build a lookup map from previous recommendations keyed by team
    function buildPrevMap(recs) {
        const map = {};
        if (!recs) return map;
        recs.forEach(r => { map[r.team] = r; });
        return map;
    }

    // Convert probability (0-1) to American odds
    function probToAmerican(p) {
        if (p <= 0 || p >= 1) return 0;
        if (p >= 0.5) return Math.round(-100 * p / (1 - p));
        return Math.round(100 * (1 - p) / p);
    }

    // Format American odds with sign
    function fmtAmerican(odds) {
        return odds >= 0 ? `+${odds}` : String(odds);
    }

    // Map a value difference to an HSL hue (0=red, 60=yellow, 120=green).
    // diff > 0 means the position is better than current → green.
    // diff < 0 means the position is worse than current → red.
    // Magnitude is clamped at ±15 cents for full saturation.
    function diffToColor(diff) {
        const clamped = Math.max(-0.15, Math.min(0.15, diff));
        const hue = 60 + (clamped / 0.15) * 60;  // -0.15→0, 0→60, +0.15→120
        return `hsl(${Math.round(hue)}, 85%, 38%)`;
    }

    // Compute fill/position P&L scenarios for a game.
    // Returns { homePnl, awayPnl, hasFills } — P&L if home/away wins respectively.
    // Returns null if no fills/positions exist.
    function getGameFillScenarios(gameId, homeTeam, awayTeam) {
        if (!lastPortfolioPositions) return null;
        const gamePos = lastPortfolioPositions[gameId];
        if (!gamePos) return null;

        const kalshiMap = window.KALSHI_ABBREV_MAP || {};
        function toInternal(abbrev) { return kalshiMap[abbrev] || abbrev; }

        let homeCost = 0, homeContracts = 0;
        let awayCost = 0, awayContracts = 0;

        function addPosition(pos) {
            let team = toInternal(pos.team);
            // Buying NO on a team = buying YES on the opponent
            if (pos.side === 'no') {
                team = (team === homeTeam) ? awayTeam : homeTeam;
            }
            const count = pos.count || 0;
            const cost = pos.cost || (count * (pos.avg_price || 0));
            if (count <= 0) return;
            if (team === homeTeam) { homeCost += cost; homeContracts += count; }
            else if (team === awayTeam) { awayCost += cost; awayContracts += count; }
        }

        function addFills(fills) {
            for (const f of fills) {
                let team = toInternal(f.team);
                // Buying NO on a team = buying YES on the opponent
                if (f.side === 'no') {
                    team = (team === homeTeam) ? awayTeam : homeTeam;
                }
                const count = f.count || 0;
                const cost = f.cost || (count * (f.price || 0));
                if (team === homeTeam) {
                    if (f.action === 'buy') { homeCost += cost; homeContracts += count; }
                    else { homeContracts -= count; }
                } else if (team === awayTeam) {
                    if (f.action === 'buy') { awayCost += cost; awayContracts += count; }
                    else { awayContracts -= count; }
                }
            }
        }

        let hasPositions = false;
        for (const pos of (gamePos.positions || [])) {
            if ((pos.count || 0) > 0) { addPosition(pos); hasPositions = true; }
        }
        if (!hasPositions) { addFills(gamePos.fills || []); }

        if (homeContracts <= 0 && awayContracts <= 0) return null;

        const homeGain = homeContracts > 0 ? (homeContracts * 1.0) - homeCost : 0;
        const awayGain = awayContracts > 0 ? (awayContracts * 1.0) - awayCost : 0;

        // P&L if home wins: collect home gain, lose away cost
        // P&L if away wins: collect away gain, lose home cost
        const homePnl = homeGain - awayCost;
        const awayPnl = awayGain - homeCost;

        return {
            homePnl, awayPnl, hasFills: true,
            homeCost, homeContracts, awayCost, awayContracts,
            homeAvgPrice: homeContracts > 0 ? homeCost / homeContracts : 0,
            awayAvgPrice: awayContracts > 0 ? awayCost / awayContracts : 0
        };
    }

    // Build the Action cell HTML for a recommendation given portfolio data.
    // Compresses all fills/positions into a single net P&L line.
    // Shows $risk→$gain (odds). Negative prefix when position profits from opponent winning.
    // Color: green = position gained value since entry, red = lost value.
    function buildActionCell(r) {
        const scenarios = getGameFillScenarios(r.game_id, r.home_team, r.away_team);
        if (!scenarios) return '—';

        // Determine fill team: whichever team's win gives higher P&L
        const fillTeamIsHome = scenarios.homePnl >= scenarios.awayPnl;
        const fillTeam = fillTeamIsHome ? r.home_team : r.away_team;
        const isAgainst = fillTeam !== r.team;  // fill team differs from model edge team

        const scenarioFill = fillTeamIsHome ? scenarios.homePnl : scenarios.awayPnl;
        const scenarioOther = fillTeamIsHome ? scenarios.awayPnl : scenarios.homePnl;

        const upside = Math.max(scenarioFill, scenarioOther);
        const downside = Math.abs(Math.min(scenarioFill, scenarioOther));

        if (upside <= 0 && downside <= 0) return '—';

        // Equivalent odds from risk/reward ratio
        const impliedProb = (upside + downside) > 0 ? downside / (upside + downside) : 0.5;
        const odds = probToAmerican(impliedProb);

        // Color from fill team's perspective: green = position gained value
        // Current market prob for the fill team
        const fillMktProb = (r.team === r.home_team)
            ? (fillTeamIsHome ? r.market_prob : 1 - r.market_prob)
            : (fillTeamIsHome ? 1 - r.market_prob : r.market_prob);
        const entryPrice = fillTeamIsHome ? scenarios.homeAvgPrice : scenarios.awayAvgPrice;
        const diff = fillMktProb - entryPrice;  // positive = gained value = green
        const color = diffToColor(diff);

        const sign = isAgainst ? '-' : '';
        return `<span style="color:${color};font-weight:600;">${sign}$${downside.toFixed(2)}\u2192${upside.toFixed(2)} (${fmtAmerican(odds)})</span>`;
    }

    // Color for a delta value normalized against column max.
    // Positive → green, negative → red, zero → near-black.
    function deltaColor(val, colMax) {
        if (!colMax || val === 0) return '#555';
        const norm = Math.max(-1, Math.min(1, val / colMax));  // -1..+1
        if (norm > 0) {
            const g = Math.round(50 + 150 * norm);
            return `rgb(0,${g},0)`;
        }
        const r = Math.round(50 + 170 * (-norm));
        return `rgb(${r},0,0)`;
    }

    // Render a delta badge: "(▲3)" or "(▼2)" with color
    function dtag(val, colMax, suffix) {
        if (val == null || val === 0) return '';
        const arrow = val > 0 ? '▲' : '▼';
        const c = deltaColor(val, colMax);
        const s = suffix || '';
        return ` <span style="color:${c};font-size:0.75em;font-weight:600;">(${arrow}${Math.abs(val)}${s})</span>`;
    }

    function displayBettingReport(recommendations, brierScore, bankroll, edgeThreshold) {
        const content = document.getElementById('betting-report-content');
        const meta = document.getElementById('betting-report-meta');
        const edgePctThreshold = Math.round((edgeThreshold || 0.07) * 100);

        if (meta) {
            meta.textContent = `Brier: ${brierScore.toFixed(3)}`;
        }

        if (!recommendations || recommendations.length === 0) {
            content.innerHTML = `<span style="font-family: monospace; font-size: 15px; color: #666;">No value bets found (edge &lt; ${edgePctThreshold}%)</span>`;
            previousRecommendations = null;
            return;
        }

        const prevMap = buildPrevMap(previousRecommendations);
        const hasPrev = Object.keys(prevMap).length > 0;
        const nowMs = Date.now();

        // --- Pass 1: compute per-row values and fresh deltas, merge into persisted ---
        const fields = ['mkt', 'mod', 'edge', 'stake'];
        const rowData = recommendations.map(r => {
            const mktPct = Math.round(r.market_prob * 100);
            const modPct = Math.round(r.model_prob * 100);
            const edgePct = Math.round(r.edge * 100);
            const scenarios = getGameFillScenarios(r.game_id, r.home_team, r.away_team);
            const hasFills = !!scenarios;
            const stake = Math.round(r.adjusted_stake || r.stake || 0);

            // Compute live net $ value for games with fills
            // Net = (homeContracts * homeCurrentPrice - homeCost) + (awayContracts * awayCurrentPrice - awayCost)
            let netValue = null;
            if (hasFills) {
                const homeMktProb = (r.team === r.home_team) ? r.market_prob : 1 - r.market_prob;
                const awayMktProb = 1 - homeMktProb;
                netValue = (scenarios.homeContracts * homeMktProb - scenarios.homeCost)
                         + (scenarios.awayContracts * awayMktProb - scenarios.awayCost);
            }

            const prev = prevMap[r.team];
            let fresh = null;
            if (prev) {
                const pMkt = Math.round(prev.market_prob * 100);
                const pMod = Math.round(prev.model_prob * 100);
                const pEdge = Math.round(prev.edge * 100);
                const pStake = Math.round(prev.adjusted_stake || prev.stake || 0);
                fresh = {
                    mkt: mktPct - pMkt,
                    mod: modPct - pMod,
                    edge: edgePct - pEdge,
                    stake: stake - pStake
                };
            }

            // Merge fresh deltas into persisted: non-zero values replace, zero keeps old
            const key = r.team;
            if (!persistedDeltas[key]) {
                persistedDeltas[key] = { mkt: 0, mod: 0, edge: 0, stake: 0, changedAt: null };
            }
            const pd = persistedDeltas[key];
            if (fresh) {
                let anyChanged = false;
                for (const f of fields) {
                    if (fresh[f] !== 0) {
                        pd[f] = fresh[f];
                        anyChanged = true;
                    }
                }
                if (anyChanged) pd.changedAt = nowMs;
            }

            return { r, mktPct, modPct, edgePct, stake, hasFills, netValue, pd };
        });

        // --- Find column max absolute deltas across all persisted values ---
        const colMax = { mkt: 0, mod: 0, edge: 0, stake: 0 };
        rowData.forEach(({ pd }) => {
            for (const f of fields) {
                colMax[f] = Math.max(colMax[f], Math.abs(pd[f]));
            }
        });

        // Helper: build class attribute string
        function cls(blink, extra) {
            const parts = [];
            if (blink) parts.push(blink);
            if (extra) parts.push(extra);
            return parts.length ? ` class="${parts.join(' ')}"` : '';
        }

        // --- Pass 2: render rows ---
        const nowForElapsed = Date.now();
        let rows = '';
        rowData.forEach(({ r, mktPct, modPct, edgePct, stake, hasFills, netValue, pd }) => {
            const time = r.game_time_formatted || 'TBD';
            const mktOdds = r.market_odds >= 0 ? `+${r.market_odds}` : String(r.market_odds);
            const modOdds = r.model_odds >= 0 ? `+${r.model_odds}` : String(r.model_odds);

            // Blink class — only on fresh change this render (edge-driven)
            const prev = prevMap[r.team];
            let blink = '';
            if (prev) {
                const freshEdge = edgePct - Math.round(prev.edge * 100);
                if (freshEdge > 0) blink = 'blink-up';
                else if (freshEdge < 0) blink = 'blink-down';
            }

            // Delta tags from persisted values
            const dMkt = dtag(pd.mkt, colMax.mkt);
            const dMod = dtag(pd.mod, colMax.mod);
            const dEdge = dtag(pd.edge, colMax.edge);
            const dStake = dtag(pd.stake, colMax.stake);
            const elapsed = pd.changedAt ? fmtElapsed(nowForElapsed - pd.changedAt) : '—';

            // Team column: away@home — highlight team with higher return from fills,
            // or fall back to model edge team if no fills
            const away = r.away_team || '';
            const home = r.home_team || '';
            const scenarios = getGameFillScenarios(r.game_id, home, away);
            let highlightTeam;
            if (scenarios) {
                // Highlight whichever team's win gives higher P&L
                highlightTeam = scenarios.homePnl >= scenarios.awayPnl ? home : away;
            } else {
                highlightTeam = r.team;  // fall back to model edge
            }
            const awayHtml = highlightTeam === away
                ? `<span style="color: #2e7d32; font-weight: 800; font-size: 1.15em;">${away}</span>`
                : `<span style="color: #888;">${away}</span>`;
            const homeHtml = highlightTeam === home
                ? `<span style="color: #2e7d32; font-weight: 800; font-size: 1.15em;">${home}</span>`
                : `<span style="color: #888;">${home}</span>`;
            const teamCell = `${awayHtml}@${homeHtml}`;

            const actionCell = buildActionCell(r);

            // Detect live game: game time has passed
            const gameStarted = r.game_time && new Date(r.game_time) <= new Date();

            // Determine fill team perspective (for rows with fills)
            const fillIsHome = scenarios ? scenarios.homePnl >= scenarios.awayPnl : null;
            // highlightTeam's current market prob (flip from r.team if needed)
            const htIsRTeam = highlightTeam === r.team;
            const htMktProb = htIsRTeam ? r.market_prob : 1 - r.market_prob;

            let marketCell, modelCell, edgeCell, stakeCell;
            if (hasFills) {
                // --- Has fills: show from fill/highlight team's perspective ---
                const htMktPct = Math.round(htMktProb * 100);
                const htMktAmOdds = probToAmerican(htMktProb);
                const fmtHtMkt = htMktAmOdds >= 0 ? `+${htMktAmOdds}` : String(htMktAmOdds);

                // Model prediction from highlight team's perspective
                const htModProb = htIsRTeam ? r.model_prob : 1 - r.model_prob;
                const htModPct = Math.round(htModProb * 100);
                const htModAmOdds = probToAmerican(htModProb);
                const fmtHtMod = htModAmOdds >= 0 ? `+${htModAmOdds}` : String(htModAmOdds);

                // Entry price for edge calculation
                const entryPrice = fillIsHome ? scenarios.homeAvgPrice : scenarios.awayAvgPrice;
                const entryPct = Math.round(entryPrice * 100);

                // Edge = current live prob - entry prob (positive = value gained)
                const fillEdge = htMktPct - entryPct;
                const edgeSign = fillEdge >= 0 ? '+' : '';
                const edgeColor = fillEdge > 0 ? 'color:#2e7d32;' : fillEdge < 0 ? 'color:#c62828;' : '';

                marketCell = `<td${cls(blink, 'num')}>${fmtHtMkt} (${htMktPct}%)${dMkt}</td>`;
                modelCell = `<td${cls(blink, 'num')}>${fmtHtMod} (${htModPct}%)${dMod}</td>`;
                edgeCell = `<td class="num" style="${edgeColor}font-weight:700;">${edgeSign}${fillEdge}%</td>`;
                stakeCell = `<td${cls(blink, 'num')}>$${stake}${dStake}</td>`;
            } else {
                // --- No fills: model edge perspective ---
                marketCell = `<td${cls(blink, 'num')}>${mktOdds} (${mktPct}%)${dMkt}</td>`;
                modelCell = `<td${cls(blink, 'num')}>${modOdds} (${modPct}%)${dMod}</td>`;
                edgeCell = `<td${cls(blink, 'num')}>+${edgePct}%${dEdge}</td>`;
                stakeCell = `<td${cls(blink, 'num')}>$${stake}${dStake}</td>`;
            }

            rows += `<tr>
                <td>${time}</td>
                <td${cls(blink)}>${teamCell}</td>
                ${marketCell}
                ${modelCell}
                ${edgeCell}
                <td class="num">${r.edge_kelly.toFixed(3)}</td>
                <td class="num">${r.dog_variance_penalty.toFixed(2)}</td>
                ${stakeCell}
                <td class="num"${hasFills && netValue !== null ? ` style="color:${netValue >= 0 ? '#2e7d32' : '#c62828'};font-weight:600;"` : ''}>${hasFills && netValue !== null ? `${netValue >= 0 ? '+' : '-'}$${Math.abs(netValue).toFixed(2)}` : '-'}</td>
                <td class="num">${actionCell}</td>
                <td class="num" style="color:#888;font-size:0.85em;" data-changed-team="${r.team}">${elapsed}</td>
            </tr>`;
        });

        // Sum Net column
        let netSum = 0;
        rowData.forEach(({ netValue, hasFills }) => {
            if (hasFills && netValue !== null) netSum += netValue;
        });
        const netSumColor = netSum >= 0 ? '#2e7d32' : '#c62828';
        const netSumStr = `${netSum >= 0 ? '+' : '-'}$${Math.abs(netSum).toFixed(2)}`;

        content.innerHTML = `<table class="betting-report-table">
            <thead><tr>
                <th>Time</th><th>Team</th><th class="num">Market</th><th class="num">Model</th><th class="num">Edge</th><th class="num">Kelly</th><th class="num">p-coeff</th><th class="num">Stake</th><th class="num">Net</th><th class="num">Action</th><th class="num">Changed</th>
            </tr></thead>
            <tbody>${rows}</tbody>
            <tfoot><tr>
                <td colspan="8" style="text-align:right;font-weight:700;padding:8px;">Net Gain:</td>
                <td class="num" style="font-weight:700;color:${netSumColor};">${netSumStr}</td>
                <td colspan="2"></td>
            </tr></tfoot>
        </table>`;
    }

    function closeBettingReportModal() {
        document.getElementById('betting-report-modal').style.display = 'none';
        stopBettingReportPoll();
        syncInputsFromModal();
    }

    // Update report button visibility based on predictions
    function updateReportButtonVisibility() {
        const hasAnyPrediction = document.querySelectorAll('.prediction-banner').length > 0;
        const reportControls = document.getElementById('betting-report-controls');
        if (reportControls) {
            reportControls.style.display = hasAnyPrediction ? 'inline-flex' : 'none';
        }
    }

    // Toggle base model feature section visibility
    function toggleBaseModel(index) {
        const featuresEl = document.getElementById(`base-model-features-${index}`);
        const toggleEl = document.getElementById(`base-model-toggle-${index}`);
        if (featuresEl && toggleEl) {
            const isHidden = featuresEl.style.display === 'none';
            featuresEl.style.display = isHidden ? 'block' : 'none';
            toggleEl.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
        }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
        const featuresModal = document.getElementById('features-modal');
        if (event.target === featuresModal) {
            closeFeaturesModal();
        }
        const reportModal = document.getElementById('betting-report-modal');
        if (event.target === reportModal) {
            closeBettingReportModal();
        }
    }
</script>

<!-- Features Modal -->
<div id="features-modal" class="features-modal" style="display: none;">
    <div id="features-modal-content" class="features-modal-content"></div>
</div>

<!-- Betting Report Modal -->
<div id="betting-report-modal" class="features-modal" style="display: none;">
    <div class="features-modal-content betting-report-modal-content">
        <div class="features-modal-header">
            <div>
                <h2 style="margin: 0;">Betting Report</h2>
                <div class="betting-report-header-inputs">
                    <label for="modal-bankroll-input">$</label>
                    <input type="number" id="modal-bankroll-input" value="1000" min="1" step="100" title="Bankroll amount">
                    <label for="modal-edge-input">Edge%</label>
                    <input type="number" id="modal-edge-input" value="7" min="1" max="50" step="1" style="width: 45px;" title="Minimum edge threshold %">
                    <label for="modal-refresh-rate">Refresh</label>
                    <input type="number" id="modal-refresh-rate" value="5" min="1" max="120" step="1" style="width: 40px;" title="Poll interval in seconds">
                    <span style="font-size:11px;color:#888;">s</span>
                    <span class="betting-report-meta" id="betting-report-meta"></span>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="betting-report-refresh-btn" class="refresh-report-btn" onclick="refreshBettingReport()" title="Refresh report (pulls live Kalshi prices)">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <polyline points="1 20 1 14 7 14"></polyline>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                    </svg>
                </button>
                <button class="close-modal" onclick="closeBettingReportModal()">&times;</button>
            </div>
        </div>
        <div class="features-modal-body">
            <div id="betting-report-content" style="background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; margin: 0;"></div>
        </div>
    </div>
</div>

<!-- Game Detail Modal -->
<div id="game-detail-modal" class="game-detail-modal" style="display: none;">
    <div class="game-detail-modal-content">
        <div class="game-detail-header">
            <button class="gd-magic-btn" onclick="runModalMagicAnalysis()" title="AI matchup breakdown">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            </button>
            <button class="nav-arrow nav-prev" onclick="navigateGame(-1)" title="Previous game">&larr;</button>
            <div class="game-detail-teams">
                <div class="game-detail-team away">
                    <img id="gd-away-logo" src="" alt="" class="gd-team-logo">
                    <div class="gd-team-info">
                        <div class="gd-team-name-row">
                            <span id="gd-away-team" class="gd-team-name"></span>
                            <span id="gd-away-ml" class="gd-moneyline"></span>
                        </div>
                        <div id="gd-away-spread-score" class="gd-spread-score"></div>
                        <div id="gd-away-kalshi" class="gd-kalshi-price live-glow"></div>
                    </div>
                </div>
                <div class="game-detail-vs">@</div>
                <div class="game-detail-team home">
                    <img id="gd-home-logo" src="" alt="" class="gd-team-logo">
                    <div class="gd-team-info">
                        <div class="gd-team-name-row">
                            <span id="gd-home-team" class="gd-team-name"></span>
                            <span id="gd-home-ml" class="gd-moneyline"></span>
                        </div>
                        <div id="gd-home-spread-score" class="gd-spread-score"></div>
                        <div id="gd-home-kalshi" class="gd-kalshi-price live-glow"></div>
                    </div>
                </div>
            </div>
            <button class="nav-arrow nav-next" onclick="navigateGame(1)" title="Next game">&rarr;</button>
            <button class="gd-close-btn" onclick="closeGameDetail()">&times;</button>
        </div>
        <div class="team-stats-row" id="gd-team-stats-row"></div>
        <div class="game-detail-info">
            <span id="gd-game-date"></span>
            <span id="gd-gametime" class="gd-gametime"></span>
            <span id="gd-prediction-info"></span>
            <button class="gd-icon-btn" id="gd-info-btn" title="View feature values">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="16" x2="12" y2="12"></line>
                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                </svg>
            </button>
            <button class="gd-icon-btn" id="gd-chat-btn" title="Chat about matchup">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
            </button>
        </div>
        <div class="game-detail-body">
            <div class="team-roster-panel away-panel">
                <h3 id="gd-away-roster-title">Away Team</h3>
                <div class="roster-columns">
                    <div class="roster-column starters-column" data-column="starters" data-team="away">
                        <h4>Starters</h4>
                        <div class="player-list" id="away-starters"></div>
                    </div>
                    <div class="roster-column bench-column" data-column="bench" data-team="away">
                        <h4>Bench</h4>
                        <div class="player-list" id="away-bench"></div>
                    </div>
                    <div class="roster-column injured-column" data-column="injured" data-team="away">
                        <h4>Injured</h4>
                        <div class="player-list" id="away-injured"></div>
                    </div>
                </div>
            </div>
            <div class="team-roster-panel home-panel">
                <h3 id="gd-home-roster-title">Home Team</h3>
                <div class="roster-columns">
                    <div class="roster-column starters-column" data-column="starters" data-team="home">
                        <h4>Starters</h4>
                        <div class="player-list" id="home-starters"></div>
                    </div>
                    <div class="roster-column bench-column" data-column="bench" data-team="home">
                        <h4>Bench</h4>
                        <div class="player-list" id="home-bench"></div>
                    </div>
                    <div class="roster-column injured-column" data-column="injured" data-team="home">
                        <h4>Injured</h4>
                        <div class="player-list" id="home-injured"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="game-detail-footer">
            <button class="gd-action-btn run-prediction-btn" onclick="runGamePrediction()">Run Prediction</button>
        </div>
        <!-- Player Detail Panel (slides in from right) -->
        <div id="player-detail-panel" class="player-detail-panel">
            <div class="player-panel-header">
                <button class="player-panel-close" onclick="closePlayerPanel()">&times;</button>
            </div>
            <div class="player-panel-content">
                <div class="player-panel-headshot">
                    <img id="panel-player-headshot" src="" alt="">
                </div>
                <div id="panel-player-name" class="player-panel-name"></div>
                <div id="panel-player-pos" class="player-panel-pos"></div>
                <div id="panel-player-size" class="player-panel-size"></div>
                <div class="player-panel-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="panel-stat-ppg">-</div>
                        <div class="stat-label">PPG</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="panel-stat-rpg">-</div>
                        <div class="stat-label">RPG</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="panel-stat-apg">-</div>
                        <div class="stat-label">APG</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="panel-stat-gp">-</div>
                        <div class="stat-label">GP/GS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="panel-stat-per">
                            <span class="per-loading"></span>
                        </div>
                        <div class="stat-label">PER</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="panel-stat-mpg">-</div>
                        <div class="stat-label">MPG</div>
                    </div>
                </div>
                <div class="player-panel-news" id="panel-player-news">
                    <div class="news-header">Player Info</div>
                    <div class="news-content" id="panel-news-content">
                        <span class="news-loading">Loading...</span>
                    </div>
                    <div class="news-source" id="panel-news-source"></div>
                </div>
                <div class="player-panel-move">
                    <div class="move-search-wrapper">
                        <input type="text" id="panel-move-team" class="move-team-input" placeholder="Move to...">
                        <div id="panel-move-results" class="move-search-results"></div>
                    </div>
                </div>
                <div class="player-panel-drop">
                    <button class="drop-player-btn" onclick="dropPlayerFromRoster()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                        Drop from Roster
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Game Detail Modal Styles */
.game-detail-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.game-detail-modal-content {
    background: #fff;
    border-radius: 0;
    width: 100%;
    height: 100%;
    max-width: none;
    max-height: none;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: none;
    position: relative; /* For player detail panel positioning */
}

.game-detail-header {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px 20px;
    background: #f5f5f5;
    border-bottom: 1px solid #ddd;
    position: relative;
}

.nav-arrow {
    background: #e0e0e0;
    border: none;
    color: #333;
    font-size: 24px;
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s;
}

.nav-arrow:hover {
    background: #ccc;
}

.nav-arrow:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.game-detail-teams {
    display: flex;
    align-items: center;
    gap: 20px;
    margin: 0 30px;
}

.game-detail-team {
    display: flex;
    align-items: center;
    gap: 10px;
}

.gd-team-logo {
    width: 48px;
    height: 48px;
    object-fit: contain;
}

.gd-team-info {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

.game-detail-team.home .gd-team-info {
    align-items: flex-end;
}

.gd-team-name-row {
    display: flex;
    align-items: baseline;
    gap: 6px;
}

.gd-team-name {
    font-size: 24px;
    font-weight: bold;
}

.gd-moneyline {
    font-size: 14px;
    font-weight: 500;
    opacity: 0.7;
}

.gd-spread-score {
    font-size: 18px;
    font-weight: 600;
    margin-top: 2px;
}

.gd-kalshi-price {
    font-size: 14px;
    font-weight: 600;
    margin-top: 6px;
    padding: 4px 10px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.08);
    font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    letter-spacing: 0.02em;
}

.gd-kalshi-price.underdog {
    color: #16a34a;
    background: rgba(22, 163, 74, 0.12);
}

.gd-kalshi-price.favorite {
    color: #dc2626;
    background: rgba(220, 38, 38, 0.12);
}

.gd-kalshi-price.live-glow {
    animation: kalshiGlow 2s ease-in-out infinite;
}

.gd-final-badge {
    font-size: 12px;
    font-weight: 600;
    margin-top: 6px;
    padding: 4px 10px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.08);
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.game-detail-vs {
    font-size: 20px;
    opacity: 0.8;
}

.gd-magic-btn {
    position: absolute;
    left: 16px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    padding: 8px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.gd-magic-btn:hover {
    background: #ddd;
    color: #333;
}

.gd-magic-btn.loading {
    pointer-events: none;
    opacity: 0.5;
}

.gd-magic-btn.loading svg {
    animation: spin 0.8s linear infinite;
}

.gd-close-btn {
    position: absolute;
    right: 16px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #666;
    font-size: 28px;
    cursor: pointer;
    padding: 4px 12px;
    border-radius: 4px;
}

.gd-close-btn:hover {
    background: #ddd;
    color: #333;
}

.game-detail-info {
    text-align: center;
    padding: 10px;
    background: #f5f5f5;
    font-size: 14px;
    color: #666;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    flex-wrap: wrap;
}

.gd-gametime {
    color: #333;
    font-weight: 500;
}

.gd-gametime a {
    color: inherit;
    text-decoration: none;
}

.gd-gametime a:hover {
    text-decoration: underline;
}

.gd-icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 6px;
    border-radius: 6px;
    color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s, color 0.2s;
}

.gd-icon-btn:hover {
    background: #e0e0e0;
    color: #333;
}

.gd-icon-btn svg {
    width: 20px;
    height: 20px;
}

.team-stats-row {
    display: flex;
    justify-content: center;
    gap: 16px;
    padding: 8px 16px;
    background: #fafafa;
    border-bottom: 1px solid #eee;
}

.team-stats-panel {
    display: flex;
    gap: 24px;
    align-items: center;
}

.team-stat-item {
    text-align: center;
}

.team-stat-value {
    font-size: 16px;
    font-weight: 600;
    color: #333;
}

.team-stat-label {
    font-size: 10px;
    color: #888;
    text-transform: uppercase;
}

.game-detail-body {
    display: flex;
    flex: 1;
    overflow: hidden;
}

.team-roster-panel {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
    border-right: 1px solid #eee;
}

.team-roster-panel:last-child {
    border-right: none;
}

.team-roster-panel h3 {
    margin: 0 0 12px 0;
    font-size: 18px;
    text-align: center;
}

.roster-columns {
    display: flex;
    gap: 12px;
    height: calc(100% - 40px);
    justify-content: center;
}

.roster-column {
    flex: 1;
    min-width: 0;
    max-width: 220px;
    background: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

.roster-column h4 {
    margin: 0 0 10px 0;
    font-size: 14px;
    text-align: center;
    color: #666;
    padding-bottom: 8px;
    border-bottom: 2px solid #ddd;
}

/* Starters and bench column colors are set dynamically via inline styles */
/* Keeping these as fallbacks */
.starters-column { background: #e8f5e9; }
.starters-column h4 { border-color: #4caf50; color: #2e7d32; }

.bench-column { background: #e8e8e8; }
.bench-column h4 { border-color: #888; color: #666; }

.injured-column { background: #ffebee; }
.injured-column h4 { border-color: #f44336; color: #c62828; }

.player-list {
    flex: 1;
    overflow-y: auto;
    min-height: 100px;
}

.player-card {
    position: relative;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background: white;
    border-radius: 6px;
    margin-bottom: 6px;
    cursor: grab;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: transform 0.15s, box-shadow 0.15s;
}

.player-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}

.player-card.dragging {
    opacity: 0.5;
    transform: scale(1.02);
}

.player-card img {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    background: #eee;
}

.player-card-info {
    flex: 1;
    min-width: 0;
}

.player-card-name {
    font-size: 13px;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-card-name a {
    color: inherit;
    text-decoration: none;
}

.player-card-name a:hover {
    text-decoration: underline;
}

.player-card-pos {
    font-size: 11px;
    color: #888;
}

.player-card-stats {
    font-size: 10px;
    color: #666;
}

.player-exclude-toggle {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
    color: #999;
    cursor: pointer;
    opacity: 0;
    transition: all 0.2s;
}

.player-card:hover .player-exclude-toggle {
    opacity: 1;
}

.player-exclude-toggle:hover {
    background: #ef4444;
    color: white;
}

.player-card.excluded {
    opacity: 0.5;
}

.player-card.excluded .player-exclude-toggle {
    opacity: 1;
    background: #ef4444;
    color: white;
}

.roster-column.drag-over {
    background: #e3f2fd;
    border: 2px dashed #2196f3;
}

.roster-search-wrapper {
    position: relative;
    margin: 4px auto 8px;
    width: 50%;
}
.roster-search-input {
    width: 100%;
    height: 28px;
    padding: 0 8px;
    font-size: 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    outline: none;
    box-sizing: border-box;
}
.roster-search-input:focus {
    border-color: #2196f3;
}
.roster-search-results {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 240px;
    overflow-y: auto;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 20;
    display: none;
}
.roster-search-results.active {
    display: block;
}
.roster-search-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    cursor: pointer;
    font-size: 12px;
}
.roster-search-item:hover,
.roster-search-item.active {
    background: #f0f0f0;
}
.roster-search-item img {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    object-fit: cover;
    background: #eee;
}
.roster-search-item .search-player-info {
    flex: 1;
    min-width: 0;
}
.roster-search-item .search-player-name {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.roster-search-item .search-player-meta {
    font-size: 10px;
    color: #888;
}

.game-detail-footer {
    display: flex;
    justify-content: center;
    gap: 12px;
    padding: 16px;
    background: #f5f5f5;
    border-top: 1px solid #eee;
}

.gd-action-btn {
    padding: 10px 24px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
}

.run-prediction-btn {
    background: #4caf50;
    color: white;
}

.run-prediction-btn:hover {
    background: #388e3c;
}

.gd-action-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
}

/* Player Detail Panel Styles */
.player-detail-panel {
    position: absolute;
    top: 0;
    right: -320px;
    width: 300px;
    height: 100%;
    background: #fff;
    border-left: 1px solid #ddd;
    box-shadow: -4px 0 12px rgba(0,0,0,0.1);
    transition: right 0.3s ease;
    z-index: 10;
    display: flex;
    flex-direction: column;
}

.player-detail-panel.open {
    right: 0;
}

.player-panel-header {
    display: flex;
    justify-content: flex-end;
    padding: 8px 12px;
    border-bottom: 1px solid #eee;
}

.player-panel-close {
    background: none;
    border: none;
    font-size: 24px;
    color: #666;
    cursor: pointer;
    padding: 4px 8px;
}

.player-panel-close:hover {
    color: #333;
}

.player-panel-content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.player-panel-headshot {
    text-align: center;
    margin-bottom: 16px;
}

.player-panel-headshot img {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    background: #f5f5f5;
    border: 3px solid #e0e0e0;
}

.player-panel-name {
    font-size: 18px;
    font-weight: bold;
    text-align: center;
    margin-bottom: 4px;
}

.player-panel-name a {
    color: inherit;
    text-decoration: none;
}

.player-panel-name a:hover {
    text-decoration: underline;
}

.player-panel-pos {
    font-size: 14px;
    color: #666;
    text-align: center;
    margin-bottom: 8px;
}

.player-panel-size {
    font-size: 13px;
    color: #888;
    text-align: center;
    margin-bottom: 20px;
}

.player-panel-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
}

.stat-item {
    text-align: center;
    padding: 12px 8px;
    background: #f8f9fa;
    border-radius: 8px;
}

.stat-value {
    font-size: 20px;
    font-weight: bold;
    color: #333;
    margin-bottom: 4px;
}

.stat-label {
    font-size: 11px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.per-loading {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #e0e0e0;
    border-top-color: #2196f3;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.player-panel-news {
    margin-top: 16px;
    padding: 12px;
    background: #f8f9fa;
    border-radius: 8px;
    display: none;  /* Hidden until loaded */
}

.player-panel-news.loaded {
    display: block;
}

.news-header {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
}

.news-content {
    font-size: 13px;
    line-height: 1.5;
    color: #333;
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.news-loading {
    color: #888;
    font-style: italic;
}

.news-source {
    margin-top: 8px;
    font-size: 11px;
    color: #888;
}

.news-source a {
    color: #2196f3;
    text-decoration: none;
}

.news-source a:hover {
    text-decoration: underline;
}

.news-error {
    color: #c00;
    font-style: italic;
}

.news-unavailable {
    color: #888;
    font-style: italic;
}

.player-panel-move {
    margin-top: 20px;
    padding-top: 16px;
    border-top: 1px solid #eee;
}
.move-search-wrapper {
    position: relative;
}
.move-team-input {
    width: 100%;
    height: 32px;
    padding: 0 10px;
    font-size: 13px;
    border: 1px solid #ccc;
    border-radius: 6px;
    outline: none;
    box-sizing: border-box;
}
.move-team-input:focus {
    border-color: #2196f3;
}
.move-search-results {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 30;
    display: none;
}
.move-search-results.active {
    display: block;
}
.move-team-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 10px;
    cursor: pointer;
    font-size: 13px;
}
.move-team-item:hover {
    background: #f0f0f0;
}
.move-team-item img {
    width: 20px;
    height: 20px;
    object-fit: contain;
}
.move-team-item .move-team-abbrev {
    font-weight: 600;
}
.move-team-item .move-team-name {
    color: #888;
    font-size: 11px;
}

.player-panel-drop {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid #eee;
    text-align: center;
}
.drop-player-btn {
    background: #fff;
    color: #dc3545;
    border: 1px solid #dc3545;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}
.drop-player-btn:hover {
    background: #dc3545;
    color: #fff;
}

/* Make player cards clickable */
.player-card {
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
}

.player-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.player-card.selected {
    border: 2px solid #2196f3;
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
}
</style>

<script>
// ========== Game Detail Modal ==========
let currentGameIndex = 0;
let gamesList = [];
let currentGameData = null;

function resetGameDetailHeader() {
    // Clear team names and moneylines
    document.getElementById('gd-away-team').textContent = '';
    document.getElementById('gd-home-team').textContent = '';
    document.getElementById('gd-away-ml').textContent = '';
    document.getElementById('gd-home-ml').textContent = '';

    // Clear/reset logos
    document.getElementById('gd-away-logo').src = '';
    document.getElementById('gd-home-logo').src = '';

    // Clear spreads/scores
    document.getElementById('gd-away-spread-score').textContent = '';
    document.getElementById('gd-home-spread-score').textContent = '';

    // Clear Kalshi prices
    const awayKalshiEl = document.getElementById('gd-away-kalshi');
    const homeKalshiEl = document.getElementById('gd-home-kalshi');
    awayKalshiEl.textContent = '';
    awayKalshiEl.style.display = 'none';
    homeKalshiEl.textContent = '';
    homeKalshiEl.style.display = 'none';

    // Clear game info
    document.getElementById('gd-game-date').textContent = 'Loading...';
    document.getElementById('gd-gametime').innerHTML = '';
    document.getElementById('gd-prediction-info').textContent = '';

    // Clear team stats row
    document.getElementById('gd-team-stats-row').innerHTML = '';
}

function openGameDetail(gameId, gameDate) {
    // Clear excluded players from previous game
    if (typeof clearExcludedPlayers === 'function') {
        clearExcludedPlayers();
    }

    // Build list of games from the page (in display order)
    const gameCards = document.querySelectorAll('.game-card');
    gamesList = Array.from(gameCards).map(card => ({
        gameId: card.getAttribute('data-game-id'),
        gameDate: card.getAttribute('data-game-date') || gameDate
    }));

    // Find current game index
    currentGameIndex = gamesList.findIndex(g => g.gameId === gameId);
    if (currentGameIndex === -1) currentGameIndex = 0;

    // Update URL with game_id param
    updateGameIdInUrl(gameId);

    // Reset header to loading state before showing modal (prevents stale data flash)
    resetGameDetailHeader();

    // Load and show modal
    loadGameDetail(gameId, gameDate);
    document.getElementById('game-detail-modal').style.display = 'flex';
}

function closeGameDetail() {
    document.getElementById('game-detail-modal').style.display = 'none';
    currentGameData = null;

    // Close player panel if open
    const playerPanel = document.getElementById('player-detail-panel');
    if (playerPanel) playerPanel.classList.remove('open');

    // Remove game_id from URL
    removeGameIdFromUrl();
}

function navigateGame(direction) {
    const newIndex = currentGameIndex + direction;
    if (newIndex < 0 || newIndex >= gamesList.length) return;

    // Close player panel when navigating games
    const playerPanel = document.getElementById('player-detail-panel');
    if (playerPanel) playerPanel.classList.remove('open');

    currentGameIndex = newIndex;
    const game = gamesList[currentGameIndex];

    // Update URL with new game_id
    updateGameIdInUrl(game.gameId);

    // Reset header to loading state before loading new game (prevents stale data flash)
    resetGameDetailHeader();

    loadGameDetail(game.gameId, game.gameDate);
}

function updateGameIdInUrl(gameId) {
    const url = new URL(window.location);
    url.searchParams.set('game_id', gameId);
    window.history.replaceState({}, '', url);
}

function removeGameIdFromUrl() {
    const url = new URL(window.location);
    url.searchParams.delete('game_id');
    window.history.replaceState({}, '', url);
}

async function loadGameDetail(gameId, gameDate) {
    // Update nav buttons
    document.querySelector('.nav-prev').disabled = currentGameIndex === 0;
    document.querySelector('.nav-next').disabled = currentGameIndex === gamesList.length - 1;

    // Show loading state
    const body = document.querySelector('.game-detail-body');
    body.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:200px;"><div class="spinner"></div></div>';

    try {
        const response = await fetch(apiUrl(`/api/game-detail/${gameId}?date=${gameDate}`));
        const data = await response.json();

        if (!data.success) {
            body.innerHTML = `<div style="padding:40px;text-align:center;color:#d32f2f;">${data.error || 'Failed to load game'}</div>`;
            return;
        }

        console.log('Game detail data:', data);
        console.log('Home players:', data.home_players?.length || 0);
        console.log('Away players:', data.away_players?.length || 0);

        currentGameData = data;
        renderGameDetail(data);
    } catch (error) {
        console.error('Error loading game detail:', error);
        body.innerHTML = `<div style="padding:40px;text-align:center;color:#d32f2f;">Error: ${error.message}</div>`;
    }
}

function renderGameDetail(data) {
    // Update header - team logos and names
    document.getElementById('gd-away-logo').src = data.away_team_logo || '';
    document.getElementById('gd-away-team').textContent = data.away_team;
    document.getElementById('gd-away-team').style.color = '#' + data.away_team_color;
    document.getElementById('gd-home-logo').src = data.home_team_logo || '';
    document.getElementById('gd-home-team').textContent = data.home_team;
    document.getElementById('gd-home-team').style.color = '#' + data.home_team_color;

    // Moneylines next to team names (like game cards)
    const lines = data.pregame_lines || {};
    const awayMlEl = document.getElementById('gd-away-ml');
    const homeMlEl = document.getElementById('gd-home-ml');

    if (lines.away_ml != null) {
        const awayML = lines.away_ml >= 0 ? `+${lines.away_ml}` : `${lines.away_ml}`;
        awayMlEl.textContent = `(${awayML})`;
        awayMlEl.style.color = '#' + data.away_team_color;
    } else {
        awayMlEl.textContent = '';
    }

    if (lines.home_ml != null) {
        const homeML = lines.home_ml >= 0 ? `+${lines.home_ml}` : `${lines.home_ml}`;
        homeMlEl.textContent = `(${homeML})`;
        homeMlEl.style.color = '#' + data.home_team_color;
    } else {
        homeMlEl.textContent = '';
    }

    // Spread or Score below team names (like game cards)
    const awaySpreadScoreEl = document.getElementById('gd-away-spread-score');
    const homeSpreadScoreEl = document.getElementById('gd-home-spread-score');

    // Show scores if game is in progress or completed (status: 'in' or 'post')
    const gameInProgressOrComplete = data.status === 'in' || data.status === 'post';
    if (gameInProgressOrComplete && data.away_score != null && data.home_score != null) {
        // Game in progress or completed - show scores
        awaySpreadScoreEl.textContent = data.away_score;
        awaySpreadScoreEl.style.color = '#' + data.away_team_color;
        homeSpreadScoreEl.textContent = data.home_score;
        homeSpreadScoreEl.style.color = '#' + data.home_team_color;
    } else if (lines.spread != null) {
        // Game not started - show spread
        const awaySpread = -lines.spread;
        const awaySpreadStr = awaySpread >= 0 ? `+${awaySpread.toFixed(1)}` : `${awaySpread.toFixed(1)}`;
        const homeSpreadStr = lines.spread >= 0 ? `+${lines.spread.toFixed(1)}` : `${lines.spread.toFixed(1)}`;
        awaySpreadScoreEl.textContent = awaySpreadStr;
        awaySpreadScoreEl.style.color = '#' + data.away_team_color;
        homeSpreadScoreEl.textContent = homeSpreadStr;
        homeSpreadScoreEl.style.color = '#' + data.home_team_color;
    } else {
        awaySpreadScoreEl.textContent = '';
        homeSpreadScoreEl.textContent = '';
    }

    // Kalshi market prices or Final badge
    const awayKalshiEl = document.getElementById('gd-away-kalshi');
    const homeKalshiEl = document.getElementById('gd-home-kalshi');
    const marketData = window.marketDataCache ? window.marketDataCache[data.game_id] : null;

    // Use Kalshi market status to determine if market is closed
    const marketStatus = marketData?.status || 'active';
    const isMarketClosed = marketStatus === 'closed' || marketStatus === 'settled';

    if (isMarketClosed) {
        // Market closed - show Final badge
        awayKalshiEl.className = 'gd-final-badge';
        awayKalshiEl.textContent = 'Final';
        awayKalshiEl.style.display = '';
        homeKalshiEl.style.display = 'none';
    } else if (marketData) {
        const awayProb = marketData.away_yes_price;
        const homeProb = marketData.home_yes_price;

        const awayClass = awayProb < 0.5 ? 'underdog' : 'favorite';
        const homeClass = homeProb < 0.5 ? 'underdog' : 'favorite';

        awayKalshiEl.className = `gd-kalshi-price live-glow ${awayClass}`;
        awayKalshiEl.textContent = formatKalshiPrice(awayProb);
        awayKalshiEl.style.display = '';

        homeKalshiEl.className = `gd-kalshi-price live-glow ${homeClass}`;
        homeKalshiEl.textContent = formatKalshiPrice(homeProb);
        homeKalshiEl.style.display = '';
    } else {
        awayKalshiEl.style.display = 'none';
        homeKalshiEl.style.display = 'none';
    }

    document.getElementById('gd-game-date').textContent = data.game_date;

    // Gametime (convert to ET display) - link to ESPN game page
    const gametimeEl = document.getElementById('gd-gametime');
    if (data.gametime) {
        try {
            const gameDate = new Date(data.gametime);
            const etOptions = { hour: 'numeric', minute: '2-digit', timeZone: 'America/New_York' };
            const timeText = gameDate.toLocaleTimeString('en-US', etOptions) + ' ET';
            const espnUrl = `https://www.espn.com/${window.ESPN_LEAGUE_SLUG}/game/_/gameId/${data.game_id}`;
            gametimeEl.innerHTML = `<a href="${espnUrl}" target="_blank" onclick="event.stopPropagation();">${timeText}</a>`;
            gametimeEl.style.display = '';
        } catch (e) {
            gametimeEl.style.display = 'none';
        }
    } else {
        gametimeEl.style.display = 'none';
    }

    // Prediction info with predicted score and American odds
    const predInfoEl = document.getElementById('gd-prediction-info');
    predInfoEl.textContent = '';
    predInfoEl.style.color = '';

    if (data.last_prediction) {
        const homeProb = data.last_prediction.home_win_prob;
        const homePredScore = data.last_prediction.home_points_pred;
        const awayPredScore = data.last_prediction.away_points_pred;
        if (homeProb != null) {
            // Determine favored team
            const homeFavored = homeProb >= 50;
            const favoredTeam = homeFavored ? data.home_team : data.away_team;
            const favoredProb = homeFavored ? homeProb : (100 - homeProb);
            const favoredColor = homeFavored ? data.home_team_color : data.away_team_color;

            // Calculate American odds from probability
            const probDecimal = favoredProb / 100;
            let americanOdds;
            if (probDecimal >= 0.5) {
                // Favorite: negative odds
                americanOdds = Math.round(-(probDecimal / (1 - probDecimal)) * 100);
            } else {
                // Underdog: positive odds
                americanOdds = Math.round(((1 - probDecimal) / probDecimal) * 100);
            }
            const oddsStr = americanOdds >= 0 ? `+${americanOdds}` : `${americanOdds}`;

            let predInfo = `Prediction: ${favoredTeam} ${favoredProb.toFixed(0)}% (${oddsStr})`;
            if (homePredScore != null && awayPredScore != null) {
                predInfo += ` | ${Math.round(awayPredScore)}-${Math.round(homePredScore)}`;
            }
            predInfoEl.textContent = predInfo;
            predInfoEl.style.color = '#' + favoredColor;
            predInfoEl.style.fontWeight = '600';
        }
    }

    // Setup info and chat buttons
    const infoBtn = document.getElementById('gd-info-btn');
    const chatBtn = document.getElementById('gd-chat-btn');
    const homeTeamId = data.home_team_id || data.home_team;
    const awayTeamId = data.away_team_id || data.away_team;

    infoBtn.onclick = () => showGameFeatures(data.game_id, data.game_date, homeTeamId, awayTeamId);
    chatBtn.onclick = () => openMatchupChat(data.game_id, data.home_team, data.away_team, data.game_date);

    // Team stats row
    const statsRow = document.getElementById('gd-team-stats-row');
    const awayStats = data.away_team_stats || {};
    const homeStats = data.home_team_stats || {};
    statsRow.innerHTML = `
        <div class="team-stats-panel" style="color:#${data.away_team_color}">
            <div class="team-stat-item">
                <div class="team-stat-value">${awayStats.wins || 0}-${awayStats.losses || 0}</div>
                <div class="team-stat-label">W-L</div>
            </div>
            <div class="team-stat-item">
                <div class="team-stat-value">${awayStats.away_wins || 0}-${awayStats.away_losses || 0}</div>
                <div class="team-stat-label">Away</div>
            </div>
            <div class="team-stat-item">
                <div class="team-stat-value">${awayStats.home_wins || 0}-${awayStats.home_losses || 0}</div>
                <div class="team-stat-label">Home</div>
            </div>
            <div class="team-stat-item">
                <div class="team-stat-value">${awayStats.last10_wins || 0}-${awayStats.last10_losses || 0}</div>
                <div class="team-stat-label">L10</div>
            </div>
        </div>
        <div style="width: 1px; background: #ddd; margin: 0 16px;"></div>
        <div class="team-stats-panel" style="color:#${data.home_team_color}">
            <div class="team-stat-item">
                <div class="team-stat-value">${homeStats.wins || 0}-${homeStats.losses || 0}</div>
                <div class="team-stat-label">W-L</div>
            </div>
            <div class="team-stat-item">
                <div class="team-stat-value">${homeStats.home_wins || 0}-${homeStats.home_losses || 0}</div>
                <div class="team-stat-label">Home</div>
            </div>
            <div class="team-stat-item">
                <div class="team-stat-value">${homeStats.away_wins || 0}-${homeStats.away_losses || 0}</div>
                <div class="team-stat-label">Away</div>
            </div>
            <div class="team-stat-item">
                <div class="team-stat-value">${homeStats.last10_wins || 0}-${homeStats.last10_losses || 0}</div>
                <div class="team-stat-label">L10</div>
            </div>
        </div>
    `;

    // Helper to convert hex color to rgba with opacity
    function hexToRgba(hex, alpha) {
        if (!hex) hex = '667eea';
        const cleanHex = hex.replace('#', '');
        const num = parseInt(cleanHex, 16);
        const R = (num >> 16) & 0xFF;
        const G = (num >> 8) & 0xFF;
        const B = num & 0xFF;
        return `rgba(${R}, ${G}, ${B}, ${alpha})`;
    }

    // Create team color backgrounds with opacity for starters columns
    const awayStartersBg = hexToRgba(data.away_team_color, 0.15);
    const homeStartersBg = hexToRgba(data.home_team_color, 0.15);

    // Rebuild body
    const body = document.querySelector('.game-detail-body');

    body.innerHTML = `
        <div class="team-roster-panel away-panel">
            <h3 style="color:#${data.away_team_color}">${data.away_team}</h3>
            <div class="roster-search-wrapper">
                <input type="text" class="roster-search-input"
                       id="away-roster-search"
                       placeholder="Add player..."
                       data-side="away" data-team="${awayTeamId}"
                       autocomplete="off">
                <div class="roster-search-results" id="away-search-results"></div>
            </div>
            <div class="roster-columns">
                <div class="roster-column starters-column" data-column="starters" data-team="away" style="background: ${awayStartersBg};">
                    <h4 style="border-color: #${data.away_team_color}; color: #${data.away_team_color};">Starters</h4>
                    <div class="player-list" id="away-starters"></div>
                </div>
                <div class="roster-column bench-column" data-column="bench" data-team="away" style="background: #e8e8e8;">
                    <h4 style="border-color: #888; color: #666;">Bench</h4>
                    <div class="player-list" id="away-bench"></div>
                </div>
                <div class="roster-column injured-column" data-column="injured" data-team="away">
                    <h4>Injured</h4>
                    <div class="player-list" id="away-injured"></div>
                </div>
            </div>
        </div>
        <div class="team-roster-panel home-panel">
            <h3 style="color:#${data.home_team_color}">${data.home_team}</h3>
            <div class="roster-search-wrapper">
                <input type="text" class="roster-search-input"
                       id="home-roster-search"
                       placeholder="Add player..."
                       data-side="home" data-team="${homeTeamId}"
                       autocomplete="off">
                <div class="roster-search-results" id="home-search-results"></div>
            </div>
            <div class="roster-columns">
                <div class="roster-column starters-column" data-column="starters" data-team="home" style="background: ${homeStartersBg};">
                    <h4 style="border-color: #${data.home_team_color}; color: #${data.home_team_color};">Starters</h4>
                    <div class="player-list" id="home-starters"></div>
                </div>
                <div class="roster-column bench-column" data-column="bench" data-team="home" style="background: #e8e8e8;">
                    <h4 style="border-color: #888; color: #666;">Bench</h4>
                    <div class="player-list" id="home-bench"></div>
                </div>
                <div class="roster-column injured-column" data-column="injured" data-team="home">
                    <h4>Injured</h4>
                    <div class="player-list" id="home-injured"></div>
                </div>
            </div>
        </div>
    `;

    // Render players - pass internal team IDs for API calls
    renderPlayers('away', awayTeamId, data.away_players);
    renderPlayers('home', homeTeamId, data.home_players);

    // Setup drag and drop
    setupDragAndDrop();

    // Setup roster search
    initRosterSearch(data);

    // Fetch PER for all players in the background
    fetchAllPlayersPER(data);
}

// Store PER values for all players
let playerPERValues = {};

async function fetchAllPlayersPER(data) {
    // Reset PER values
    playerPERValues = {};

    // Build list of all players with their teams
    const allPlayers = [];
    const homeTeamId = data.home_team_id || data.home_team;
    const awayTeamId = data.away_team_id || data.away_team;

    for (const player of (data.home_players || [])) {
        allPlayers.push({
            player_id: player.player_id,
            team: homeTeamId
        });
    }
    for (const player of (data.away_players || [])) {
        allPlayers.push({
            player_id: player.player_id,
            team: awayTeamId
        });
    }

    if (allPlayers.length === 0) return;

    try {
        const response = await fetch(apiUrl('/api/players-per-batch'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                players: allPlayers,
                date: data.game_date,
                season: data.season
            })
        });

        const result = await response.json();
        if (result.success && result.per_values) {
            playerPERValues = result.per_values;
            console.log('Loaded PER for', Object.keys(playerPERValues).length, 'players');

            // Update the player panel if it's currently open
            updateOpenPanelPER();
        }
    } catch (error) {
        console.error('Error fetching batch PER:', error);
    }
}

function getPositionOrder(pos) {
    // Guard = 0, Forward = 1, Center = 2
    if (!pos) return 3;
    const posLower = pos.toLowerCase();
    if (posLower.includes('guard') || posLower === 'pg' || posLower === 'sg' || posLower === 'g') return 0;
    if (posLower.includes('forward') || posLower === 'sf' || posLower === 'pf' || posLower === 'f') return 1;
    if (posLower.includes('center') || posLower === 'c') return 2;
    return 3;
}

function getStartRate(player) {
    const stats = player.stats || {};
    const gp = stats.games || 0;
    const gs = stats.games_started || 0;
    if (gp === 0) return 0;
    return gs / gp;
}

function renderPlayers(side, team, players) {
    const startersEl = document.getElementById(`${side}-starters`);
    const benchEl = document.getElementById(`${side}-bench`);
    const injuredEl = document.getElementById(`${side}-injured`);

    startersEl.innerHTML = '';
    benchEl.innerHTML = '';
    injuredEl.innerHTML = '';

    // Separate players into columns
    const starters = [];
    const bench = [];
    const injured = [];

    for (const player of players) {
        if (player.injured) {
            injured.push(player);
        } else if (player.starter) {
            starters.push(player);
        } else {
            bench.push(player);
        }
    }

    // Sort starters by: 1) disabled last, 2) position (guard, forward, center)
    starters.sort((a, b) => {
        const aDisabled = a.disabled ? 1 : 0;
        const bDisabled = b.disabled ? 1 : 0;
        if (aDisabled !== bDisabled) return aDisabled - bDisabled;
        const posA = a.pos_display_name || a.pos_name || '';
        const posB = b.pos_display_name || b.pos_name || '';
        return getPositionOrder(posA) - getPositionOrder(posB);
    });

    // Sort bench by: 1) disabled last, 2) start rate descending
    bench.sort((a, b) => {
        const aDisabled = a.disabled ? 1 : 0;
        const bDisabled = b.disabled ? 1 : 0;
        if (aDisabled !== bDisabled) return aDisabled - bDisabled;
        return getStartRate(b) - getStartRate(a);
    });

    // Sort injured by: disabled last
    injured.sort((a, b) => {
        const aDisabled = a.disabled ? 1 : 0;
        const bDisabled = b.disabled ? 1 : 0;
        return aDisabled - bDisabled;
    });

    // Render each column
    for (const player of starters) {
        startersEl.appendChild(createPlayerCard(player, team));
    }
    for (const player of bench) {
        benchEl.appendChild(createPlayerCard(player, team));
    }
    for (const player of injured) {
        injuredEl.appendChild(createPlayerCard(player, team));
    }

    // Initialize excludedPlayers from DB disabled flags
    for (const player of players) {
        if (player.disabled) {
            excludedPlayers[side].add(String(player.player_id));
        }
    }
}

function createPlayerCard(player, team) {
    const card = document.createElement('div');
    card.className = 'player-card' + (player.disabled ? ' excluded' : '');
    card.draggable = true;
    card.dataset.playerId = player.player_id;
    card.dataset.team = team;
    card.dataset.playerName = player.player_name;
    card.dataset.headshot = player.headshot || '';
    card.dataset.position = player.pos_display_name || player.pos_name || '';
    card.dataset.startRate = getStartRate(player).toFixed(4);

    const headshot = player.headshot || 'https://a.espncdn.com/combiner/i?img=/i/headshots/nophoto.png';
    const stats = player.stats || {};
    const ppg = stats.ppg != null ? stats.ppg.toFixed(1) : '-';
    const rpg = stats.rpg != null ? stats.rpg.toFixed(1) : '-';
    const apg = stats.apg != null ? stats.apg.toFixed(1) : '-';

    const espnPlayerUrl = `https://www.espn.com/${window.ESPN_LEAGUE_SLUG}/player/_/id/${player.player_id}`;
    card.innerHTML = `
        <img src="${headshot}" alt="${player.player_name}" onerror="this.src='https://a.espncdn.com/combiner/i?img=/i/headshots/nophoto.png'">
        <div class="player-card-info">
            <div class="player-card-name"><a href="${espnPlayerUrl}" target="_blank" onclick="event.stopPropagation();">${player.player_name}</a></div>
            <div class="player-card-pos">${player.pos_display_name || player.pos_name || ''}</div>
            <div class="player-card-stats">${ppg}p ${rpg}r ${apg}a</div>
        </div>
        <div class="player-exclude-toggle" onclick="event.stopPropagation(); togglePlayerExcluded(this);" title="Exclude from prediction">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
            </svg>
        </div>
    `;

    // Click handler to open player detail panel
    card.addEventListener('click', (e) => {
        // Don't open panel if dragging or clicking exclude toggle
        if (e.target.closest('.player-card').classList.contains('dragging')) return;
        if (e.target.closest('.player-exclude-toggle')) return;
        openPlayerPanel(player.player_id, team, player.player_name, headshot, card.dataset.position);
    });

    return card;
}

// Track excluded players per team
const excludedPlayers = {
    home: new Set(),
    away: new Set()
};

function togglePlayerExcluded(toggleEl) {
    const card = toggleEl.closest('.player-card');
    const playerId = card.dataset.playerId;
    const team = card.dataset.team;
    const homeId = currentGameData?.home_team_id || currentGameData?.home_team;
    const side = team === homeId ? 'home' : 'away';

    const nowExcluded = !card.classList.contains('excluded');

    // Optimistic UI update
    if (nowExcluded) {
        card.classList.add('excluded');
        excludedPlayers[side].add(playerId);
    } else {
        card.classList.remove('excluded');
        excludedPlayers[side].delete(playerId);
    }

    // Re-sort the column to move disabled players to bottom
    const column = card.closest('.roster-column');
    if (column) {
        sortColumnCards(column);
    }

    // Persist to DB
    const pathMatch = window.location.pathname.match(/^\/([a-z]+)\//);
    const leaguePrefix = (pathMatch && pathMatch[1] !== 'api') ? '/' + pathMatch[1] : '';
    fetch(`${leaguePrefix}/api/update-player`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            game_id: currentGameData?.game_id,
            player_id: playerId,
            team: team,
            is_disabled: nowExcluded
        })
    }).catch(err => console.error('Failed to persist disabled state:', err));
}

function getExcludedPlayersConfig() {
    return {
        home_excluded: Array.from(excludedPlayers.home),
        away_excluded: Array.from(excludedPlayers.away)
    };
}

function clearExcludedPlayers() {
    excludedPlayers.home.clear();
    excludedPlayers.away.clear();
    document.querySelectorAll('.player-card.excluded').forEach(card => {
        card.classList.remove('excluded');
    });
}

function setupDragAndDrop() {
    const columns = document.querySelectorAll('.roster-column');
    const cards = document.querySelectorAll('.player-card');

    cards.forEach(card => {
        card.addEventListener('dragstart', handleDragStart);
        card.addEventListener('dragend', handleDragEnd);
    });

    columns.forEach(col => {
        col.addEventListener('dragover', handleDragOver);
        col.addEventListener('dragleave', handleDragLeave);
        col.addEventListener('drop', handleDrop);
    });
}

let draggedCard = null;

function handleDragStart(e) {
    draggedCard = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.roster-column').forEach(col => col.classList.remove('drag-over'));
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const column = e.target.closest('.roster-column');
    if (column && draggedCard) {
        // Only allow drop within same team
        const cardTeam = draggedCard.dataset.team;
        const colTeam = column.dataset.team;
        if ((colTeam === 'home' && cardTeam === currentGameData.home_team) ||
            (colTeam === 'away' && cardTeam === currentGameData.away_team)) {
            column.classList.add('drag-over');
        }
    }
}

function handleDragLeave(e) {
    const column = e.target.closest('.roster-column');
    if (column) {
        column.classList.remove('drag-over');
    }
}

async function handleDrop(e) {
    e.preventDefault();
    const column = e.target.closest('.roster-column');
    if (!column || !draggedCard) return;

    column.classList.remove('drag-over');

    const cardTeam = draggedCard.dataset.team;
    const colTeam = column.dataset.team;
    const colType = column.dataset.column;

    // Get internal team IDs for comparison
    const homeTeamId = currentGameData.home_team_id || currentGameData.home_team;
    const awayTeamId = currentGameData.away_team_id || currentGameData.away_team;

    // Validate same team (using internal IDs)
    if ((colTeam === 'home' && cardTeam !== homeTeamId) ||
        (colTeam === 'away' && cardTeam !== awayTeamId)) {
        return;
    }

    // Move card to new column
    const playerList = column.querySelector('.player-list');
    playerList.appendChild(draggedCard);

    // Determine new status
    const isStarter = colType === 'starters';
    const isInjured = colType === 'injured';
    const playerId = draggedCard.dataset.playerId;

    // Update via API
    try {
        const response = await fetch(apiUrl('/api/update-player'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                game_id: currentGameData.game_id,
                player_id: playerId,
                team: cardTeam,
                is_playing: !isInjured,
                is_starter: isStarter,
                is_injured: isInjured
            })
        });

        const result = await response.json();
        if (!result.success) {
            console.error('Failed to update player:', result.error);
        }
    } catch (error) {
        console.error('Error updating player:', error);
    }

    // Sort the column after drop
    sortColumnCards(column);
}

function sortColumnCards(column) {
    const colType = column.dataset.column;
    const playerList = column.querySelector('.player-list');
    const cards = Array.from(playerList.querySelectorAll('.player-card'));

    if (cards.length <= 1) return;

    // Primary sort: disabled/excluded players go to bottom
    // Secondary sort: by column-specific criteria
    cards.sort((a, b) => {
        const aExcluded = a.classList.contains('excluded') ? 1 : 0;
        const bExcluded = b.classList.contains('excluded') ? 1 : 0;

        // First sort by excluded status (non-excluded first)
        if (aExcluded !== bExcluded) {
            return aExcluded - bExcluded;
        }

        // Then sort by column-specific criteria
        if (colType === 'starters') {
            // Sort starters by position (guard, forward, center)
            const posA = a.dataset.position || '';
            const posB = b.dataset.position || '';
            return getPositionOrder(posA) - getPositionOrder(posB);
        } else if (colType === 'bench') {
            // Sort bench by start rate descending
            const rateA = parseFloat(a.dataset.startRate) || 0;
            const rateB = parseFloat(b.dataset.startRate) || 0;
            return rateB - rateA;
        }
        // Injured column - maintain order within enabled/disabled groups
        return 0;
    });

    // Re-append cards in sorted order
    cards.forEach(card => playerList.appendChild(card));
}

// ========== Roster Search ==========
let rosterSearchTimers = {};

function initRosterSearch(data) {
    ['away', 'home'].forEach(side => {
        const input = document.getElementById(`${side}-roster-search`);
        if (!input) return;

        input.addEventListener('input', () => {
            clearTimeout(rosterSearchTimers[side]);
            rosterSearchTimers[side] = setTimeout(() => {
                handleRosterSearch(side, input.value.trim(), data.season, data.game_date);
            }, 250);
        });

        input.addEventListener('keydown', (e) => {
            const results = document.getElementById(`${side}-search-results`);
            const items = results.querySelectorAll('.roster-search-item');
            let activeIdx = Array.from(items).findIndex(i => i.classList.contains('active'));

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (activeIdx >= 0) items[activeIdx].classList.remove('active');
                activeIdx = Math.min(activeIdx + 1, items.length - 1);
                if (items[activeIdx]) items[activeIdx].classList.add('active');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (activeIdx >= 0) items[activeIdx].classList.remove('active');
                activeIdx = Math.max(activeIdx - 1, 0);
                if (items[activeIdx]) items[activeIdx].classList.add('active');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const active = results.querySelector('.roster-search-item.active');
                if (active) active.click();
            } else if (e.key === 'Escape') {
                results.classList.remove('active');
                input.blur();
            }
        });
    });

    // Close dropdowns on outside click
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.roster-search-wrapper')) {
            document.querySelectorAll('.roster-search-results').forEach(r => r.classList.remove('active'));
        }
    });
}

async function handleRosterSearch(side, query, season, gameDate) {
    const results = document.getElementById(`${side}-search-results`);
    if (query.length < 2) {
        results.classList.remove('active');
        results.innerHTML = '';
        return;
    }

    try {
        const resp = await fetch(apiUrl(`/api/player-search?q=${encodeURIComponent(query)}&season=${encodeURIComponent(season)}`));
        const players = await resp.json();

        // Filter out players already on this side's roster
        const existingIds = new Set();
        document.querySelectorAll(`#${side}-starters .player-card, #${side}-bench .player-card, #${side}-injured .player-card`).forEach(card => {
            existingIds.add(String(card.dataset.playerId));
        });
        const filtered = players.filter(p => !existingIds.has(String(p.player_id)));

        if (filtered.length === 0) {
            results.innerHTML = '<div style="padding:8px;font-size:12px;color:#999;text-align:center;">No results</div>';
            results.classList.add('active');
            return;
        }

        const input = document.getElementById(`${side}-roster-search`);
        const team = input.dataset.team;

        results.innerHTML = filtered.map(p => {
            const hs = p.headshot || 'https://a.espncdn.com/combiner/i?img=/i/headshots/nophoto.png';
            const pos = p.pos_display_name || p.pos_name || '';
            const meta = [p.team, pos, `${p.games}g`].filter(Boolean).join(' · ');
            return `<div class="roster-search-item" data-player='${JSON.stringify(p).replace(/'/g, "&#39;")}'>
                <img src="${hs}" onerror="this.src='https://a.espncdn.com/combiner/i?img=/i/headshots/nophoto.png'">
                <div class="search-player-info">
                    <div class="search-player-name">${p.player_name}</div>
                    <div class="search-player-meta">${meta}</div>
                </div>
            </div>`;
        }).join('');

        results.querySelectorAll('.roster-search-item').forEach(item => {
            item.addEventListener('click', () => {
                const player = JSON.parse(item.dataset.player);
                selectSearchResult(side, team, player, season, gameDate);
            });
        });

        results.classList.add('active');
    } catch (err) {
        console.error('Roster search error:', err);
    }
}

async function selectSearchResult(side, team, player, season, gameDate) {
    const input = document.getElementById(`${side}-roster-search`);
    const results = document.getElementById(`${side}-search-results`);

    try {
        const resp = await fetch(apiUrl('/api/add-player-to-roster'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                player_id: player.player_id,
                team: team,
                season: season,
                game_date: gameDate
            })
        });
        const data = await resp.json();

        if (data.success && data.player) {
            const benchList = document.getElementById(`${side}-bench`);
            const card = createPlayerCard(data.player, team);
            benchList.appendChild(card);

            // Re-enable drag/drop on the new card
            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);

            sortColumnCards(benchList.closest('.roster-column'));
        } else {
            console.error('Failed to add player:', data.error);
        }
    } catch (err) {
        console.error('Error adding player to roster:', err);
    }

    input.value = '';
    results.classList.remove('active');
    results.innerHTML = '';
}

// ========== Player Detail Panel ==========
let selectedPlayerCard = null;
let selectedPlayerId = null;  // Track currently selected player for PER updates

function openPlayerPanel(playerId, team, playerName, headshot, position) {
    const panel = document.getElementById('player-detail-panel');

    // Track selected player ID for PER updates
    selectedPlayerId = String(playerId);

    // Remove selection from previous card
    if (selectedPlayerCard) {
        selectedPlayerCard.classList.remove('selected');
    }

    // Find and select the new card
    const cards = document.querySelectorAll('.player-card');
    cards.forEach(card => {
        if (card.dataset.playerId === playerId && card.dataset.team === team) {
            card.classList.add('selected');
            selectedPlayerCard = card;
        }
    });

    // Set initial content
    const defaultHeadshot = 'https://a.espncdn.com/combiner/i?img=/i/headshots/nophoto.png';
    document.getElementById('panel-player-headshot').src = headshot || defaultHeadshot;
    document.getElementById('panel-player-headshot').onerror = function() { this.src = defaultHeadshot; };
    const espnPlayerUrl = `https://www.espn.com/${window.ESPN_LEAGUE_SLUG}/player/_/id/${playerId}`;
    document.getElementById('panel-player-name').innerHTML = `<a href="${espnPlayerUrl}" target="_blank">${playerName}</a>`;
    document.getElementById('panel-player-pos').textContent = position;
    document.getElementById('panel-player-size').textContent = '';  // Reset until loaded

    // Reset stats to loading state
    document.getElementById('panel-stat-ppg').textContent = '-';
    document.getElementById('panel-stat-rpg').textContent = '-';
    document.getElementById('panel-stat-apg').textContent = '-';
    document.getElementById('panel-stat-gp').textContent = '-';
    document.getElementById('panel-stat-mpg').textContent = '-';

    // Show PER from pre-loaded values (or loading if not yet available)
    // Convert to string for consistent lookup
    const perValue = playerPERValues[String(playerId)];
    if (perValue !== undefined) {
        document.getElementById('panel-stat-per').textContent = perValue != null ? perValue.toFixed(1) : '-';
    } else {
        document.getElementById('panel-stat-per').innerHTML = '<span class="per-loading"></span>';
    }

    // Reset news section
    const newsSection = document.getElementById('panel-player-news');
    const newsContent = document.getElementById('panel-news-content');
    const newsSource = document.getElementById('panel-news-source');
    newsSection.classList.remove('loaded');
    newsContent.innerHTML = '<span class="news-loading">Loading...</span>';
    newsSource.innerHTML = '';

    // Open panel
    panel.classList.add('open');

    // Fetch player detail (basic stats)
    fetchPlayerDetail(playerId, team);

    // Fetch player news from Rotowire (if available for this league)
    fetchPlayerNews(playerId);
}

function closePlayerPanel() {
    const panel = document.getElementById('player-detail-panel');
    panel.classList.remove('open');

    // Remove selection
    if (selectedPlayerCard) {
        selectedPlayerCard.classList.remove('selected');
        selectedPlayerCard = null;
    }
    selectedPlayerId = null;
}

async function dropPlayerFromRoster() {
    if (!selectedPlayerId || !currentGameData) {
        console.error('No player selected or no game data');
        return;
    }

    // Get the team from the selected player's card
    const playerCard = selectedPlayerCard;
    if (!playerCard) {
        console.error('No player card selected');
        return;
    }

    const team = playerCard.dataset.team;
    if (!team) {
        console.error('Could not determine player team');
        return;
    }

    const playerName = document.getElementById('panel-player-name').textContent;
    if (!confirm(`Drop ${playerName} from ${team} roster?`)) {
        return;
    }

    try {
        const response = await fetch(apiUrl('/api/drop-player-from-roster'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                player_id: selectedPlayerId,
                team: team,
                season: currentGameData.season
            })
        });

        const data = await response.json();
        if (data.success) {
            // Remove the player card from the UI
            if (playerCard) {
                playerCard.remove();
            }
            closePlayerPanel();
        } else {
            alert(data.error || 'Failed to drop player');
        }
    } catch (error) {
        console.error('Error dropping player:', error);
        alert('Error dropping player from roster');
    }
}

// Close player panel when clicking outside it
document.addEventListener('click', function(e) {
    const panel = document.getElementById('player-detail-panel');
    if (!panel || !panel.classList.contains('open')) return;
    // If the click is inside the panel itself, ignore
    if (panel.contains(e.target)) return;
    // If the click is on a player card (which opens the panel), ignore
    if (e.target.closest('.player-card')) return;
    closePlayerPanel();
});

// Update PER in the open panel when batch PER values arrive
function updateOpenPanelPER() {
    if (!selectedPlayerId) return;

    const panel = document.getElementById('player-detail-panel');
    if (!panel.classList.contains('open')) return;

    const perValue = playerPERValues[selectedPlayerId];
    const perEl = document.getElementById('panel-stat-per');

    if (perValue !== undefined && perValue !== null) {
        perEl.textContent = perValue.toFixed(1);
    } else if (perValue === null) {
        perEl.textContent = '-';
    }
    // If undefined, PER hasn't loaded yet - leave spinner
}

async function fetchPlayerDetail(playerId, team) {
    if (!currentGameData) return;

    try {
        const params = new URLSearchParams({
            player_id: playerId,
            team: team,
            date: currentGameData.game_date,
            season: currentGameData.season
        });

        const response = await fetch(apiUrl(`/api/player-detail?${params}`));
        const data = await response.json();

        if (data.success && data.stats) {
            const stats = data.stats;
            document.getElementById('panel-stat-ppg').textContent = stats.ppg?.toFixed(1) ?? '-';
            document.getElementById('panel-stat-rpg').textContent = stats.rpg?.toFixed(1) ?? '-';
            document.getElementById('panel-stat-apg').textContent = stats.apg?.toFixed(1) ?? '-';
            document.getElementById('panel-stat-gp').textContent = `${stats.games ?? 0}/${stats.games_started ?? 0}`;
            document.getElementById('panel-stat-mpg').textContent = stats.mpg?.toFixed(1) ?? '-';

            // Update headshot if returned
            if (data.headshot) {
                document.getElementById('panel-player-headshot').src = data.headshot;
            }

            // Update height/weight
            const sizeEl = document.getElementById('panel-player-size');
            if (data.height && data.weight) {
                sizeEl.textContent = `${data.height} | ${data.weight} lbs`;
            } else if (data.height) {
                sizeEl.textContent = data.height;
            } else if (data.weight) {
                sizeEl.textContent = `${data.weight} lbs`;
            } else {
                sizeEl.textContent = '';
            }
        }
    } catch (error) {
        console.error('Error fetching player detail:', error);
    }
}

async function fetchPlayerNews(playerId) {
    const newsSection = document.getElementById('panel-player-news');
    const newsContent = document.getElementById('panel-news-content');
    const newsSource = document.getElementById('panel-news-source');

    try {
        const params = new URLSearchParams({
            player_id: playerId
        });

        const response = await fetch(apiUrl(`/api/player-news?${params}`));
        const data = await response.json();

        if (data.success && data.player_info) {
            // Show the news section
            newsSection.classList.add('loaded');

            // Display the extracted text (truncate if needed for display)
            const text = data.player_info;
            newsContent.textContent = text;

            // Add source link
            if (data.source_url) {
                newsSource.innerHTML = `<a href="${data.source_url}" target="_blank">View on Rotowire</a>`;
            }
        } else if (data.error && data.error.includes('not available for this league')) {
            // League doesn't have Rotowire support - hide the section silently
            newsSection.classList.remove('loaded');
        } else if (data.error && data.error.includes('not found in Rotowire mapping')) {
            // Player not in mapping - show as unavailable
            newsSection.classList.add('loaded');
            newsContent.innerHTML = '<span class="news-unavailable">No Rotowire data available for this player</span>';
        } else {
            // Other error - hide section
            newsSection.classList.remove('loaded');
        }
    } catch (error) {
        console.error('Error fetching player news:', error);
        // On error, just hide the section
        newsSection.classList.remove('loaded');
    }
}

async function fetchPlayerPER(playerId, team) {
    if (!currentGameData) return;

    try {
        const params = new URLSearchParams({
            player_id: playerId,
            team: team,
            date: currentGameData.game_date,
            season: currentGameData.season
        });

        const response = await fetch(apiUrl(`/api/player-per?${params}`));
        const data = await response.json();

        if (data.success && data.per != null) {
            document.getElementById('panel-stat-per').textContent = data.per.toFixed(1);
        } else {
            document.getElementById('panel-stat-per').textContent = '-';
        }
    } catch (error) {
        console.error('Error fetching player PER:', error);
        document.getElementById('panel-stat-per').textContent = '-';
    }
}

// ========== Move Player to Team ==========
let cachedTeamsList = null;

async function loadTeamsList() {
    if (cachedTeamsList) return cachedTeamsList;
    try {
        const response = await fetch(apiUrl('/api/teams-list'));
        cachedTeamsList = await response.json();
    } catch (e) {
        console.error('Error loading teams list:', e);
        cachedTeamsList = [];
    }
    return cachedTeamsList;
}

function initMoveToSearch() {
    const input = document.getElementById('panel-move-team');
    const resultsEl = document.getElementById('panel-move-results');
    if (!input || !resultsEl) return;

    input.addEventListener('input', async () => {
        const q = input.value.trim().toLowerCase();
        if (q.length < 1) {
            resultsEl.classList.remove('active');
            resultsEl.innerHTML = '';
            return;
        }

        const teams = await loadTeamsList();
        const matches = teams.filter(t =>
            (t.abbreviation && t.abbreviation.toLowerCase().includes(q)) ||
            (t.display_name && t.display_name.toLowerCase().includes(q))
        ).slice(0, 10);

        if (matches.length === 0) {
            resultsEl.classList.remove('active');
            resultsEl.innerHTML = '';
            return;
        }

        resultsEl.innerHTML = matches.map(t => {
            const logoHtml = t.logo ? `<img src="${t.logo}" alt="">` : '';
            return `<div class="move-team-item" data-team="${t.abbreviation || t.team_id}">
                ${logoHtml}
                <span class="move-team-abbrev">${t.abbreviation || t.team_id}</span>
                <span class="move-team-name">${t.display_name}</span>
            </div>`;
        }).join('');
        resultsEl.classList.add('active');

        resultsEl.querySelectorAll('.move-team-item').forEach(item => {
            item.addEventListener('click', () => {
                const toTeam = item.dataset.team;
                movePlayerToTeam(toTeam);
            });
        });
    });

    // Close dropdown on outside click
    input.addEventListener('blur', () => {
        setTimeout(() => {
            resultsEl.classList.remove('active');
            resultsEl.innerHTML = '';
        }, 200);
    });
}

async function movePlayerToTeam(toTeam) {
    if (!currentGameData || !selectedPlayerId) return;

    const input = document.getElementById('panel-move-team');
    const resultsEl = document.getElementById('panel-move-results');

    try {
        const response = await fetch(apiUrl('/api/move-player'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                player_id: selectedPlayerId,
                to_team: toTeam,
                season: currentGameData.season
            })
        });
        const data = await response.json();

        if (data.success) {
            // Clear input and close dropdown
            if (input) input.value = '';
            if (resultsEl) { resultsEl.classList.remove('active'); resultsEl.innerHTML = ''; }
            // Close player panel and reload game detail
            closePlayerPanel();
            loadGameDetail(currentGameData.game_id, currentGameData.game_date);
        } else {
            alert('Move failed: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        alert('Error moving player: ' + error.message);
    }
}

// Initialize move-to search when DOM is ready
document.addEventListener('DOMContentLoaded', () => { initMoveToSearch(); });

async function runGamePrediction() {
    if (!currentGameData) return;

    const btn = document.querySelector('.run-prediction-btn');
    btn.disabled = true;
    btn.textContent = 'Running...';

    try {
        const result = await runPredictionForGame(
            currentGameData.game_id,
            currentGameData.game_date,
            currentGameData.home_team_id || currentGameData.home_team,
            currentGameData.away_team_id || currentGameData.away_team
        );

        if (result.success) {
            // Reload modal to show prediction
            await loadGameDetail(currentGameData.game_id, currentGameData.game_date);
            // Also update the game card on the main page
            updateGameCardPrediction(currentGameData.game_id, result);
        } else {
            alert('Prediction failed: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        alert('Error running prediction: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Run Prediction';
    }
}

async function runCardPrediction(gameId, gameDate, homeTeam, awayTeam) {
    const predictIcon = document.querySelector(`[data-game-id="${gameId}"] .game-card-predict-icon`);
    if (!predictIcon) return;

    predictIcon.classList.add('loading');

    try {
        const result = await runPredictionForGame(gameId, gameDate, homeTeam, awayTeam);

        if (result.success) {
            // Update the game card
            updateGameCardPrediction(gameId, result);
            // Also update the modal if it's open for this game
            if (currentGameData && currentGameData.game_id === gameId) {
                await loadGameDetail(gameId, gameDate);
            }
        } else {
            alert('Prediction failed: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        alert('Error running prediction: ' + error.message);
    } finally {
        predictIcon.classList.remove('loading');
    }
}

async function runPredictionForGame(gameId, gameDate, homeTeam, awayTeam) {
    const body = {
        game_id: gameId,
        game_date: gameDate,
        home_team: homeTeam,
        away_team: awayTeam
    };

    const response = await fetch(apiUrl('/api/predict'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
    });
    return await response.json();
}

function updateGameCardPrediction(gameId, result) {
    const gameCard = document.querySelector(`[data-game-id="${gameId}"]`);
    if (!gameCard) return;

    // Prediction data is nested under result.prediction
    const pred = result.prediction || result;

    // Update the data attribute with new prediction
    gameCard.dataset.lastPrediction = JSON.stringify(pred);

    // Update prediction displays on the card
    const awayPanel = gameCard.querySelector('.team-panel.away');
    const homePanel = gameCard.querySelector('.team-panel.home');
    if (!awayPanel || !homePanel) return;

    // Remove existing prediction badges
    awayPanel.querySelectorAll('.prediction-banner, .points-prediction').forEach(el => el.remove());
    homePanel.querySelectorAll('.prediction-banner, .points-prediction').forEach(el => el.remove());

    // Add win probability badges
    if (pred.away_win_prob != null) {
        const awayBadge = document.createElement('div');
        awayBadge.className = 'prediction-banner';
        awayBadge.textContent = `${Math.round(pred.away_win_prob)}%${pred.away_odds != null ? ` (${pred.away_odds >= 0 ? '+' : ''}${Math.round(pred.away_odds)})` : ''}`;
        awayPanel.appendChild(awayBadge);
    }

    if (pred.home_win_prob != null) {
        const homeBadge = document.createElement('div');
        homeBadge.className = 'prediction-banner';
        homeBadge.textContent = `${Math.round(pred.home_win_prob)}%${pred.home_odds != null ? ` (${pred.home_odds >= 0 ? '+' : ''}${Math.round(pred.home_odds)})` : ''}`;
        homePanel.appendChild(homeBadge);
    }

    // Add points prediction badges
    if (pred.away_points_pred != null) {
        const awayPtsBadge = document.createElement('div');
        awayPtsBadge.className = 'points-prediction';
        awayPtsBadge.textContent = `${Math.round(pred.away_points_pred)} pts`;
        awayPanel.appendChild(awayPtsBadge);
    }

    if (pred.home_points_pred != null) {
        const homePtsBadge = document.createElement('div');
        homePtsBadge.className = 'points-prediction';
        homePtsBadge.textContent = `${Math.round(pred.home_points_pred)} pts`;
        homePanel.appendChild(homePtsBadge);
    }
}

// Close modal when clicking outside
document.getElementById('game-detail-modal')?.addEventListener('click', function(e) {
    if (e.target === this) {
        closeGameDetail();
    }
});

// Close modal on Escape key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const modal = document.getElementById('game-detail-modal');
        if (modal && modal.style.display !== 'none') {
            closeGameDetail();
        }
    }
});

// Check for game_id in URL on page load and open modal if present
document.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const gameId = urlParams.get('game_id');
    if (gameId) {
        // Get game date from URL or use the current date displayed on the page
        const gameDate = urlParams.get('date') || document.querySelector('[name="selected_date"]')?.value || new Date().toISOString().split('T')[0];
        // Small delay to ensure game cards are rendered
        setTimeout(() => {
            openGameDetail(gameId, gameDate);
        }, 100);
    }
});
</script>

<!-- Matchup Chat Modal -->
{% include 'matchup_chat_modal.html' %}

<script>
// Magic Analysis - opens chat and sends pre-defined analysis prompt
async function runMagicAnalysis(gameId, homeTeam, awayTeam, gameDate) {
    const magicIcon = document.querySelector(`[data-game-id="${gameId}"] .game-card-magic-icon`);
    if (magicIcon) {
        magicIcon.classList.add('loading');
    }

    try {
        // Open the matchup chat (this creates the session)
        await openMatchupChat(gameId, homeTeam, awayTeam, gameDate);

        // Wait a moment for the modal to open and session to be ready
        await new Promise(resolve => setTimeout(resolve, 300));

        // Now send the magic analysis message
        if (matchupChatSessionId) {
            const magicPrompt = "Break down this matchup statistically. Provide news, public/expert opinion, injury news, and predictions from the web.";

            // Set the input value and trigger send
            const input = document.getElementById('matchupChatInput');
            if (input) {
                input.value = magicPrompt;
                // Trigger the form submit
                const form = document.getElementById('matchupChatForm');
                if (form) {
                    form.dispatchEvent(new Event('submit', { cancelable: true }));
                }
            }
        }
    } catch (error) {
        console.error('Error running magic analysis:', error);
        alert(`Error: ${error.message}`);
    } finally {
        if (magicIcon) {
            magicIcon.classList.remove('loading');
        }
    }
}

async function runModalMagicAnalysis() {
    if (!currentGameData) return;
    const btn = document.querySelector('.gd-magic-btn');
    if (btn) btn.classList.add('loading');
    try {
        await runMagicAnalysis(
            currentGameData.game_id,
            currentGameData.home_team_id || currentGameData.home_team,
            currentGameData.away_team_id || currentGameData.away_team,
            currentGameData.game_date
        );
    } finally {
        if (btn) btn.classList.remove('loading');
    }
}

// Matchup Chat Functions
let matchupChatSessionId = null;

async function openMatchupChat(gameId, homeTeam, awayTeam, gameDate) {
    try {
        // Clear previous game's state immediately
        matchupChatSessionId = null;
        const messagesDiv = document.getElementById('matchupChatMessages');
        if (messagesDiv) messagesDiv.innerHTML = '';

        // Get game info from the game card element
        let gameInfo = {
            home_team: homeTeam,
            away_team: awayTeam,
            date: gameDate,
            game_id: gameId
        };

        // Try to extract game details from the game card element
        try {
            const gameCard = document.querySelector(`[data-game-id="${gameId}"]`);
            if (gameCard) {
                gameInfo.home_team_logo = gameCard.getAttribute('data-home-logo') || '';
                gameInfo.away_team_logo = gameCard.getAttribute('data-away-logo') || '';
                gameInfo.home_team_color = gameCard.getAttribute('data-home-color') || '667eea';
                gameInfo.away_team_color = gameCard.getAttribute('data-away-color') || '666666';
                const homePoints = gameCard.getAttribute('data-home-points');
                const awayPoints = gameCard.getAttribute('data-away-points');
                gameInfo.home_points = homePoints ? parseInt(homePoints) : null;
                gameInfo.away_points = awayPoints ? parseInt(awayPoints) : null;
                gameInfo.status = gameCard.getAttribute('data-game-status') || 'pre';
                gameInfo.gametime = gameCard.getAttribute('data-gametime') || '';

                // Parse pregame_lines and last_prediction
                try {
                    const pregameLinesStr = gameCard.getAttribute('data-pregame-lines');
                    if (pregameLinesStr) {
                        gameInfo.pregame_lines = JSON.parse(pregameLinesStr);
                    }
                } catch (e) {
                    gameInfo.pregame_lines = {};
                }

                try {
                    const lastPredictionStr = gameCard.getAttribute('data-last-prediction');
                    if (lastPredictionStr) {
                        gameInfo.last_prediction = JSON.parse(lastPredictionStr);
                    }
                } catch (e) {
                    gameInfo.last_prediction = {};
                }
            }
        } catch (e) {
            console.log('Could not get game card info:', e);
        }

        // Show modal immediately with game card data (fast)
        updateMatchupChatGameCard(gameInfo);
        const modal = document.getElementById('matchupChatModal');
        if (modal) {
            modal.style.display = 'flex';
        }

        // Create session + fetch game detail in parallel
        const [sessionResponse, detailData] = await Promise.all([
            fetch(apiUrl('/api/matchup-chat/sessions'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    game_id: gameId,
                    home_team: homeTeam,
                    away_team: awayTeam,
                    game_date: gameDate
                })
            }),
            fetch(apiUrl(`/api/game-detail/${gameId}?date=${gameDate}`))
                .then(r => r.ok ? r.json() : null)
                .catch(() => null)
        ]);

        if (!sessionResponse.ok) {
            const errorData = await sessionResponse.json().catch(() => ({ error: 'Failed to create session' }));
            alert(`Error: ${errorData.error || 'Failed to create chat session'}`);
            return;
        }

        const sessionData = await sessionResponse.json();
        matchupChatSessionId = sessionData.session_id;

        // Merge detail data into header if available
        if (detailData && detailData.success) {
            gameInfo.home_team_stats = detailData.home_team_stats;
            gameInfo.away_team_stats = detailData.away_team_stats;
            gameInfo.home_team_logo = detailData.home_team_logo || gameInfo.home_team_logo;
            gameInfo.away_team_logo = detailData.away_team_logo || gameInfo.away_team_logo;
            gameInfo.home_team_color = detailData.home_team_color || gameInfo.home_team_color;
            gameInfo.away_team_color = detailData.away_team_color || gameInfo.away_team_color;
            gameInfo.pregame_lines = detailData.pregame_lines || gameInfo.pregame_lines;
            gameInfo.last_prediction = detailData.last_prediction || gameInfo.last_prediction;
            gameInfo.status = detailData.status || gameInfo.status;
            gameInfo.gametime = detailData.gametime || gameInfo.gametime;
            gameInfo.game_id = detailData.game_id || gameId;
            updateMatchupChatGameCard(gameInfo);
        }

        // Load existing messages + focus input
        await loadMatchupChatMessages();
        const input = document.getElementById('matchupChatInput');
        if (input) input.focus();
    } catch (error) {
        console.error('Error opening matchup chat:', error);
        alert(`Error: ${error.message}`);
    }
}

function updateMatchupChatGameCard(game) {
    // Update header elements to match game detail modal style
    const homeTeam = game.home_team || game.homeTeam?.name || '';
    const awayTeam = game.away_team || game.awayTeam?.name || '';
    const gameDate = game.date || '';
    const homeLogo = game.home_team_logo || '';
    const awayLogo = game.away_team_logo || '';
    const homeColor = game.home_team_color || '333333';
    const awayColor = game.away_team_color || '333333';
    const pregameLines = game.pregame_lines || {};
    const lastPrediction = game.last_prediction || {};
    const homePoints = game.home_points || game.homeTeam?.points;
    const awayPoints = game.away_points || game.awayTeam?.points;
    const gametime = game.gametime;
    const homeStats = game.home_team_stats || {};
    const awayStats = game.away_team_stats || {};
    const gameId = game.game_id;

    // Minimal header bar team names
    const barAwayEl = document.getElementById('mc-bar-away');
    const barHomeEl = document.getElementById('mc-bar-home');
    if (barAwayEl) {
        barAwayEl.textContent = awayTeam;
        barAwayEl.style.color = '#' + awayColor;
    }
    if (barHomeEl) {
        barHomeEl.textContent = homeTeam;
        barHomeEl.style.color = '#' + homeColor;
    }

    // Away team elements
    const awayLogoEl = document.getElementById('mc-away-logo');
    const awayTeamEl = document.getElementById('mc-away-team');
    const awayMlEl = document.getElementById('mc-away-ml');
    const awaySpreadScoreEl = document.getElementById('mc-away-spread-score');
    const awayKalshiEl = document.getElementById('mc-away-kalshi');

    if (awayLogoEl) {
        awayLogoEl.src = awayLogo || '';
        awayLogoEl.style.display = awayLogo ? '' : 'none';
    }
    if (awayTeamEl) {
        awayTeamEl.textContent = awayTeam;
        awayTeamEl.style.color = '#' + awayColor;
    }
    if (awayMlEl) {
        if (pregameLines.away_ml !== undefined && pregameLines.away_ml !== null) {
            awayMlEl.textContent = `(${pregameLines.away_ml >= 0 ? '+' : ''}${pregameLines.away_ml})`;
            awayMlEl.style.display = '';
        } else {
            awayMlEl.style.display = 'none';
        }
    }
    const gameStatus = game.status || 'pre';
    const mcGameLiveOrDone = gameStatus === 'in' || gameStatus === 'post';

    if (awaySpreadScoreEl) {
        if (mcGameLiveOrDone && awayPoints !== undefined && awayPoints !== null) {
            awaySpreadScoreEl.textContent = awayPoints;
            awaySpreadScoreEl.style.color = '#' + awayColor;
            awaySpreadScoreEl.style.display = '';
        } else if (pregameLines.spread !== undefined && pregameLines.spread !== null) {
            const awaySpread = -pregameLines.spread;
            awaySpreadScoreEl.textContent = `${awaySpread >= 0 ? '+' : ''}${awaySpread.toFixed(1)}`;
            awaySpreadScoreEl.style.color = '#' + awayColor;
            awaySpreadScoreEl.style.display = '';
        } else {
            awaySpreadScoreEl.style.display = 'none';
        }
    }

    // Home team elements
    const homeLogoEl = document.getElementById('mc-home-logo');
    const homeTeamEl = document.getElementById('mc-home-team');
    const homeMlEl = document.getElementById('mc-home-ml');
    const homeSpreadScoreEl = document.getElementById('mc-home-spread-score');
    const homeKalshiEl = document.getElementById('mc-home-kalshi');

    if (homeLogoEl) {
        homeLogoEl.src = homeLogo || '';
        homeLogoEl.style.display = homeLogo ? '' : 'none';
    }
    if (homeTeamEl) {
        homeTeamEl.textContent = homeTeam;
        homeTeamEl.style.color = '#' + homeColor;
    }
    if (homeMlEl) {
        if (pregameLines.home_ml !== undefined && pregameLines.home_ml !== null) {
            homeMlEl.textContent = `(${pregameLines.home_ml >= 0 ? '+' : ''}${pregameLines.home_ml})`;
            homeMlEl.style.display = '';
        } else {
            homeMlEl.style.display = 'none';
        }
    }
    if (homeSpreadScoreEl) {
        if (mcGameLiveOrDone && homePoints !== undefined && homePoints !== null) {
            homeSpreadScoreEl.textContent = homePoints;
            homeSpreadScoreEl.style.color = '#' + homeColor;
            homeSpreadScoreEl.style.display = '';
        } else if (pregameLines.spread !== undefined && pregameLines.spread !== null) {
            homeSpreadScoreEl.textContent = `${pregameLines.spread >= 0 ? '+' : ''}${pregameLines.spread.toFixed(1)}`;
            homeSpreadScoreEl.style.color = '#' + homeColor;
            homeSpreadScoreEl.style.display = '';
        } else {
            homeSpreadScoreEl.style.display = 'none';
        }
    }

    // Kalshi prices (from marketDataCache if available)
    const marketData = window.marketDataCache ? window.marketDataCache[gameId] : null;
    const marketStatus = marketData?.status || 'active';
    const isMarketClosed = marketStatus === 'closed' || marketStatus === 'settled' || marketStatus === 'finalized';

    // Helper to format Kalshi price (fallback if global function not available)
    const mcFormatKalshiPrice = (prob) => {
        const pct = Math.round(prob * 100);
        let odds;
        if (prob >= 1) odds = '-∞';
        else if (prob <= 0) odds = '+∞';
        else if (prob === 0.5) odds = '-100';
        else if (prob > 0.5) odds = Math.round(-100 * prob / (1 - prob)).toString();
        else odds = '+' + Math.round(100 * (1 - prob) / prob);
        return `${pct}% (${odds})`;
    };

    if (awayKalshiEl && homeKalshiEl) {
        if (isMarketClosed) {
            awayKalshiEl.className = 'mc-final-badge';
            awayKalshiEl.textContent = 'Final';
            awayKalshiEl.style.display = '';
            homeKalshiEl.style.display = 'none';
        } else if (marketData && marketData.home_yes_price != null && marketData.away_yes_price != null) {
            const homeProb = marketData.home_yes_price;
            const awayProb = marketData.away_yes_price;
            const homeClass = homeProb >= 50 ? 'favorite' : 'underdog';
            const awayClass = awayProb >= 50 ? 'favorite' : 'underdog';

            awayKalshiEl.className = `mc-kalshi-price live-glow ${awayClass}`;
            awayKalshiEl.textContent = mcFormatKalshiPrice(awayProb);
            awayKalshiEl.style.display = '';

            homeKalshiEl.className = `mc-kalshi-price live-glow ${homeClass}`;
            homeKalshiEl.textContent = mcFormatKalshiPrice(homeProb);
            homeKalshiEl.style.display = '';
        } else {
            awayKalshiEl.style.display = 'none';
            homeKalshiEl.style.display = 'none';
        }
    }

    // Team stats row
    const statsRow = document.getElementById('mc-team-stats-row');
    if (statsRow) {
        if (Object.keys(awayStats).length > 0 || Object.keys(homeStats).length > 0) {
            statsRow.innerHTML = `
                <div class="mc-team-stats-panel" style="color:#${awayColor}">
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${awayStats.wins || 0}-${awayStats.losses || 0}</div>
                        <div class="mc-team-stat-label">W-L</div>
                    </div>
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${awayStats.away_wins || 0}-${awayStats.away_losses || 0}</div>
                        <div class="mc-team-stat-label">Away</div>
                    </div>
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${awayStats.home_wins || 0}-${awayStats.home_losses || 0}</div>
                        <div class="mc-team-stat-label">Home</div>
                    </div>
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${awayStats.last10_wins || 0}-${awayStats.last10_losses || 0}</div>
                        <div class="mc-team-stat-label">L10</div>
                    </div>
                </div>
                <div style="width: 1px; background: #ddd; margin: 0 16px;"></div>
                <div class="mc-team-stats-panel" style="color:#${homeColor}">
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${homeStats.wins || 0}-${homeStats.losses || 0}</div>
                        <div class="mc-team-stat-label">W-L</div>
                    </div>
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${homeStats.home_wins || 0}-${homeStats.home_losses || 0}</div>
                        <div class="mc-team-stat-label">Home</div>
                    </div>
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${homeStats.away_wins || 0}-${homeStats.away_losses || 0}</div>
                        <div class="mc-team-stat-label">Away</div>
                    </div>
                    <div class="mc-team-stat-item">
                        <div class="mc-team-stat-value">${homeStats.last10_wins || 0}-${homeStats.last10_losses || 0}</div>
                        <div class="mc-team-stat-label">L10</div>
                    </div>
                </div>
            `;
            statsRow.style.display = '';
        } else {
            statsRow.style.display = 'none';
        }
    }

    // Info row elements
    const gameDateEl = document.getElementById('mc-game-date');
    const gametimeEl = document.getElementById('mc-gametime');
    const predInfoEl = document.getElementById('mc-prediction-info');

    if (gameDateEl) {
        gameDateEl.textContent = gameDate || '';
    }
    if (gametimeEl) {
        if (gametime) {
            try {
                const gameDateTime = new Date(gametime);
                const etOptions = { hour: 'numeric', minute: '2-digit', timeZone: 'America/New_York' };
                gametimeEl.textContent = gameDateTime.toLocaleTimeString('en-US', etOptions) + ' ET';
                gametimeEl.style.display = '';
            } catch (e) {
                gametimeEl.style.display = 'none';
            }
        } else {
            gametimeEl.style.display = 'none';
        }
    }
    if (predInfoEl) {
        predInfoEl.textContent = '';
        predInfoEl.style.color = '';
        if (lastPrediction && lastPrediction.home_win_prob != null) {
            const homeProb = lastPrediction.home_win_prob;
            const homeFavored = homeProb >= 50;
            const favoredTeam = homeFavored ? homeTeam : awayTeam;
            const favoredProb = homeFavored ? homeProb : (100 - homeProb);
            const favoredColor = homeFavored ? homeColor : awayColor;

            // Calculate American odds
            const probDecimal = favoredProb / 100;
            let americanOdds;
            if (probDecimal >= 0.5) {
                americanOdds = Math.round(-(probDecimal / (1 - probDecimal)) * 100);
            } else {
                americanOdds = Math.round(((1 - probDecimal) / probDecimal) * 100);
            }
            const oddsStr = americanOdds >= 0 ? `+${americanOdds}` : `${americanOdds}`;

            let predInfo = `${favoredTeam} ${favoredProb.toFixed(0)}% (${oddsStr})`;
            if (lastPrediction.home_points_pred != null && lastPrediction.away_points_pred != null) {
                predInfo += ` | ${Math.round(lastPrediction.away_points_pred)}-${Math.round(lastPrediction.home_points_pred)}`;
            }
            predInfoEl.textContent = predInfo;
            predInfoEl.style.color = '#' + favoredColor;
        }
    }
}

function closeMatchupChat() {
    const modal = document.getElementById('matchupChatModal');
    if (modal) {
        modal.style.display = 'none';
    }
    matchupChatSessionId = null;
}

async function loadMatchupChatMessages() {
    if (!matchupChatSessionId) return;
    
    try {
        const response = await fetch(apiUrl(`/api/matchup-chat/sessions/${matchupChatSessionId}`));
        if (!response.ok) return;
        
        const data = await response.json();
        if (!data.success) return;
        
        const messages = data.session.messages || [];
        const messagesDiv = document.getElementById('matchupChatMessages');
        if (!messagesDiv) return;
        
        messagesDiv.innerHTML = '';
        
        for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            if (msg.role === 'user' || msg.role === 'assistant') {
                addMatchupMessage(msg.role, msg.content, i);
            }
        }
        
        scrollMatchupChatToBottom();
    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function addMatchupMessage(role, content, index = null) {
    const messagesDiv = document.getElementById('matchupChatMessages');
    if (!messagesDiv) return null;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `matchup-chat-message ${role}`;
    
    // Store message index and role for deletion
    if (index !== null) {
        messageDiv.setAttribute('data-message-index', index);
    }
    messageDiv.setAttribute('data-message-role', role);
    
    // Store plain text content for deletion
    const plainText = typeof content === 'string' ? content : String(content);
    messageDiv.setAttribute('data-plain-text', plainText.replace(/\\n/g, '\n'));
    
    // Create message bubble wrapper
    const messageBubble = document.createElement('div');
    messageBubble.className = 'message-bubble';
    
    // Add delete button
    const deleteButton = document.createElement('button');
    deleteButton.className = 'matchup-chat-delete-button';
    deleteButton.innerHTML = '×';
    deleteButton.title = 'Delete message';
    deleteButton.onclick = () => deleteMatchupMessage(deleteButton);
    messageBubble.appendChild(deleteButton);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    
    // Handle user messages - preserve newlines using CSS white-space: pre-wrap
    if (role === 'user') {
        if (typeof content === 'string') {
            // Unescape any escaped newlines and escape HTML to prevent XSS
            let contentToRender = content.replace(/\\n/g, '\n');
            contentToRender = contentToRender
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            contentDiv.textContent = contentToRender;
        }
    }
    // Render markdown for assistant messages
    else if (role === 'assistant') {
        try {
            // Check if marked is available
            const markedAvailable = typeof marked !== 'undefined' && (marked.parse || typeof marked === 'function');
            
            if (markedAvailable) {
                // Configure marked options
                if (typeof marked.setOptions === 'function') {
                    marked.setOptions({
                        breaks: true,
                        gfm: true
                    });
                } else if (typeof marked.use === 'function') {
                    marked.use({
                        breaks: true,
                        gfm: true
                    });
                }
                
                // Ensure content has proper line breaks preserved
                let contentToRender = content;
                if (typeof content === 'string') {
                    contentToRender = content.replace(/\\n/g, '\n');
                }
                
                // Render markdown to HTML
                let renderedContent;
                if (typeof marked.parse === 'function') {
                    renderedContent = marked.parse(contentToRender);
                } else if (typeof marked === 'function') {
                    renderedContent = marked(contentToRender);
                } else {
                    throw new Error('marked.parse is not available');
                }
                
                // Verify it's actually HTML
                if (!renderedContent || !renderedContent.includes('<')) {
                    renderedContent = contentToRender.replace(/\n/g, '<br>');
                }
                
                contentDiv.innerHTML = renderedContent;
            } else {
                // marked.js not loaded, use fallback
                let fallbackContent = content;
                if (typeof content === 'string') {
                    fallbackContent = content.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
                }
                contentDiv.innerHTML = fallbackContent;
            }
        } catch (e) {
            console.error('Error rendering markdown:', e);
            // Fallback: preserve newlines as <br> tags
            let fallbackContent = content;
            if (typeof content === 'string') {
                fallbackContent = content.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
            }
            contentDiv.innerHTML = fallbackContent;
        }
    }
    
    messageBubble.appendChild(contentDiv);
    messageDiv.appendChild(messageBubble);
    messagesDiv.appendChild(messageDiv);
    
    scrollMatchupChatToBottom();
    return messageDiv;
}

async function deleteMatchupMessage(button) {
    const messageDiv = button.closest('.matchup-chat-message');
    if (!messageDiv) return;
    
    const messageIndex = messageDiv.getAttribute('data-message-index');
    const role = messageDiv.getAttribute('data-message-role');
    const messageContent = messageDiv.getAttribute('data-plain-text') || '';
    
    if (!matchupChatSessionId) {
        // Just remove from DOM if no session
        messageDiv.remove();
        return;
    }
    
    try {
        const response = await fetch(apiUrl(`/api/matchup-chat/sessions/${matchupChatSessionId}/messages`), {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message_index: messageIndex !== null && messageIndex !== '' ? parseInt(messageIndex) : null,
                message_content: messageContent,
                message_role: role
            })
        });
        
        const data = await response.json();
        if (data.success) {
            // If this is a user message, populate the input field with its text
            if (role === 'user' && messageContent) {
                const input = document.getElementById('matchupChatInput');
                if (input) {
                    input.value = messageContent;
                    input.focus();
                    input.setSelectionRange(input.value.length, input.value.length);
                }
            }
            
            // Remove from DOM
            messageDiv.remove();
            
            // Reload messages to update indices
            await loadMatchupChatMessages();
        } else {
            alert('Error deleting message: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error deleting message:', error);
        alert('Error deleting message');
    }
}

function scrollMatchupChatToBottom() {
    const messagesDiv = document.getElementById('matchupChatMessages');
    if (messagesDiv) {
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
}

function addMatchupAgentAction(action) {
    // Display agent action in the chat (supports both tool_call and agent_output kinds)
    console.log('[MATCHUP_CHAT] Adding agent action:', action);
    const messagesDiv = document.getElementById('matchupChatMessages');
    if (!messagesDiv) {
        console.error('[MATCHUP_CHAT] messagesDiv not found!');
        return;
    }

    const actionDiv = document.createElement('div');
    actionDiv.className = 'matchup-chat-agent-action';

    const kind = action.kind || 'tool_call';
    const agentName = action.agent || 'unknown';
    const actionId = 'agent-action-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

    if (kind === 'agent_output') {
        // Agent output (e.g., planner plan, synthesizer output) - render as markdown
        const outputText = action.text || '';

        const actionHtml = `<div class="agent-action-header" onclick="toggleAgentActionContent('${actionId}')" style="cursor: pointer;">
            <span class="agent-action-expand-icon" id="${actionId}-icon">&#9654;</span>
            <span class="agent-action-icon">&#129302;</span>
            <span class="agent-action-name">${escapeHtml(agentName)}</span>
            <span class="agent-action-preview">${escapeHtml(outputText.substring(0, 60))}${outputText.length > 60 ? '...' : ''}</span>
        </div>
        <div class="agent-action-content" id="${actionId}" style="display: none;">
            <div class="agent-action-markdown">${renderMarkdown(outputText)}</div>
        </div>`;

        actionDiv.innerHTML = actionHtml;
    } else {
        // Tool call - expandable with full input/output
        const toolName = action.name || 'Unknown tool';
        const toolArgs = action.args || {};
        const toolOutput = action.output;

        // Format the tool args as a readable string
        let argsStr = '';
        try {
            if (typeof toolArgs === 'object') {
                argsStr = JSON.stringify(toolArgs, null, 2);
            } else {
                argsStr = String(toolArgs);
            }
        } catch (e) {
            argsStr = String(toolArgs);
        }

        // Format output
        let outputStr = '';
        if (toolOutput) {
            try {
                if (typeof toolOutput === 'object') {
                    outputStr = JSON.stringify(toolOutput, null, 2);
                } else {
                    outputStr = String(toolOutput);
                }
            } catch (e) {
                outputStr = String(toolOutput);
            }
        }

        // Create preview text
        let previewText = argsStr.replace(/\s+/g, ' ').substring(0, 50);
        if (argsStr.length > 50) previewText += '...';

        // Build the action display
        let actionHtml = `<div class="agent-action-header" onclick="toggleAgentActionContent('${actionId}')" style="cursor: pointer;">
            <span class="agent-action-expand-icon" id="${actionId}-icon">&#9654;</span>
            <span class="agent-action-icon">&#9881;</span>
            <span class="agent-action-name">${escapeHtml(agentName)}</span>
            <span class="agent-action-tool">&#8594; ${escapeHtml(toolName)}</span>
            <span class="agent-action-preview">${escapeHtml(previewText)}</span>
        </div>
        <div class="agent-action-content" id="${actionId}" style="display: none;">`;

        if (argsStr && argsStr !== '{}') {
            actionHtml += `<div class="agent-action-input">
                <div class="agent-action-label">Input:</div>
                <pre class="agent-action-code">${escapeHtml(argsStr)}</pre>
            </div>`;
        }

        if (outputStr) {
            actionHtml += `<div class="agent-action-output">
                <div class="agent-action-label">Output:</div>
                <pre class="agent-action-code">${escapeHtml(outputStr)}</pre>
            </div>`;
        }

        actionHtml += `</div>`;
        actionDiv.innerHTML = actionHtml;
    }

    messagesDiv.appendChild(actionDiv);
    scrollMatchupChatToBottom();
}

function toggleAgentActionContent(actionId) {
    const content = document.getElementById(actionId);
    const icon = document.getElementById(actionId + '-icon');
    if (content && icon) {
        if (content.style.display === 'none') {
            content.style.display = 'block';
            icon.innerHTML = '&#9660;'; // Down arrow
        } else {
            content.style.display = 'none';
            icon.innerHTML = '&#9654;'; // Right arrow
        }
    }
}

function renderMarkdown(text) {
    // Simple markdown renderer for agent outputs
    if (!text) return '';

    let html = escapeHtml(text);

    // Code blocks (```...```)
    html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre class="md-code-block"><code>$2</code></pre>');

    // Inline code (`...`)
    html = html.replace(/`([^`]+)`/g, '<code class="md-inline-code">$1</code>');

    // Bold (**...** or __...__)
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');

    // Italic (*...* or _..._)
    html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    html = html.replace(/_([^_]+)_/g, '<em>$1</em>');

    // Headers (# ... ## ... ### ...)
    html = html.replace(/^### (.+)$/gm, '<h4 class="md-h4">$1</h4>');
    html = html.replace(/^## (.+)$/gm, '<h3 class="md-h3">$1</h3>');
    html = html.replace(/^# (.+)$/gm, '<h2 class="md-h2">$1</h2>');

    // Bullet lists (- ... or * ...)
    html = html.replace(/^[\-\*] (.+)$/gm, '<li class="md-li">$1</li>');
    html = html.replace(/(<li class="md-li">.*<\/li>\n?)+/g, '<ul class="md-ul">$&</ul>');

    // Numbered lists (1. ... 2. ...)
    html = html.replace(/^\d+\. (.+)$/gm, '<li class="md-li-num">$1</li>');
    html = html.replace(/(<li class="md-li-num">.*<\/li>\n?)+/g, '<ol class="md-ol">$&</ol>');

    // Line breaks
    html = html.replace(/\n/g, '<br>');

    // Clean up extra <br> in lists
    html = html.replace(/<\/li><br>/g, '</li>');
    html = html.replace(/<br><li/g, '<li');

    return html;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function sendMatchupMessage(event) {
    event.preventDefault();
    
    const input = document.getElementById('matchupChatInput');
    if (!input) return;
    
    const message = input.value.trim();
    if (!message || !matchupChatSessionId) return;
    
    // Add user message to UI
    addMatchupMessage('user', message);
    input.value = '';
    
    // Show loading - create loading element properly
    const messagesDiv = document.getElementById('matchupChatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'matchup-chat-message assistant';
    loadingDiv.id = 'matchup-loading-message';
    const loadingContent = document.createElement('div');
    loadingContent.className = 'message-content';
    const loadingSpinner = document.createElement('div');
    loadingSpinner.className = 'matchup-chat-loading';
    loadingContent.appendChild(loadingSpinner);
    loadingDiv.appendChild(loadingContent);
    messagesDiv.appendChild(loadingDiv);
    scrollMatchupChatToBottom();
    
    try {
        // Get checkbox values
        const showAgentActionsCheckbox = document.getElementById('matchupChatShowAgentActions');
        const showAgentActions = showAgentActionsCheckbox ? showAgentActionsCheckbox.checked : false;
        console.log('[MATCHUP_CHAT] Checkbox found:', !!showAgentActionsCheckbox, 'Checked:', showAgentActions);

        const response = await fetch(apiUrl('/api/matchup-chat'), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                session_id: matchupChatSessionId,
                show_agent_actions: showAgentActions,
                memory: (() => {
                    const memoryInput = document.getElementById('matchupChatMemoryInput');
                    const memoryValue = memoryInput ? memoryInput.value.trim() : '';
                    return memoryValue === '' ? null : (parseInt(memoryValue) || null);
                })()
            })
        });

        // Remove loading message
        const messagesDiv = document.getElementById('matchupChatMessages');
        if (messagesDiv && messagesDiv.lastElementChild) {
            messagesDiv.removeChild(messagesDiv.lastElementChild);
        }

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Request failed' }));
            addMatchupMessage('assistant', `Error: ${errorData.error || 'Request failed'}`);
            return;
        }

        const data = await response.json();
        console.log('[MATCHUP_CHAT] Response data:', {
            success: data.success,
            showAgentActions,
            agentActionsCount: data.agent_actions?.length || 0,
            hasResponse: !!data.response
        });
        if (data.success) {
            // Show agent actions if checkbox is checked and actions are returned
            if (showAgentActions && data.agent_actions && data.agent_actions.length > 0) {
                console.log('[MATCHUP_CHAT] Displaying', data.agent_actions.length, 'agent actions');
                for (const action of data.agent_actions) {
                    addMatchupAgentAction(action);
                }
            }
            addMatchupMessage('assistant', data.response);
        } else {
            addMatchupMessage('assistant', `Error: ${data.error || 'Unknown error'}`);
        }
    } catch (error) {
        // Remove loading message
        const messagesDiv = document.getElementById('matchupChatMessages');
        if (messagesDiv && messagesDiv.lastElementChild) {
            messagesDiv.removeChild(messagesDiv.lastElementChild);
        }
        
        addMatchupMessage('assistant', `Error: ${error.message}`);
    }
}

// Handle textarea auto-resize
const matchupChatInput = document.getElementById('matchupChatInput');
if (matchupChatInput) {
    matchupChatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const form = document.getElementById('matchupChatForm');
            if (form) {
                form.dispatchEvent(new Event('submit'));
            }
        }
    });
}

// Close modal on escape key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const modal = document.getElementById('matchupChatModal');
        if (modal && modal.style.display !== 'none') {
            closeMatchupChat();
        }
    }
});
</script>

<style>
    .game-card-icons {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 8px;
        z-index: 10;
    }
    
    .game-card-info-icon,
    .game-card-message-icon,
    .game-card-predict-icon,
    .game-card-magic-icon {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .game-card-predict-icon:hover {
        background: #16a34a;
        color: white;
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .game-card-predict-icon.loading {
        background: #f0f0f0;
        pointer-events: none;
    }

    .game-card-predict-icon.loading svg {
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .game-card-info-icon:hover {
        background: #2196F3;
        color: white;
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .game-card-message-icon:hover {
        background: #667eea;
        color: white;
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .game-card-message-icon {
        position: relative;
    }

    .message-count-badge {
        position: absolute;
        top: -6px;
        right: -6px;
        background: #ef4444;
        color: white;
        font-size: 10px;
        font-weight: 600;
        min-width: 16px;
        height: 16px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    .game-card-info-icon svg,
    .game-card-message-icon svg,
    .game-card-predict-icon svg,
    .game-card-magic-icon svg {
        width: 16px;
        height: 16px;
    }

    .game-card-magic-icon {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }

    .game-card-magic-icon:hover {
        background: linear-gradient(135deg, #764ba2 0%, #f093fb 100%);
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4);
    }

    .game-card-magic-icon.loading {
        pointer-events: none;
        opacity: 0.7;
    }

    .game-card-magic-icon.loading svg {
        animation: sparkle 1s ease-in-out infinite;
    }

    @keyframes sparkle {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.7; }
    }

    .features-modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
    }
    
    .features-modal-content {
        background-color: #fff;
        margin: auto;
        padding: 0;
        border-radius: 8px;
        width: 90%;
        max-width: 900px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .features-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        border-bottom: 1px solid #e0e0e0;
        background: #f5f5f5;
        border-radius: 8px 8px 0 0;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .features-modal-header h2 {
        margin: 0;
        font-size: 1.5em;
        color: #333;
    }
    
    .close-modal {
        background: none;
        border: none;
        font-size: 2em;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s;
    }
    
    .close-modal:hover {
        background: #e0e0e0;
        color: #333;
    }
    
    .features-modal-body {
        padding: 20px;
    }
    
    .game-info {
        margin-bottom: 20px;
        padding: 15px;
        background: #f9f9f9;
        border-radius: 4px;
        border-left: 4px solid #2196F3;
    }
    
    .game-info strong {
        font-size: 1.2em;
        color: #333;
    }
    
    .game-info small {
        color: #666;
    }
    
    .feature-category {
        margin-bottom: 25px;
        background: #fafafa;
        border-radius: 8px;
        padding: 15px;
        border: 1px solid #eee;
    }

    .feature-category h3 {
        margin: 0 0 12px 0;
        font-size: 1.1em;
        color: #2196F3;
        font-weight: 600;
        padding-bottom: 8px;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .features-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
        table-layout: fixed;
    }

    .features-table thead {
        background: #f5f5f5;
    }

    .features-table th {
        padding: 10px;
        text-align: left;
        font-weight: 600;
        color: #666;
        border-bottom: 2px solid #e0e0e0;
    }

    .features-table th:first-child {
        width: 70%;
    }

    .features-table th:last-child {
        width: 30%;
        text-align: right;
    }

    .features-table td {
        padding: 10px;
        border-bottom: 1px solid #f0f0f0;
        vertical-align: middle;
    }

    .features-table tr:hover {
        background: #f9f9f9;
    }

    .feature-name {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        color: #333;
        font-size: 0.95em;
        word-break: break-word;
    }

    .feature-value {
        text-align: right;
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        color: #2196F3;
        font-weight: 600;
        font-size: 1em;
        white-space: nowrap;
    }

    /* Base Model Breakdown Styles */
    .base-model-breakdown h3 {
        color: #9c27b0 !important;
    }

    .base-model-section {
        transition: all 0.2s ease;
    }

    .base-model-section:hover {
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .base-model-header {
        transition: background 0.2s ease;
    }

    .base-model-header:hover {
        background: #eeeeee !important;
    }

    .base-model-features table {
        width: 100%;
        border-collapse: collapse;
    }

    .base-model-features tbody tr:hover {
        background: #f9f9f9;
    }

    .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #2196F3;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
{% endblock %}

